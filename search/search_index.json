{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#desarrollo-de-aplicaciones-multiplataforma-acceso-a-datos","title":"Desarrollo de Aplicaciones Multiplataforma -- Acceso a Datos","text":""},{"location":"#2025-2026","title":"2025 - 2026","text":"<p>Imagen de Jensen Art Co en Pixabay</p> <p>Professor:</p> <ul> <li>Jos\u00e9 Manuel Romero Mart\u00ednez   -- jm.romeromartinez@edu.gva.es</li> </ul>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/","title":"1. Sistema de archivos","text":""},{"location":"Unidad%201%20Ficheros/1_File_System.es/#11-introduccion","title":"1.1. Introducci\u00f3n","text":"<p>En los inicios de la inform\u00e1tica, los archivos eran el \u00fanico mecanismo para almacenar informaci\u00f3n. Hoy en d\u00eda, los sistemas operativos gestionan los dispositivos de almacenamiento de modo casi transparente para el usuario. Sin entrar en detalles de las tecnolog\u00edas de almacenamiento subyacentes, nos ofrecen una abstracci\u00f3n mediante la cual s\u00f3lo debemos preocuparnos por dos conceptos: archivos y directorios.</p> <ul> <li>Archivo \u2192 contenedores de informaci\u00f3n (de todo tipo y formato).</li> <li>Directorios \u2192 organizadoras de archivos, y pueden contener archivos y otros directorios.</li> </ul> <p>Sobre la informaci\u00f3n (el contenido del archivo), encontramos una clasificaci\u00f3n cl\u00e1sica:</p> <ul> <li>Archivo de texto \u2192 la informaci\u00f3n se almacena de forma que puede verse o abrirse con cualquier editor de texto plano, como vino, nano o notepad.</li> <li>Archivo binario \u2192 la informaci\u00f3n se almacena codificada en formato binario. Como ya sabe el estudiante, cualquier tipo de informaci\u00f3n (texto, n\u00fameros, fotos, etc.) puede traducirse a 0 y 1. En nuestro caso (programadoras), podemos transformar objetos y variables de diferentes formas.</li> </ul> <p>Importante tener en cuenta que...</p> <ul> <li>Aunque almacenemos informaci\u00f3n en archivos de texto, aparece un nuevo concepto: estructura. Si organizamos la informaci\u00f3n de diferentes formas, podemos hablar de archivos csv, archivos xml, archivos json. Los archivos csv, xml y json son estructuras, porque al fin y al cabo, todos ellos son archivos de texto. </li> <li>La gente piensa que los archivos de texto son d\u00e9biles para almacenar informaci\u00f3n, pero no es cierto. Las t\u00e9cnicas criptogr\u00e1ficas nos ofrecen m\u00e9todos para almacenar informaci\u00f3n de forma segura dentro de archivos de texto. Por ejemplo, <code>htpasswd</code> en apache o <code>/etc/shadow</code> en sistemas Linux. Abajo pueden verse un ejemplo de clave p\u00fablica PGP, almacenada en un archivo de texto.</li> </ul> <pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Alice's OpenPGP certificate\nComment: https://www.ietf.org/id/draft-bre-openpgp-samples-01.html\n\nmDMEXEcE6RYJKwYBBAHaRw8BAQdArjWwk3FAqyiFbFBKT4TzXcVBqPTB3gmzlC/U\nb7O1u120JkFsaWNlIExvdmVsYWNlIDxhbGljZUBvcGVucGdwLmV4YW1wbGU+iJAE\n...\nDAAKCRDyMVUMT0fjjlnQAQDFHUs6TIcxrNTtEZFjUFm1M0PJ1Dng/cDW4xN80fsn\n0QEA22Kr7VkCjeAEC08VSTeV+QFsmz55/lntWkwYWhmvOgE=\n=iIGO\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#12-accediendo-al-sistema-de-archivos-en-java","title":"1.2. Accediendo al sistema de archivos en Java","text":"<p><code>Java</code> nos ofrece varias formas de acceder al sistema de archivos. Esta forma es independiente del dispositivo subyacente que almacena la informaci\u00f3n. El dispositivo puede ser un disco duro, un disco ssd, unidad \u00f3ptica, etc. La clase que nos ofrece esta posibilidad es la clase File. Repasaremos los principales aspectos de esta clase y despu\u00e9s revisaremos algunos ejemplos.</p> <ul> <li> <p>El constructor de la clase est\u00e1 sobrecargado, como la mayor\u00eda de las clases de Java. Podemos utilizar: </p> </li> <li> <p><code>File(File pariente, String child)</code> \u2192 Crea una nueva instancia de File a partir de un directorio padre abstracto y una cadena de directorio hijo. </p> </li> <li><code>File(String pathname)</code> \u2192 Crea una nueva instancia de File convirtiendo la cadena de directorio dato en un directorio abstracto. </li> <li><code>File(String parent, String child)</code> \u2192 Crea una nueva instancia de File a partir de una cadena de directorio padre y una cadena de directorio hijo. </li> <li> <p><code>File(URI uri)</code> \u2192 Crea una nueva instancia de File convirtiendo el file: URI dado en un directorio abstracto.</p> </li> <li> <p>Para acceder al archivo debemos usar un n\u00famero de ruta. \u00c9sta es la ruta, y tenemos dos posibilidades: </p> </li> <li> <p>Ruta absoluta \u2192 la ruta desde el directorio ra\u00edz del sistema hasta el archivo que queremos, comenzando con <code>/</code> en sistemas Linux o <code>letra:</code> en sistemas Windows. Recuerda utilizar <code>/</code> para separar carpetas en Linux y <code>\\\\</code> en Windows. No es un error, ya que la barra invertida es un s\u00edmbolo con un significado propio, debemos escaparla, duplic\u00e1ndola para obtener el significado que queremos. </p> </li> <li>Ruta relativa \u2192 suponemos que el archivo que queremos se encuentra en la misma carpeta que el proyecto/programa que estamos ejecutando. En este caso, s\u00f3lo proporcionamos el nombre del archivo, sin ninguna carpeta al principio de la ruta.</li> </ul> <pre><code>// absolute paths\nFile f=new File(\"/home/manu/texto.md\") // Linux\nFile f=new File(\"C:\\\\Usuarios\\\\manu\\\\Dektop\\\\texto.md\") // Windows\n...\n// relative paths\nFile f=new File(\"texto.md\") // Linux\nFile f=new File(\"docs\\texto.md\") // Windows\n</code></pre> <ul> <li>La misma clase <code>File</code> se utiliza para acceder tanto a un archivo regular como a un directorio. Es tarea del programador diferenciarlos mediante los m\u00e9todos de archivo, as\u00ed como comprobar si un archivo existe. Para ello podemos utilizar varios m\u00e9todos como: </li> <li><code>boolean exists()</code> \u2192 devuelve true si el objeto de archivo existe y false de lo contrario. </li> <li><code>boolean isFile()</code> y <code>isDirectory()</code> \u2192 devuelve true si el objeto es un archivo regular o un directorio. Obviamente, aquestos m\u00e9todos son exclusivos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#13-creando-archivos","title":"1.3. Creando archivos","text":"<p>Si queremos crear una carpeta o un archivo regular, podemos utilizar estos m\u00e9todos:</p> <ul> <li><code>boolean createNewFile()</code> \u2192 Crea de forma at\u00f3mica un nuevo archivo vac\u00edo con el nombre especificado si y s\u00f3lo si un archivo con ese nombre todav\u00eda no existe.</li> <li><code>static FilecreateTempFile(String prefijo, String suffix)</code> \u2192 Crea un archivo vac\u00edo en el directorio temporal por defecto, utilizando el prefijo y el sufijo especificados para generar su nombre.</li> <li><code>boolean mkdir()</code> \u2192 Crea el directorio con el nombre especificado.</li> <li><code>boolean mkdirs()</code> \u2192 Crea el directorio con el nombre especificado, incluyendo cualquier directorio padre necesario pero que no exista.</li> <li><code>boolean renameTo(File dest)</code> \u2192 Cambia el nombre del archivo especificado.</li> <li><code>boolean delete()</code> \u2192 Elimina el archivo o directorio especificado.</li> </ul> <p>Atenci\u00f3n</p> <ul> <li>En las secciones siguientes estudiaremos c\u00f3mo crear archivos cuando guardamos contenido. En otras palabras, no es necesario crear el archivo ad hoc y luego rellenarlo. Hay mecanismos para crear el archivo de forma automatizada. </li> <li>La diferencia entre mkdir y mkdirs es que la segunda opci\u00f3n crear\u00e1 todos los directorios entre el sistema de archivos ra\u00edz y el directorio actual, mientras que la primera requiere que la ruta ya exista.</li> </ul>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#14-pidiendo-propiedades-del-archivo","title":"1.4. Pidiendo propiedades del archivo","text":"<p>Normalmente abrimos archivos para escribir o leer su contenido, pero a veces necesitamos pedir las propiedades del archivo, como el tama\u00f1o, los permisos, etc. La clase File nos ayudar\u00e1 de nuevo.</p> <p>Informaci\u00f3n general:</p> <ul> <li><code>boolean exists()</code> \u2192 Comprueba si el archivo o directorio indicado para esta ruta abstracta existe.</li> <li><code>long lastModified()</code> \u2192 Devuelve el tiempo en que se modific\u00f3 por \u00faltima vez el archivo indicado por esta ruta abstracta.</li> <li><code>long length()</code> \u2192 Devuelve el tama\u00f1o del archivo indicado para esta ruta abstracta.</li> </ul> <p>Informaci\u00f3n sobre permisos. Esta informaci\u00f3n es la misma que el usuario puede obtener con <code>ls -la</code> en el formato de <code>chmod</code>:</p> <ul> <li><code>boolean canExecute()</code> \u2192 Comprueba si la aplicaci\u00f3n puede ejecutar el archivo indicado por esta ruta abstracta.</li> <li><code>boolean canRead()</code> \u2192 Comprueba si la aplicaci\u00f3n puede leer el archivo indicado para esta ruta abstracta.</li> <li><code>boolean canWrite()</code> \u2192 Comprueba si la aplicaci\u00f3n puede modificar el archivo indicado por esta ruta abstracta.</li> </ul> <p>Contenido de un directorio:</p> <ul> <li><code>String[] list()</code> \u2192 Devuelve un array de cadenas con los nombres de los archivos y directorios del directorio indicado por esta ruta abstracta.</li> <li><code>File[] listFiles()</code> \u2192 Devuelve un array de rutas abstractas que indican los archivos del directorio indicado por esta ruta abstracta.</li> <li><code>String[] list(FilenameFilter filter)</code> \u2192 Devuelve un array de cadenas con los nombres de los archivos y directorios del directorio indicado por esta ruta abstracta que cumplen el filtro especificado.</li> <li><code>File[] listFiles(FilenameFilter filter)</code> \u2192 Devuelve un array de rutas abstractas que indican los archivos y directorios del directorio indicado por esta ruta abstracta que cumplen el filtro especificado.</li> </ul> <p>Consejo</p> <p>Le sugerimos al estudiante que busque informaci\u00f3n sobre la clase FilenameFilter.</p>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#141-ejercicio-resuelto","title":"1.4.1. Ejercicio resuelto","text":"<p>Analiza y explica el siguiente blog de c\u00f3digo <pre><code>public static void main(String[] args) { \nString ruta = args[0]; \nFile f = new File(ruta); \n\nif (f.exists()) { \nif (f.isFile()) { \nSystem.out.println(\"El tama\u00f1o es de \" + f.length()); \nSystem.out.println(\"Puede ejecturase: \" + f.canExecute()); \nSystem.out.println(\"Puede leerse: \" + f.canRead()); \nSystem.out.println(\"Puede escribirse: \" + f.canWrite()); \n} else { \nString[] losArchivos = f.list(); \nSystem.out.println(\"El directorio \" + ruta + \" contiene:\"); \nfor (String archivo : losArchivos) { \nSystem.out.println(\"\\t\" + archivo); \n} \n} \n\n} else { \nSystem.out.println(\"El archivo o ruta no existe\"); \n}\n}\n</code></pre></p> <p>Soluci\u00f3n</p> <ol> <li>Este programa lee desde la l\u00ednea de pedidos una ruta y crea un objeto File.</li> <li>A continuaci\u00f3n, comprueba si la ruta existe o no en el sistema de archivos. En caso de que no exista, el programa finaliza.</li> <li>Si la ruta existe, el siguiente paso es verificar si es un archivo: </li> <li>Leemos algunas propiedades triviales como el tama\u00f1o y los permisos.</li> <li>Si la ruta apuntada por el archivo es un directorio, obtenemos el contenido de este directorio y lo mostramos en la pantalla.</li> </ol>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/","title":"2. Lectura y escritura de archivos","text":"<p>Java ofrece una gran variedad de maneras de manipular el contenido de los archivos, aportando gran poder pero tambi\u00e9n complejidad al mismo tiempo.</p> <p>La lectura y escritura de archivos en Java se realiza a trav\u00e9s de flujos de datos o <code>streams</code>, que pueden ser orientados a bytes o considerados como un conjunto de caracteres. El concepto de archivo, que es est\u00e1tico, debe diferenciarse del concepto de flujo, que tiene un car\u00e1cter din\u00e1mico: un archivo se guarda en el disco, pero desde el punto de vista de la aplicaci\u00f3n, nos interesa la transferencia de esta informaci\u00f3n desde el archivo a nuestro programa. Una comparaci\u00f3n cl\u00e1sica: los flujos ser\u00edan como tuber\u00edas de agua, mientras que los archivos ser\u00edan dep\u00f3sitos. El concepto de flujo de datos, aparte del \u00e1mbito de los archivos, tambi\u00e9n ser\u00e1 aplicable a la transferencia de informaci\u00f3n, por ejemplo a trav\u00e9s de la red o entre procesos.</p> <p>Los flujos se pueden clasificar en:</p> <ul> <li><code>flujo de entrada</code>: Aquellos que van desde una fuente (por ejemplo, un archivo) al programa.</li> <li><code>flujo de salida</code>: Aquellos que salen del programa hacia un destino (por ejemplo, un archivo).</li> </ul> <p>Cuando leemos y almacenamos datos, debemos tener mucho cuidado con los tipos de datos con los que trabajamos, ya que la misma secuencia de bits en el disco representa informaci\u00f3n diferente seg\u00fan el tipo de datos utilizado. Incluido cuando se trata del mismo tipo de datos, como en el caso de los caracteres, es necesario tener especial cuidado, ya que diferentes sistemas pueden utilizar diferentes codificaciones. Java, por ejemplo, para el tipo char utiliza Unicode de 16 bits (UTF-16), pero podemos intentar acceder a archivos codificados, por ejemplo, con UTF-8 o ASCII.</p> <p>Las superclases padre para el manejo de corrientes orientadas a bytes son <code>InputStream</code> y <code>OutputStream</code>. De ellas derivan otras, pero para la gesti\u00f3n de archivos nos interesan dos: <code>FileInputStream</code> y <code>FileOutputStream</code>.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#21-fileinputstream","title":"2.1. FileInputStream","text":"<p>La clase <code>FileInputStream</code> se utiliza para acceder a archivos para la lectura y tiene dos constructores principales:</p> <ul> <li><code>FileInputStream (File f)</code> \u2192 Recibe un objeto de tipo <code>File</code>, que har\u00e1 referencia al objeto que leeremos.</li> <li><code>FileInputStream (String name)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a leer.</li> </ul> <p>Los principales m\u00e9todos que tenemos para esta clase son:</p> <ul> <li><code>int read()</code> \u2192 M\u00e9todo de lectura secuencial abstracto: Devuelve un entero correspondiente al siguiente byte de un flujo de entrada (fichero, vector de bytes...). Si llega al final de la secuencia, devuelve <code>-1</code>. En caso de error, lanzar\u00e1 una excepci\u00f3n de tipo IOException.</li> <li><code>int read(byte[] buffer)</code> \u2192 Lee un n\u00famero determinado de bytes de la entrada (tanto como el tama\u00f1o del buffer), los guarda en el buffer y devuelve el n\u00famero de bytes le\u00eddos efectivamente, que como m\u00e1ximo ser\u00e1 igual al tama\u00f1o del buffer. Si no hay bytes disponibles, devuelve <code>-1</code>.</li> <li><code>int available()</code> \u2192 Indica los bytes disponibles para la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tantos bytes como indica el par\u00e1metro. El valor de retorno es el n\u00famero de bytes que se han descartado efectivamente (puede ser menor que el indicado si llegamos al final, por ejemplo).</li> <li><code>int close()</code> \u2192 Cierra el flujo de datos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#22-fileoutputstream","title":"2.2. FileOutputStream","text":"<p>La clase <code>FileOutputStream</code> se utiliza para acceder a archivos para la escritura. Tiene los siguientes constructores:</p> <ul> <li><code>FileOutputStream (File f)</code> \u2192 Recibe un objeto de tipo <code>File</code> y lo abre en modo escritura. En caso de que no exista, se crear\u00e1, y si ya existe, se sobreescribir\u00e1.</li> <li><code>FileOutputStream (String name)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a escribir, y lo abre en modo escritura. En caso de que no exista, se crear\u00e1, y si ya existe, se sobreescribir\u00e1.</li> <li><code>FileOutputStream (File f, boolean append)</code> \u2192 Recibe un objeto de tipo <code>File</code> y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s (s\u00f3lo si append est\u00e1 establecido en <code>True</code>).</li> <li><code>FileOutputStream (String name, boolean append)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a escribir y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s (s\u00f3lo si append est\u00e1 establecido en <code>True</code>).</li> </ul> <p>Los principales m\u00e9todos de la clase son:</p> <ul> <li><code>write(int byte)</code> \u2192 Escribe el byte en el flujo de salida. Aunque este par\u00e1metro es un entero, s\u00f3lo se escribe un byte. Si hay un error, se lanzar\u00e1 una excepci\u00f3n de tipo IOException.</li> <li><code>void write(byte[] buffer)</code> \u2192 Escribe el contenido del buffer (vector de bytes) en el archivo. Si el buffer es nulo, lanzar\u00e1 una excepci\u00f3n.</li> <li><code>void write(byte[] buffer, int pos, int length)</code> \u2192 Escribe el contenido del <code>buffer</code> (vector de bytes) desde la posici\u00f3n <code>pos</code>, y tantos bytes como se indiquen en <code>length</code>.</li> <li><code>void flush()</code> \u2192 Fuerza la escritura de los bytes restantes en la memoria cach\u00e9 en el archivo de salida.</li> <li><code>void close()</code> \u2192 Cierra el flujo de salida y libera los recursos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#221-ejercicio-resuelto","title":"2.2.1. Ejercicio resuelto","text":"<p>Crea un programa sencillo en Java que copie un hitoxer a otro archivo byte en byte. El archivo origen y el archivo destino se indicar\u00e1n a trav\u00e9s de la l\u00ednea de pedidos.</p> <p>Soluci\u00f3n</p> <pre><code>class FileCopy { \n/* \nClass to test FileInputStream and FileOutputStream. \n\nCopy byte to byte of files \n\nSintaxis: \nFileCopy sourceFile destinationFile. \n\n*/ \npublic static void main(String[] args) throws Exception { \n// Byte readed from source \nint bytes; \n// Bytes (effectively) writen to dest \nlong bytesCopied=0; \n\n// Streams \n\nFileInputStream fis= null; \nFileOutputStream fundido=null; \n\n// To provide information about source \nFile f; \n\n\n// Are the arguments ok? \nif(args.length!=2){ \nSystem.out.println(\"N\u00famero de argumentos err\u00f3neo. Sintaxis:\\n FileCopy archivoOrigen archivoDesti\"); \nreturn; \n} \n\ntry{ \n\n// show source size \nf=new File(args[0]); \nSystem.out.println(\"Total: \"+f.length()+\" bytes\"); \n\n// Create streams \nfis=new FileInputStream(args[0]); \nfos=new FileOutputStream(args[1]); \n\ndo { \n// read one byte from source \nbytes=fis.read(); \n// write in destination \nif (bytes!=-1) \nfos.write(bytes); \n// Update number of bytes \nbytesCopied++; \n\n// Show progress (think alternativas as exercise) \nSystem.out.print(\"\\rCopiados \"+(bytesCopied-1)+\" bytes...\"); \n}while (bytes!=-1); \nSystem.out.println(\"Done it!\"); \n\n\n}catch (IOException exc){ \nSystem.out.println(\"Error de entrada y salida: \"+exc); \n}finally { \n// En el final, no hay que terminar las filas, sino en error existentes o no. \ntry { \nif (fis!=null) fis.close(); \n}catch (IOException exc){ \nSystem.out.println(\"Error al cerrar el archivo de origen.\"); \n} \ntry { \nif(fos!=null) fos.close(); \n}catch (IOException exc){ \nSystem.out.println(\"Error al cerrar el archivo destino.\"); \n} \n} \n} \n} \n</code></pre> <p>Piensa y comprueba</p> <p>Con el programa de ejemplo que hemos visto, podr\u00edamos copiar archivos de todo tipo: texto, audio, v\u00eddeo. </p> <p>Reto </p> <p>Trate de cambiar el \u00faltimo programa para leer los datos en bloques de 32 bytes, utilizando los m\u00e9todos adecuados de las clases. Comparte tu soluci\u00f3n en el foro.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#23-ficheros-de-texto","title":"2.3. Ficheros de Texto","text":"<p>Como se ha dicho, Java permite gestionar flujos con orientaci\u00f3n a bytes o con orientaci\u00f3n a caracteres. Las clases abstractas para la gesti\u00f3n de flujos orientados a caracteres son <code>Reader</code> y <code>Writer</code>.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#231-filereader","title":"2.3.1. <code>FileReader</code>","text":"<p>La clase <code>FileReader</code> sirve para acceder a archivos para la lectura y tiene dos constructores:</p> <ul> <li><code>FileReader (File f)</code> \u2192 Recibe un objeto de tipo <code>File</code>, que har\u00e1 referencia al objeto del que se obtendr\u00e1 la informaci\u00f3n.</li> <li><code>FileReader (String name)</code> \u2192 Recibe una cadena con el nombre o la ruta del archivo.</li> </ul> <p>Los m\u00e9todos que tenemos para esta clase son muy parecidos a los que tenemos para <code>FileInputStream</code>, con la diferencia de que ahora leemos caracteres en lugar de bytes.</p> <ul> <li><code>int read()</code> \u2192 Lee el siguiente car\u00e1cter del flujo de entrada y lo devuelve como entero.</li> <li>`int read(char[] buffer) \u2192 Rellena el buffer con tantos caracteres de la entrada como tenga (como m\u00e1ximo). Devuelve el n\u00famero de caracteres le\u00eddos efectivamente.</li> <li><code>int available()</code> \u2192 Devuelve el n\u00famero de caracteres disponibles para la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tantos caracteres como indica el par\u00e1metro.</li> <li><code>int close()</code> \u2192 Cierra el flujo de datos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#232-filewriter","title":"2.3.2. <code>FileWriter</code>","text":"<p>La clase FileWriter ser\u00eda el equivalente de <code>FileOutputStream</code> en la versi\u00f3n de flujos orientados a caracteres Los constructores de la clase son:</p> <ul> <li><code>FileWriter (File f)</code> \u2192 Abre elarchivo especificado por <code>File</code> para la escritura. Si el archivo no existe, se crear\u00e1, y si ya existe, se eliminar\u00e1n los contenidos.</li> <li><code>FileWriter (String name)</code> \u2192 Abre el archivo especificado por una cadena con el nombre y la ruta en modo escritura. Si no existe, se crear\u00e1, y si ya existe, se borrar\u00e1n los contenidos.</li> <li><code>FileWriter (File f, boolean append)</code> \u2192 Recibe un objeto de tipo <code>File</code> y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s.</li> <li><code>FileWriter (String name, boolean append)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a escribir y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s.</li> </ul> <p>Los principales m\u00e9todos de la clase <code>FileWriter</code> son muy similares a los de <code>OutputStream</code>:</p> <ul> <li><code>write(int character)</code> \u2192 Escribe el car\u00e1cter en el flujo de salida, con la codificaci\u00f3n propia del sistema operativo. Si hay un error, se arroja una excepci\u00f3n de tipo <code>IOException</code>.</li> <li><code>void write(char[] buffer)</code> \u2192 Escribe el contenido del buffer (vector de caracteres) en el archivo. Si el buffer es nulo, lanzar\u00e1 una excepci\u00f3n.</li> <li><code>void write(char[] buffer, int pos, int length)</code> \u2192 Escribe el contenido del buffer (array de caracteres) desde la posici\u00f3n pos, y tantos bytes como se indiquen en length.</li> <li><code>void flush()</code> \u2192 Fuerza la escritura de los bytes restantes en la memoria cach\u00e9 en el archivo de salida.</li> <li><code>void close()</code> \u2192 Cierra el flujo de salida y libera los recursos.</li> <li><code>void write(String text)</code> \u2192 Escribe todo el contenido de texto en el archivo.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#233-ejercicio-resuelto","title":"2.3.3. Ejercicio resuelto","text":"<p>Crea un programa sencillo en Java que fusione todos los archivos dentro de una carpeta en un \u00fanico archivo. La carpeta de origen y el archivo de destino se indicar\u00e1n en la llamada del programa. Supongamos que todos los archivos dentro de esta carpeta son archivos de texto.</p> <p>Soluci\u00f3n</p> <pre><code>class FusionaTextos { \n// C\u00f3digo del programa \n} \n``` /* \n\n\nSintax: \nMergeTexts DirectorioOrigen ArchivoDestino \n\n*/ \npublic static void main(String[] args) throws Exception { \n\nFile decir; // Source dir \n// Collection of files from that dir \nFile[] filas; \n\n// readed characters \nint characters; \n\n// Input and Output Streams \nFileReader fin=null; \nFileWriter fout=null; \n\n// Check the args \nif(args.length!=2){ \nSystem.out.println(\"N\u00famero de argumentos err\u00f3neo. Sintaxis:\\n mergeTexts DirectorioOrigen archivoDesti\"); \nreturn; \n} \n\ntry{ \n\n// We get the list of Files \ndir=new File(args[0]); \nfilas=dir.listFiles(); \n\n\n// Open and close output stream (in ordenar a crear el archivo) \nfout=new FileWriter(args[1]); \nfout.close(); \n\n// Re-open it \nfout=new FileWriter(args[1], true); \n\n// Iterate among the list \nfor (int i=0; i&lt;files.length; i++){ \n// open input stream \nfin=new FileReader(argos[0]+\"/\"+files[y].getName()); \nSystem.out.println(\"Merging \"+args[0]+\"/\"+files[i].getName()); \n// and merge to the output one \ndo { \ncharacters=fin.read(); \nif (characters!=-1) \nfout.write(characters); \n}while (characters!=-1); \nfin.close(); //close the file merged \n\n} \nfout.close(); //close the output file \n\n}catch (Exception exc){ \n// Catch all the exception (we coud improve it) \nSystem.out.println(\"Input/Output error: \"+exc); \n} \n} \n} \n</code></pre> <p>Mejora tu c\u00f3digo</p> <p>Intenta mejorar el c\u00f3digo anterior creando una funci\u00f3n <code>merge()</code>. Deber\u00edamos llamarla dentro del bucle principal.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#24-decoradores","title":"2.4. Decoradores","text":"<p>Patr\u00f3n de dise\u00f1o decorador</p> <p>Las clases de decorador son aquellas que heredan de cierta clase y proporcionan funcionalidades a\u00f1adidas al original. En el caso de los flujos de entrada y salida, tenemos decoradores que nos permiten leer o escribir l\u00edneas completas en vez de byte a byte, o guardarlos en un cierto formato de datos. Simplifica nuestro trabajo, a\u00f1adiendo una forma m\u00e1s natural y amigable para utilizar las clases base.</p> <p>La clase <code>InputStream</code> tiene varios decoradores, pero nos centraremos en los siguientes:</p> <ul> <li><code>DataInputStream</code> \u2192 Permite leer datos de cualquier tipo (entero, l\u00f3gico, etc.)</li> <li><code>ObjectInputStream</code> \u2192 A\u00f1ade la opci\u00f3n de leer un objeto entero</li> </ul> <p>Por otro lado, la clase <code>OutputStream</code> tambi\u00e9n tiene diferentes decoradores, entre los que destacamos:</p> <ul> <li><code>DataOutputStream</code> \u2192 Permite escribir datos de cualquier tipo (entero, l\u00f3gico, etc.)</li> <li><code>PrintStream</code> \u2192Permite escribir datos de cualquier tipo y tambi\u00e9n acepta los m\u00e9todos <code>printf</code> y <code>println</code></li> <li><code>ObjectOutputStream</code> \u2192 Permite escribir (serializar) objetos</li> </ul> <p>En cuanto a las clases de decorador para flujos orientados a caracteres, tenemos, por un lado, los decoradores de <code>Reader</code> (m\u00e1s destacados):</p> <ul> <li><code>BufferedReader</code> \u2192 Crea un buffer de entrada, permitiendo, por ejemplo, leer una l\u00ednea completa</li> </ul> <p>Y para la escritura:</p> <ul> <li><code>BufferedWriter</code> \u2192 Crea un buffer de salida, permitiendo, por ejemplo, escribir una l\u00ednea completa</li> <li><code>PrintWriter</code> \u2192 Permite escribir datos de diferentes tipos y tiene m\u00e9todos como <code>printf</code> y <code>println</code></li> </ul> <p>La clase <code>BufferedReader</code>, entre otros, tiene el m\u00e9todo <code>readLine()</code>, que permite leer una l\u00ednea entera del archivo hasta el final de la l\u00ednea, muy \u00fatil en archivos de texto.</p> <p>Por su parte, la clase <code>BufferedWriter</code> proporciona el m\u00e9todo <code>newLine()</code> para introducir el car\u00e1cter de retorno de carro y el m\u00e9todo <code>write(String cadena, int inicio, int longitud)</code> para escribir una cadena o parte espec\u00edfica.</p> <p>El otro decorador para la escritura es el <code>PrintWriter</code>, que nos ofrece los m\u00e9todos <code>print(datos)</code>, <code>println(datos)</code> y <code>printf()</code> para el formato.</p> <p>Alternativas a...</p> <p>Obviamente, podr\u00eda: </p> <ul> <li>concatenar <code>\\n</code> al final de cada cadena en cada m\u00e9todo <code>print()</code> en vez de llamar <code>newLine()</code>. </li> <li>utilizar <code>println()</code> en lugar de llamar <code>newLine()</code>.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#241-ejercicio-resuelto","title":"2.4.1. Ejercicio resuelto","text":"<p>Crea un programa para copiar un archivo de texto a\u00f1adiendo el n\u00famero de l\u00ednea al principio de cada l\u00ednea.</p> <p>Soluci\u00f3n</p> <pre><code>public class NumberLines { \npublic static void main(String[] args) throws Exception { \n\n// Input and Output \nBufferedReader fin; \nPrintWriter fout; \n\n// line counter \nint num_linia; \n// readed line \nString linea; \n\n// check args \nif (args.length != 2) { \nSystem.out.println(\"N\u00famero de argumentos err\u00f3neo. Sintaxis:\\n numberLines archivo salida\"); \nreturn; \n} \n\n// Creare decorators \nfin = new BufferedReader(new FileReader(args[0])); \nfout = new PrintWriter(new FileWriter(args[1])); \n\nnum_linia = 1; \ndo { \n// Read the line \nlinea = fin.readLine(); \nif (l\u00ednea != null) { \nfout.println(num_linia + \". \" + linea); \n} \nnum_linia++; \n} while (l\u00ednea != null); // until we can't read \n\n// close all \nfin.close(); \nfout.close(); \n\n} \n} \n</code></pre>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#25-ficheros-binarios","title":"2.5. Ficheros binarios","text":"<p>En esta secci\u00f3n y las siguientes veremos c\u00f3mo almacenar diferentes tipos de datos y objetos en archivos de diferentes formatos: archivos binarios, archivos XML o JSON.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#251-almacenar-datos-estructurados-en-archivos-binarios","title":"2.5.1. Almacenar datos estructurados en archivos binarios.","text":"<p>En la secci\u00f3n anterior vimos c\u00f3mo trabajar con archivos de caracteres y de bytes. En el caso de los archivos de bytes, hemos visto c\u00f3mo leerlos y escribirlos secuencialmente, byte a byte hasta el final del archivo.</p> <p>Imaginemos que queremos guardar la siguiente tabla, que combina datos de distintos tipos. Este ejemplo aparecer\u00e1 en las siguientes secciones.</p> <p>|Modulo |</p> <p>|---|-|---|</p> <p>|Acceso a Datos | 6 |8.45 |</p> <p>|Programaci\u00f3n de servicios y procesos |3 |9.0|</p> <p>|Desarrollo de interfaces |6 |8.0|</p> <p>|Programaci\u00f3n Multimedia y dispositivos m\u00f3viles |5 |7.34|</p> <p>|Sistemas de Gesti\u00f3n Empresarial |5 |8.2|</p> <p>|Empresa e iniciativa emprendedora |3 |7.4|</p> <p>Como podemos ver, tenemos datos de texto, datos num\u00e9ricos enteros y reales. Si queremos mantener los tipos, los flujos orientados a caracteres como <code>Reader</code> o <code>Writer</code> no ser\u00e1n \u00fatiles, as\u00ed que deber\u00edamos utilizar <code>InputStream</code> y <code>OutputStream</code>.</p> <p>Para guardar estas estructuras eficientemente, podemos utilizar las clases <code>DataInputStream</code> y <code>DataOutputStream</code>, que son decoradores de flujos y que nos ofrecen los siguientes m\u00e9todos para guardar o recuperar datos de diferentes tipos, sin tener que preocuparnos de cu\u00e1nto ocupan internamente como puede ver, hay m\u00e9todos rec\u00edprocos para leer.</p> <p>|<code>DataInputStream</code> |</p> <p>|---|---|---|</p> <p>|<code>byte readByte()</code>|<code>void writeByte(int)</code> |un byte |</p> <p>|<code>short readShort()</code> |<code>void writeShort(short)</code> |entero corto |</p> <p>|<code>int readInt()</code> |<code>void writeInt(int)</code> |</p> <p>|<code>long readLong()</code> |<code>void writeLong(long)</code> |</p> <p>|<code>float readFloat()</code> |<code>void writeFloat(float)</code> | real de precisi\u00f3n simple|</p> <p>|<code>double readDouble()</code> |<code>void writeDouble(double)</code> |real doble|</p> <p>|<code>char readChar()</code> |<code>void writeChar(int)</code> |n car\u00e1cter Unicode|</p> <p>|<code>String readUTF()</code> |<code>void writeUTF(String)</code>|un String UTF-8 |</p> <p>Tip</p> <p>Una cadena <code>UTF-8</code> es diferente a una String. Cuando se guarda una cadena, como es evidente, se guardan todos los caracteres. Al guardarla como cadena UTF-8, se a\u00f1ade informaci\u00f3n sobre la longitud de la cadena, siendo esta informaci\u00f3n esencial para cortar estas cadenas cuando se lean en el futuro. </p> <p>Imagina que guardas dos cadenas, \"euro\" y \"sport\". El resultado ser\u00e1, al final, \"eurosport\". Cuando alguien abra este archivo en el futuro, \u00bfc\u00f3mo sabr\u00e1 el n\u00famero de cadenas almacenadas (\"euro\", \"sport\" o simplemente \"eurosport\" (canal de televisi\u00f3n))? </p> <p>Al guardarlo como UTF-8, cuando guardas \"euro\" y \"sport\", el resultado es \"4euro5sport\". Cuando alguien intente leerlo, primero ver\u00e1 un '4' y leer\u00e1 \"euro\". Luego, ver\u00e1 un '5' y leer\u00e1 \"sport\". </p> <p>Cabe destacar que si se guarda \"eurosport\", el resultado ser\u00e1 \"9eurosport\". Prueba a escribir un programa de ejemplo con esta cadena, abriendo el archivo resultante con un editor hexadecimal.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#252-ejercicio-resuelto","title":"2.5.2. Ejercicio resuelto","text":"<p>Escribe un programa que tenga los datos almacenados en tres arrays paralelos, que almacenan los datos de los m\u00f3dulos de DAM. Escribe dos funciones, una para escribir estos datos en un archivo y otra para leerlos. Considera almacenar los datos agrupados por m\u00f3dulo, en vez de nombre, horas y calificaci\u00f3n.</p> <p>Soluci\u00f3n</p> <pre><code>public class Moduls{ \n\n// several arrays with modules data \nString[] modulos={\"Acceso a Datos\", \"Programaci\u00f3n de servicios y procesos\", \"Desarrollo de interfaces\", \"Programaci\u00f3n Multimedia y dispositivod m\u00f3viles\", \"Sistemas de Gesti\u00f3n Empresarial\", \"Empresa e iniciativa emprendedora\"}; \nint[] horas={6, 3, 6, 5, 5, 3}; \ndouble[] notas={8.45, 9.0, 8.0, 7.34, 8.2, 7.4}; \n\npublic void readFiLe(String name) throws IOException { \n// Para leer el archivo binario, creamos un DataInputStream \n// a partir del FileInputStream creado a partir del nombre \nDataInputStream f = new DataInputStream(new FileInputStream(name)); \n\n// Mientras el DataInputStream tenga datos disponibles \nwhile (f.available()&gt;0){ \n// Leeremos del archivo cada dato, con el orden correspondiente \n// en funci\u00f3n del tipo \n// (por lo tanto, debemos saber el orden en el que guardamos!) \nSystem.out.println(\"M\u00f3dulo: \" + f.readUTF()); \nSystem.out.println(\"Horas: \" + f.readInt()); \nSystem.out.println(\"Notas: \" + f.readDouble()); \nSystem.out.println(); \n} \nf.close(); \n} \n\npublic void writeFile(String name) throws IOException{ \n// Para escribir el archivo, hacemos uso de DataOutputStream \nDataOutputStream f = new DataOutputStream(new FileOutputStream(name)); \n\n// Recorreremos cualquiera de los vectores (todos deber\u00edan tener) \n// la misma longitud \nfor (int i=0;i&lt;this.moduls.length;i++){ \n// Y para cada posici\u00f3n, escribiremos en funci\u00f3n del tipo de dato \nf.writeUTF(this.moduls[i]); \nf.writeInt(this.horas[i]); \nf.writeDouble(this.notes[i]); \n\n} \nf.close(); \n} \n\npublic static void main(String[] args) throws IOException { \n\n// Comprobamos los argumentos \nif (args.length!=2){ \nSystem.out.println(\"N\u00famero de argumentos incorrecto.\\n\\nSintaxis: \\n\\t java Moduls [read | write] archivo.dat\"); \nSystem.exit(0); \n} \n\n// Defining the class \nModuls moduls=new Modulos(); \n\n// Depending the args, we will proceed \nif (args[0].equals(\"read\")) \nmoduls.readFiLe(args[1]); \nelse if (args[0].equals(\"write\")) \nmoduls.writeFile(args[1]); \nelse \nSystem.out.println(\"No entiendo el mandato \"+args[0]+\"\\n\"); \n} \n} \n</code></pre>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#26-serializando-objetos","title":"2.6. Serializando Objetos","text":"<p>Java proporciona un sistema gen\u00e9rico de serializaci\u00f3n de objetos: un sistema recursivo que itera sobre cada objeto contenido en una instancia, hasta llegar a los tipos primitivos, que se almacenan como un array de bytes. Aparte de esta informaci\u00f3n de los tipos primitivos, tambi\u00e9n se almacena informaci\u00f3n adicional o metadatos espec\u00edficos de cada clase, como el nombre o los atributos, entre otros. Gracias a estos metadatos, que describen los objetos que guardamos, podemos automatizar la serializaci\u00f3n de forma gen\u00e9rica, asegur\u00e1ndonos que posteriormente podremos leer los objetos.</p> <p>La desventaja de este m\u00e9todo es que al cambiar la definici\u00f3n de la clase (por ejemplo, a\u00f1adiendo un atributo m\u00e1s o cambiando su tipo), los metadatos se modifican y no podr\u00edamos leer los objetos serializados con versiones anteriores de la clase. Adem\u00e1s, tambi\u00e9n hay que tener en cuenta que \u00e9ste es un mecanismo espec\u00edfico de Java y que no podremos consultar estos objetoses desde otros lenguajes.</p> <p>Por todo ello, otras t\u00e9cnicas son preferibles para el almacenamiento permanente de objetos, que veremos m\u00e1s adelante, pero la serializaci\u00f3n puede resultar \u00fatil para el almacenamiento temporal, dentro de la propia ejecuci\u00f3n de la aplicaci\u00f3n.</p> <p>\u00bfQu\u00e9 es esto?</p> <p>Investigaci\u00f3n: intenta encontrar informaci\u00f3n sobre SerialVersionUID y para qu\u00e9 es importante.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#261-la-interfaz-serializable-y-los-decorators","title":"2.6.1. La interfaz <code>Serializable</code> y los <code>Decorators</code>","text":"<p>Si queremos que una clase sea serializable, debe implementar la interfaz <code>Serializable</code>, la cual tiene como \u00fanico prop\u00f3sito actuar como marcador para indicar al JVM que la clase puede ser serializada, por tanto, esta clase no tendr\u00e1 m\u00e9todos.</p> <p>Cabe decir que todas las clases correspondientes a los tipos b\u00e1sicos ya implementan la interfaz Serializable, as\u00ed como la clase String, contenedores y Arrays. En el caso de las colecciones, depende de sus contenidos, si sus elementos son serializables, la colecci\u00f3n tambi\u00e9n lo ser\u00e1. Si el objeto que queremos serializar o sus objetos no implementan la interfaz Serializable, se lanzar\u00e1 la excepci\u00f3n <code>NotSerializableException</code>.</p> <p>Los decoradores <code>ObjectInputStream</code> y <code>ObjectOutputStream</code> nos ofrecen la capacidad de serializar cualquier objeto deserializable. Para escribir un objeto, haremos uso del m\u00e9todo <code>writeObject</code> de <code>ObjectOutputStream</code>, y para leerlo haremos uso de <code>readObject</code> de <code>ObjectInputStream</code>.</p> <p>Ovejas con ovejas</p> <p>Hay que tener en cuenta que la lectura de objetos debe realizarse en instancias de la misma clase que se guard\u00f3. De lo contrario, se lanzar\u00e1 una excepci\u00f3n <code>ClassCastException</code>. Adem\u00e1s, es necesario tener el c\u00f3digo compilado de la clase para evitar la excepci\u00f3n <code>ClassNotFoundException</code>. </p> <p>Adem\u00e1s, <code>readObject</code> devuelve un Object, y necesitamos un objeto de una clase espec\u00edfica. Por este motivo, es necesario realizar una conversi\u00f3n de Object a la clase necesaria. Los conceptos de herencia son importantes para garantizar programas robustos.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#262-ejercicio-resuelto","title":"2.6.2. Ejercicio resuelto","text":"<p>Empezando con la misma base de la clase <code>Moduls</code> del ejercicio anterior, crearemos una clase <code>Modul</code> para almacenar un \u00fanico m\u00f3dulo. Este tipo de clases se conocen como POJO (Plain Old Java Objects) y est\u00e1n dise\u00f1adas s\u00f3lo para almacenar informaci\u00f3n. (Aparecer\u00e1 m\u00e1s adelante, junto con las clases BEAN).</p> <p>Una vez creada la clase <code>Modul</code>, escribe un programa para guardar objetos directamente en un archivo. Despu\u00e9s, escribe la funci\u00f3n complementaria para leer todos los objetos almacenados en ese archivo.</p> <p>Soluci\u00f3n</p> Modulo.java<pre><code>package org.example.pojo;\n\nimport java.io.Serializable;\n\npublic class Modulo implements Serializable {\n\n    String nombre;\n    int horas;\n    double nota;\n\n    public Modulo(){\n// Constructor vac\u00edo\n    }\n\n    public Modulo(String nombre, int horas, double nota){\n        this.nombre=nombre;\n        this.horas=horas;\n        this.nota=nota;\n    }\n\n    public String getModulo() {return this.nombre;}\n    public int getHoras() {return this.horas;}\n    public double getNota() {return this.nota;}\n\n\n    /*\n     Write and Read modules to/from file\n     */\n\n\n\n\n}\n</code></pre> Modulo2.java<pre><code>package org.example.pojo;\n\nimport java.io.*;\n\npublic class Modulo2 {\n\n    // Arrays with source data\n    String[] modulos = {\"Acceso a Datos\", \"Programaci\u00f3n de servicios y procesos\", \"Desarrollo de interfaces\", \"Programaci\u00f3n Multimedia y dispositivod m\u00f3viles\", \"Sistemas de Gesti\u00f3n Empresarial\", \"Empresa e iniciativa emprendedora\"};\n    int[] horas = {6, 3, 6, 5, 5, 3};\n    double[] notas = {8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void EscribeObjeto(String nombre) throws IOException {\n\n        //destination file\n        ObjectOutputStream f = new ObjectOutputStream(new FileOutputStream(nombre));\n\n        Modulo m; // Single object\n\n        // loop along the arrays\n        for (int i = 0; i &lt; this.modulos.length; i++) {\n            m = new Modulo(this.modulos[i], this.horas[i], this.notas[i]);\n            f.writeObject(m);\n        }\n\n        // close the file\n        f.close();\n\n    }\n\n    public void LeeObjeto(String nombre) throws IOException, ClassNotFoundException {\n\n        // input file\n        ObjectInputStream f = new ObjectInputStream(new FileInputStream(nombre));\n\n        Modulo m;\n        // No se puede saber que hay objetos existentes en el archivo.\n        try {\n            while (true) { // forever\n\n                m = (Modulo) f.readObject();\n\n                // show the module\n                System.out.println(\"Modul: \" + m.getModul());\n                System.out.println(\"Horas: \" + m.getHores());\n                System.out.println(\"Nota: \" + m.getNota());\n                System.out.println();\n\n            }\n        } catch (EOFException ex) {\n            f.close();\n        }\n\n    }\n}\n</code></pre> Main.java<pre><code>package org.example;\n\nimport org.example.pojo.Modulo2;\n\nimport java.io.IOException;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        // test the args\n        if (args.length != 2) {\n            System.out.println(\"N\u00famero de argumentos incorrecto.\\n\\nSintaxis: \\n\\t java Moduls2 [ read | write ] archivo.obj\");\n            System.exit(0);\n        }\n\n        Modulo2 modulos = new Modulo2();\n\n        // depending the args\n        if (args[0].equals(\"read\")) {\n            modulos.LeeObjeto(args[1]);\n        } else if (args[0].equals(\"write\")) {\n            modulos.EscribeObjeto(args[1]);\n        } else {\n            System.out.println(\"No entiendo el mandato \" + args[0] + \"\\n\");\n        }\n\n    }\n}\n</code></pre> <p>Menos trabajo, pero al final lo mismo.</p> <p>Probablemente lo pienses:</p> <ul> <li>Si todo en Java hereda de Object, un ArrayList es un Object... \u00bfPuedo guardar o cargar un ArrayList completo en una sola llamada?</li> <li>Pru\u00e9balo como una mejora del ejercicio anterior.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/","title":"3. Archivos XML","text":""},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#31-por-que-xml","title":"3.1. \u00bfPor qu\u00e9 XML?","text":"<p>Cuando queremos guardar datos que puedan ser le\u00eddos por distintas aplicaciones y plataformas, es mejor utilizar formatos de almacenamiento est\u00e1ndar que m\u00faltiples aplicaciones puedan entender (portabilidad). Un caso muy espec\u00edfico son los lenguajes de marcado, y el m\u00e1s conocido es el est\u00e1ndar XML (eXtensible Markup Language).</p> <p>Con los documentos XML, estructuramos la informaci\u00f3n insertando marcas o etiquetas entre la informaci\u00f3n. Estas etiquetas tienen un inicio y un final, y pueden anidarse dentro de otros, as\u00ed como contener informaci\u00f3n textual. el encabezamiento del documento la codificaci\u00f3n utilizada para guardar el documento.</p> <p>La forma de guardar informaci\u00f3n en XML, de forma jer\u00e1rquica, es muy similar a la forma en que lo hacen los objetos en una aplicaci\u00f3n, de manera que \u00e9stos se pueden traducir de manera relativamente conveniente en un documento XML.</p> <p>|M\u00f3dulo |</p> <p>|---|-|---|</p> <p>|Acceso a Datos | 6 |8.45 |</p> <p>|Programaci\u00f3n de servicios y procesos |3 |9.0|</p> <p>|Desarrollo de interfaces |6 |8.0|</p> <p>|Programaci\u00f3n Multimedia y dispositivos m\u00f3viles |5 |7.34|</p> <p>|Sistemas de Gesti\u00f3n Empresarial |5 |8.2|</p> <p>|Empresa e iniciativa emprendedora |3 |7.4|</p> <p>puede representarse en etiquetas <code>xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;curso&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Acceso a Datos&lt;/nombre&gt;\n        &lt;horas&gt;6&lt;/horas&gt;\n        &lt;calificacion&gt;8.45&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Programaci\u00f3n de servicios y procesos&lt;/nombre&gt;\n        &lt;horas&gt;3&lt;/horas&gt;\n        &lt;calificacion&gt;9.0&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Desarrollo de interfaces&lt;/nombre&gt;\n        &lt;horas&gt;6&lt;/horas&gt;\n        &lt;calificacion&gt;8.0&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Programaci\u00f3n Multimedia y dispositivos m\u00f3viles&lt;/nombre&gt;\n        &lt;horas&gt;5&lt;/horas&gt;\n        &lt;calificacion&gt;7.34&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Sistemas de Gesti\u00f3n Empresarial&lt;/nombre&gt;\n        &lt;horas&gt;5&lt;/horas&gt;\n        &lt;calificacion&gt;8.2&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Empresa e iniciativa emprendedora&lt;/nombre&gt;\n        &lt;horas&gt;3&lt;/horas&gt;\n        &lt;calificacion&gt;7.4&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n&lt;/curso&gt;\n</code></pre> <p>o puede ser representado con etiquetas y atributos:</p> <p><pre><code>&lt;curso&gt; \n&lt;modulo nombre=\"Acceso a Datos\" horas=\"6\" calificacion=\"8.45\" &gt; \n&lt;modulo nombre=\"Programaci\u00f3n de servicios y procesos\" \"horas\"=3 calificacion=\"9.0\" &gt; \n&lt;modulo nombre =\"Desarrollo de interfaces\" horas=\"6\" calificacion=\"8.0\" &gt; \n&lt;/modulo&gt; \n&lt;modulo nombre=\"Programaci\u00f3n Multimedia y dispositivod m\u00f3viles\" horas=\"5\" calificacion=\"7,34\"&gt; \n&lt;modulo nombre=\"Sistemas de Gesti\u00f3n Empresarial\" horas=\"5\" \"calificacion\"=8.2 /&gt; \n&lt;modulo nombre=\"Empresa e iniciativa emprendedora\" horas=\"3\" calificacion=\"7.4\" /&gt; \n&lt;/modulo&gt;\n&lt;/curso&gt;\n</code></pre> Un analizador XML es una clase que permite analizar un archivo XML y extraer informaci\u00f3n de \u00e9l, relacion\u00e1ndola seg\u00fan su posici\u00f3n en la jerarqu\u00eda. Los analizadores, seg\u00fan su forma de funcionar, pueden ser:</p> <ul> <li>Analizadores secuenciales o sint\u00e1cticos, que extraen el contenido a medida que se descubren las etiquetas de apertura y cierre. Son muy r\u00e1pidos, pero tienen el problema que hay que leer todo el documento para acceder a una parte espec\u00edfica.</li> <li>Analizadores jer\u00e1rquicos, que son los m\u00e1s utilizados y que guardan todos los datos del documento XML en la memoria, en forma de una estructura jer\u00e1rquica (DOM o Document Object Model), siendo los preferidos para aplicaciones que deben leer los datos de forma m\u00e1s continua.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#32-el-modelo-de-objetos-de-documento-dom","title":"3.2. El Modelo de Objetos de Documento (DOM)","text":"<p>El DOM (Document Object Model) es la estructura especificada por la W3C donde se almacena la informaci\u00f3n de los documentos XML. El DOM se ha relacionado principalmente con el mundo web, con HTML y Javascript como principales impulsores.</p> <p>La interfaz principal del DOM en Java es <code>Document</code>, y representa el documento XML completo Al ser una interfaz, se puede implementar en varias clases.</p> <p>Hay que tener en cuenta que...</p> <p>Una interfaz es una especie de plantilla para construir clases y generalmente est\u00e1 compuesta por un conjunto de declaraciones de cabecera de m\u00e9todos no implementados que especifican c\u00f3mo se comportan una o m\u00e1s clases. Adem\u00e1s, una clase puede implementar una o m\u00e1s interfaces. </p> <p>Hay que tener en cuenta que una interfaz no debe confundirse con una clase abstracta, ya que hay algunas diferencias. Por ejemplo, una interfaz tiene todos los m\u00e9todos abstractos, no puede declarar variables de instancia, una clase puede implementar varias interfaces pero no heredatar de varias superclases, y una interfaz no debe pertenecer a ninguna jerarqu\u00eda, por lo que las clases que no tienen ninguna relaci\u00f3n de herencia pueden implementar la misma interfaz.</p> <p>Aparte de <code>Document</code>, la W3C tambi\u00e9n define la clase abstracta <code>DocumentBuilder</code>, que permite crear el DOM a partir del XML. Adem\u00e1s, se especifica la clase <code>DocumentBuilderFactory</code>, que nos permite fabricar <code>DocumentBuilders</code>, puesto que, al ser abstracta, no se puede instanciar directamente.</p> <p>Cabe decir, como advertencia, que Java ofrece muchas librer\u00edas desde las que importar Document. Las librer\u00edas que utilizaremos para analizar XML ser\u00e1n:</p> <ul> <li>La librer\u00eda <code>java.xml.parsers.*</code>, que ofrecer\u00e1 las clases <code>DocumentBuilderFactory</code> y <code>DocumentBuilder</code>, y</li> <li>La librer\u00eda <code>org.w3c.dom.*</code> para la clase <code>Document</code>.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#321-documentbuilder-y-documentbuilderfactory","title":"3.2.1. <code>DocumentBuilder</code> y <code>DocumentBuilderFactory</code>","text":"<p>Como se ha dicho, <code>DocumentBuilder</code> define una API para obtener instancias DOM de un documento XML. Para obtener una instancia de la clase, se debe utilizar la clase <code>DocumentBuilderFactory</code>, y concretamente el m\u00e9todo <code>newDocumentBuilder()</code>:</p> <p>Por otra parte, para leer e interpretar el documento XML, la clase <code>DocumentBuilderFactory</code> proporciona el m\u00e9todo <code>parse()</code>, que analiza un XML indicado por un archivo y devuelve un objeto <code>Document</code>.</p> <p>Veremos todo esto con un ejemplo. Continuamos almacenando datos sobre los m\u00f3dulos del curso, pero ahora con XML. El siguiente m\u00e9todo nos servir\u00e1 para abrir un documento XML, analizarlo y devolver el DOM generado en un <code>Document</code>. Lo podemos utilizar en cualquier sitio de nuestros programas, ya que la tarea es siempre similar:</p> <pre><code>    public Document OpenXML(String name) throws IOException, SAXException, ParserConfigurationException, FileNotFoundException {\n\n        // Create an instance of DocumentBuilderFactory\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        // Using the DocumentBuilderFactory instance we create a DocumentBuilder\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n\n        return dBuilder.parse(new File(name));\n    }\n</code></pre> <p>Hay que decir que la funci\u00f3n anterior podr\u00eda simplificarse sin utilizar las declaraciones intermedias, pero est\u00e1 algo ofuscada.</p> <pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException { \nreturn DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(name);\n}\n</code></pre> <p>Por otra parte, la clase <code>DocumentBuilder</code> tambi\u00e9n nos permite crear un nuevo DOM con el m\u00e9todo <code>newDocument()</code>. Esto nos servir\u00e1 m\u00e1s adelante para almacenar nuevos documentos XML. El procedimiento es el siguiente:</p> <ul> <li>Ante todo, debemos crear un nuevo DOM con <code>newDocument()</code>.</li> <li>A\u00f1adir los elementos y,</li> <li>Luego almacenarlo en un archivo.</li> </ul> <p>En secciones posteriores, veremos c\u00f3mo hacer todo esto. Por ahora, nos centraremos en interpretar y leer el DOM.</p> <p>Para m\u00e1s informaci\u00f3n, puedes consultar las clases DocumentBuilder y DocumentBuilderFactory en el API de OpenJDK.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#33-clases-y-metodos-de-dom","title":"3.3. Clases y M\u00e9todos de DOM","text":"<p>Hasta ahora hemos visto c\u00f3mo abrir y analizar un documento XML con <code>DocumentBuilder</code> para crear un objeto de tipo <code>Document</code>. En esta secci\u00f3n veremos c\u00f3mo trabajar con este documento para acceder a los distintos elementos. Como sabemos, el DOM tiene una estructura jer\u00e1rquica, formada por nodos. Los distintos tipos de nodos que podemos encontrar son:</p> <ul> <li><code>Document</code> \u2192 que es el nodo principal y representa todo el XML.</li> <li><code>Element</code> \u2192 que representa las diferentes etiquetas (incluyendo la etiqueta ra\u00edz). En otras palabras, todas las etiquetas son Elementos, unas dentro de otras.</li> <li><code>TextElement</code> \u2192 que representa el contenido de una etiqueta de texto.</li> <li><code>Attribute</code> \u2192 que representa los atributos.</li> </ul> <p>Todas estas interfaces derivan de la interfaz <code>Node</code>, por tanto, heredar\u00e1n sus atributos y m\u00e9todos, y adem\u00e1s, proporcionar\u00e1n sus propios atributos y m\u00e9todos.</p> <p>A continuaci\u00f3n, veremos los m\u00e9todos m\u00e1s importantes de cada interfaz:</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#331-metodos-de-nodo","title":"3.3.1. M\u00e9todos de Nodo","text":"<p>M\u00e9todos relacionados con la obtenci\u00f3n de informaci\u00f3n</p> <ul> <li><code>String getNodeName()</code> \u2192 Obtiene el nombre del nodo actual</li> <li><code>short getNodeType()</code> \u2192 Obtiene el tipo de nodo (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE...)</li> <li><code>String getNodeValue()</code>\u2192 Obtiene el valor del nodo</li> <li><code>NodeList getChildNodes()</code> \u2192 Obtiene una lista con los nodos hijos</li> <li><code>Node getFirstChild()</code> \u2192 Devuelve el primer hijo</li> <li><code>Node getLastChild()</code> \u2192 Devuelve el \u00faltimo hijo</li> <li><code>NamedNodeMap getAttributes()</code> \u2192 Devuelve una lista con los atributos del nodo</li> <li><code>Node getParentNode()</code> \u2192 Devuelve el nodo padre</li> <li><code>String getTextContent()</code> \u2192 Devuelve el texto contenido en el elemento y sus descendientes</li> <li><code>boolean hasChildNodes()</code> \u2192 Devuelve <code>true</code> si el nodo tiene alg\u00fan hijo</li> <li><code>boolean hasAttributes()</code> \u2192Devuelve <code>true</code> si el nodo tiene alg\u00fan atributo</li> </ul> <p>M\u00e9todos relacionados con la escritura</p> <ul> <li><code>Node appendChild(Node node)</code> \u2192 A\u00f1ade un nuevo nodo como \u00faltimo hijo.</li> <li><code>void removeChild(Node node)</code> \u2192 Elimina el nodo especificado de los nodos hijos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#332-metodos-de-la-interfaces-elemento","title":"3.3.2. M\u00e9todos de la interfaces Elemento:","text":"<p>M\u00e9todos relacionados con la obtenci\u00f3n de informaci\u00f3n</p> <ul> <li><code>String getAttribute(String name)</code> \u2192 Devuelve el valor del atributo dado por el nombre.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Devuelve una lista de nodos hijos que coinciden con el nombre dado.</li> <li><code>boolean hasAttribute(String name)</code> \u2192 Devuelve true si el elemento tiene el atributo dado.</li> </ul> <p>M\u00e9todos relacionados con la escritura</p> <ul> <li><code>void setAttribute(String name, String value)</code> \u2192 A\u00f1ade un atributo al elemento, con el nombre y valor dados.</li> <li><code>void removeAttribute(String name)</code> \u2192 Elimina el atributo indicado por el nombre.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#333-metodos-de-la-interfaz-documento","title":"3.3.3. M\u00e9todos de la interfaz Documento:","text":"<p>M\u00e9todos relacionados con la obtenci\u00f3n de informaci\u00f3n</p> <ul> <li><code>Element getDocumentElement()</code> \u2192 Devuelve el elemento ra\u00edz del documento.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Devuelve una lista de nodos hijos que coinciden con el nombre dado.</li> </ul> <p>M\u00e9todos relacionados con la escritura</p> <ul> <li><code>Element createElement(String name)</code> \u2192 Crea un elemento nuevo con el nombre dado.</li> <li><code>Text createTextNode(String text)</code> \u2192 Crea un nuevo elemento de texto.</li> <li><code>Node appendChild(Node node)</code> \u2192 A\u00f1ade un nuevo nodo hijo.</li> </ul> <p>Los objetos de tipo <code>NodeList</code>, que representan una lista de nodos, ofrecen el m\u00e9todo <code>item(int index)</code> para acceder a los distintos nodos de la lista, indicando su orden.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#34-lectura-de-archivos-xml","title":"3.4. Lectura de archivos XML","text":"<p>Vamos a repasar todos los conceptos de esta secci\u00f3n con una pr\u00e1ctica. Crearemos una clase que incluya todos los m\u00e9todos necesarios para abrir, leer, mostrar y escribir archivos XML. Trabajaremos con el documento de la secci\u00f3n anterior.</p> <p>Para empezar a leer el documento, lo primero que deberemos hacer es obtener el elemento ra\u00edz del documento con <code>getDocumentElement()</code>, que devuelve un objeto de tipo <code>Element</code>. Recuerda que la variable doc contiene todo el DOM, le\u00eddo con el m\u00e9todo explicado anteriormente:</p> <pre><code>Element root = doc.getDocumentElement();\n</code></pre> <p>Con este elemento ra\u00edz, ya podemos mostrar todo su contenido con <code>getTextContent()</code>. Se mostrar\u00e1 en pantalla en formato de texto, s\u00f3lo se imprimir\u00e1:</p> <pre><code>System.out.println(root.getTextContent());\n</code></pre> <p>Pero lo que nos interesa es recorrer todo el DOM y acceder a sus elementos. Para ello, a partir de este elemento ra\u00edz, seguiremos los siguientes pasos:</p> <ol> <li>Buscamos todos los tags <code>&lt;modulo&gt;</code> con <code>getElementsByTagName</code>. Este m\u00e9todo nos devuelve una lista de nodos (objeto de tipo <code>NodeList</code>).</li> <li>Ser\u00e1 necesario recorrer la lista de nodos (<code>NodeList</code>) para acceder a cada elemento. Para ello, es necesario utilizar el m\u00e9todo <code>item(int index)</code>, que devolver\u00e1 un elemento de tipo <code>Node</code>, y que debe convertirse expl\u00edcitamente a <code>Element</code> con una operaci\u00f3n de cast.</li> <li>Para cada elemento, accederemos al nombre del nodo para mostrar el nombre y el orden, utilizando <code>getNodeName()</code>.</li> <li>Buscamos las diferentes etiquetas encontradas dentro de cada m\u00f3dulo ('nombre', 'horas' y 'calificaci\u00f3n') con <code>getElementsByTagName()</code>. Este m\u00e9todo nos devolver\u00e1 una NodeList para cada tipo de etiqueta. Como s\u00f3lo tendremos un elemento, basta con acceder al elemento \u00fanico, representado por <code>item(0)</code>.</li> <li>Cabe destacar que con lo que hemos visto hasta ahora tendremos la primera (y \u00fanica) etiqueta 'nombre', 'horas' o 'calificaci\u00f3n' del m\u00f3dulo, pero todav\u00eda no estamos en el contenido, ya que esto es un elemento de tipo <code>TEXT_NODE</code>. Para acceder, deberemos acceder al primer hijo de la etiqueta (<code>getFirstChild()</code>) y obtener su valor con <code>getNodeValue()</code>.</li> </ol> <pre><code>// We will get a list of nodes (Step 1) \nNodeList modules = root.getElementsByTagName(\"modulo\"); \n\n// For each node (Step 2) \nfor (int i = 0; i &lt; modules.getLength(); i++) { \nElemento el = (Element) modules.item(i); \n\n// Display the node name (Step 3) \nSystem.out.println(el.getNodeName() + \" \" + (y + 1)); \n\n// And we show the value of the different tags \nSystem.out.println(\"Nombre: \" + el.getElementsByTagName(\"nombre\").item(0).getFirstChild().getNodeValue()); \nSystem.out.println(\"Horas: \" + el.getElementsByTagName(\"horas\").item(0).getFirstChild().getNodeValue()); \nSystem.out.println(\"Calificaci\u00f3n: \" + el.getElementsByTagName(\"calificacion\").item(0).getFirstChild().getNodeValue()); \nSystem.out.println(); \n}\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#35-escribir-archivos-xml","title":"3.5. Escribir archivos XML","text":"<p>Ahora vamos a la parte de escritura de los documentos XML. Por eso, partiremos de un archivo que ya contiene la informaci\u00f3n en formato binario de los m\u00f3dulos (por ejemplo, de la secci\u00f3n anterior), lo leeremos e importaremos su informaci\u00f3n en formato XML.</p> <p>Lo primero que debemos hacer es leer el archivo de objetos utilizando un <code>ObjectInputStream</code>:</p> <pre><code>ObjectInputStream f = new ObjectInputStream(new FileInputStream(file));\n</code></pre> <p>Y crearemos un documento vac\u00edo con las clases <code>DocumentBuilder</code> y <code>DocumentBuilderFactory</code>:</p> <pre><code>Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n</code></pre> <p>Una vez tenemos el documento vac\u00edo, creamos el elemento ra\u00edz (curso) y lo a\u00f1adimos al documento:</p> <pre><code>Elemento root = doc.createElement(\"curso\");\ndoc.appendChild(root);\n</code></pre> <p>Recuerda que accederemos al archivo de objetos, as\u00ed que deberemos saber exactamente c\u00f3mo es la clase que queremos leer y acceder a los m\u00e9todos correspondientes para obtener informaci\u00f3n sobre ella. Por eso, primero, debes definir un objeto de tipo <code>Modul</code>, y leeremos el archivo de objetos con el m\u00e9todo <code>readObject</code> de <code>File</code>. Una vez le\u00eddo un objeto, crearemos la etiqueta que engloba cada uno de ellos: la etiqueta <code>modulo</code>:</p> <pre><code>M\u00f3dulo m = (M\u00f3dulo) f.readObject();\nElemento modulo = doc.createElement(\"modulo\");\n</code></pre> <p>Dentro de \u00e9l, a medida que extraemos las diferentes propiedades del objeto del m\u00f3dulo, crearemos nodos secundarios y los a\u00f1adiremos al m\u00f3dulo. Por ejemplo, para el nombre del m\u00f3dulo:</p> <pre><code>Elemento name = doc.createElement(\"nombre\");\nname.appendChild(doc.createTextNode(m.getNom()));\nmodule.appendChild(name);\n</code></pre> <p>Como podemos ver, hemos creado un objeto de tipo Elemento con la etiqueta 'nombre', y hemos a\u00f1adido como hijo un nodo de tipo texto (TEXT_NODE), que hemos extra\u00eddo directamente del objeto <code>Modul m</code> con su propia funci\u00f3n <code>getModul()</code>. Adem\u00e1s, hemos a\u00f1adido esta etiqueta a la etiqueta <code>&lt;modul&gt;</code>, con <code>appendChild</code>.</p> <p>Deberemos hacer lo mismo para las horas de cada m\u00f3dulo y la calificaci\u00f3n, pero por ello, deberemos tener en cuenta que los m\u00e9todos getHores y getNota no devuelven una cadena de texto, sino un entero y un decimal, por lo que tendr\u00e1n que ser convertidos a texto:</p> <pre><code>Elemento hours = doc.createElement(\"horas\");\nhours.appendChild(doc.createTextNode(Integer.toString(m.getHores()))));\nmodule.appendChild(hours);\n\nElemento calificaci\u00f3n = doc.createElement(\"calificacion\");\ncalification.appendChild(doc.createTextNode(Double.toString(m.getNote()))));\nmodule.appendChild(grade);\n</code></pre> <p>Pondremos todo este procedimiento dentro de un bucle que recorrer\u00e1 todo el archivo de objetos. Una vez hayamos le\u00eddo cada uno de los m\u00f3dulos, deberemos a\u00f1adirlos al elemento ra\u00edz con:</p> <pre><code>root.appendChild(modulo);\n</code></pre> <p>Y ya tendremos el documento XML en la ra\u00edz. No se debe convertir este objeto en el tipo <code>Element</code> en cadena de texto en orden a la obtenci\u00f3n de la vuelta y de la etiqueta. Para esto, se debe utilizar la utilidad <code>`Transformer</code>.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#351-transformer","title":"3.5.1. Transformer","text":"<p>Java nos ofrece la utilidad <code>Transformer</code> para convertir informaci\u00f3n entre diferentes formatos jer\u00e1rquicos, como el objeto Documento que contiene el DOM de nuestro XML, a un archivo de texto XML.</p> <p>La clase <code>Transformer</code>, como <code>DocumentBuilder</code>, es tambi\u00e9n una clase abstracta, por lo que tambi\u00e9n requiere una f\u00e1brica para ser instanciada. La clase Transformer trabaja con dos tipos de adaptadores. Los adaptadores son clases que hacen compatibles distintas jerarqu\u00edas. Estos adaptadores son <code>Source</code> y <code>Result</code>. Las clases que implementan estos adaptadores ser\u00e1n las encargadas de hacer compatibles los distintos tipos de contenedores con los que requiere la clase Transformer. As\u00ed, y para aclararlo, tenemos las clases <code>DOMSource</code>, <code>SAXSource</code> o <code>StreamSource</code>, que son adaptadores del contenedor de origen de la informaci\u00f3n para DOM, SAX o Stream; y <code>DOMResult</code>, <code>SAXResult</code> y <code>StreamResult</code> como adaptadores equivalentes para el contenedor de destino.</p> <p>En nuestro caso, ya que tenemos un DOM y queremos convertirlo en un Stream, necesitaremos un <code>DomSource</code> y un <code>StreamResult</code>. Veremos el c\u00f3digo necesario para ello:</p> <pre><code>Transformer trans = TransformerFactory.newInstance().newTransformer();\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(new FileOutputStream(file+\".xml\"));\n</code></pre> <p>Lo primero que hemos hecho es crear un objeto de tipo <code>Transformer</code> con el m\u00e9todo <code>newTransformer()</code> de una instancia (newInstance()) de la f\u00e1brica de Transformers TransformerFactory. A continuaci\u00f3n, hemos definido la fuente (source) y el resultado (resultado) para la transformaci\u00f3n, siendo la fuente un DomSource creado a partir del doc que contiene nuestro documento, y el resultado un StreamResult, que escribir\u00e1 el flujo en el disco a trav\u00e9s de un FileOutputStream.</p> <p>Por \u00faltimo, hacemos la transformaci\u00f3n de un elemento a otro, que generar\u00e1 autom\u00e1ticamente el archivo XML de salida:</p> <pre><code>trans.transform(source, result);\n</code></pre>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#36-tecnicas-avanzadas-vinculacion-xml","title":"3.6. T\u00e9cnicas avanzadas: vinculaci\u00f3n XML","text":"<p>La t\u00e9cnica de vinculaci\u00f3n consiste en generar clases Java con formatos espec\u00edficos, como XML, de modo que cada etiqueta o atributo XML corresponda a una propiedad de una determinada clase. Esta correspondencia se llama mapeo.</p> <p>En Java, existen diferentes librer\u00edas para la vinculaci\u00f3n o mapeo: JAXB, JuBX, XMLBinding, etc. JAXB (Java Architecture for XML Binding) es una potente librer\u00eda que se ha incluido en el est\u00e1ndar desde JDK 6, pero se ha eliminado en la versi\u00f3n 11 y se sugiere incluirla como paquete externo. JAXB utiliza anotaciones para obtener la informaci\u00f3n necesaria para el mapeo de la vinculaci\u00f3n.Las anotaciones son indicaciones especiales de Java que permiten asociar informaci\u00f3n y funcionalidad a los objetos, sin interferir en la estructura del modelo de datos. Las anotaciones pueden asociarse con un paquete, una clase, un atributo o un par\u00e1metro, y se declaran con el s\u00edmbolo <code>@</code> delante del nombre de la anotaci\u00f3n. Cuando el compilador detecta una anotaci\u00f3n, crea una instancia y la inyecta en el elemento afectado, sin interferir en la clase misma. Cuando una aplicaci\u00f3n necesita la informaci\u00f3n de las anotaciones, puede obtener la instancia inyectada.</p> <p>Por ejemplo, en la clase <code>Modul</code> que hab\u00edamos definido, utilizar\u00edamos la anotaci\u00f3n <code>@XmlRootElement</code> para indicar el elemento ra\u00edz del m\u00f3dulo, y las anotaciones <code>@XmlElement</code> para indicar que los setters de la clase tambi\u00e9n escribir\u00e1n elementos XML.</p> <pre><code>@XmlRootElement\nclass Modulo { \n\nString nombre; \nint horas; \ndouble nota; \n\npublic String getNom() { return nombre; } \n@XmlElement \npublic void setNom(String nombre) { this.nom = nombre; } \n\n\npublic int getHores() { return horas; } \n@XmlElement \npublic void setHores(int horas) { this.hores = horas; } \n\npublic double getNota() { return nota; } \n@XmlElement \npublic void setNota(double nota) { this.nota = nota;}\n\n\n}\n</code></pre> <p>Con esto tendr\u00edamos s\u00f3lo la clase con las anotaciones preparadas para guardar un m\u00f3dulo como documento XML. Para guardar toda la jerarqu\u00eda deber\u00edamos crear la clase <code>Curso</code>, que contendr\u00eda un <code>ArrayList</code> de m\u00f3dulos.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#37-ejemplos-con-el-xml-inicial","title":"3.7. Ejemplos con el XML inicial","text":"<p>\ud83d\udcd6 Ejemplo 1: Lectura de XML con DOM</p> <pre><code>package org.dam;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport java.io.File;\n\npublic class LecturaCursoXML {\n    public static void main(String[] args) {\n        try {\n            File archivo = new File(\"curso.xml\");\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(archivo);\n\n            document.getDocumentElement().normalize();\n\n            System.out.println(\"Elemento ra\u00edz: \" + document.getDocumentElement().getNodeName());\n\n            NodeList listaModulos = document.getElementsByTagName(\"modulo\");\n\n            System.out.println(\"\\n=== M\u00d3DULOS DEL CURSO ===\");\n            System.out.printf(\"%-45s %-8s %-12s%n\", \"Nombre\", \"Horas\", \"Calificaci\u00f3n\");\n            System.out.println(\"--------------------------------------------------------------\");\n\n            for (int i = 0; i &lt; listaModulos.getLength(); i++) {\n                Node nodo = listaModulos.item(i);\n\n                if (nodo.getNodeType() == Node.ELEMENT_NODE) {\n                    Element elemento = (Element) nodo;\n\n                    String nombre = elemento.getElementsByTagName(\"nombre\").item(0).getTextContent();\n                    String horas = elemento.getElementsByTagName(\"horas\").item(0).getTextContent();\n                    String calificacion = elemento.getElementsByTagName(\"calificacion\").item(0).getTextContent();\n\n                    System.out.printf(\"%-45s %-8s %-12s%n\",\n                            nombre.length() &gt; 40 ? nombre.substring(0, 40) + \"...\" : nombre,\n                            horas,\n                            calificacion);\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}   \n</code></pre> <p>\ud83d\udcdd Ejemplo 2: Escritura de XML con DOM</p> <pre><code>package org.dam;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport java.io.File;\n\npublic class EscrituraCursoXML {\n    public static void main(String[] args) {\n        try {\n            // Crear el DocumentBuilder\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.newDocument();\n\n            // Crear el elemento ra\u00edz &lt;curso&gt;\n            Element curso = document.createElement(\"curso\");\n            document.appendChild(curso);\n\n            // Crear m\u00f3dulos seg\u00fan la estructura proporcionada\n            crearModulo(document, curso, \"Acceso a Datos\", 6, 8.45);\n            crearModulo(document, curso, \"Programaci\u00f3n de servicios y procesos\", 3, 9.0);\n            crearModulo(document, curso, \"Desarrollo de interfaces\", 6, 8.0);\n            crearModulo(document, curso, \"Programaci\u00f3n Multimedia y dispositivos m\u00f3viles\", 5, 7.34);\n            crearModulo(document, curso, \"Sistemas de Gesti\u00f3n Empresarial\", 5, 8.2);\n            crearModulo(document, curso, \"Empresa e iniciativa emprendedora\", 3, 7.4);\n\n            // Escribir el contenido en un archivo XML\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, \"yes\");\n            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\n            DOMSource source = new DOMSource(document);\n            StreamResult result = new StreamResult(new File(\"curso.xml\"));\n\n            transformer.transform(source, result);\n\n            System.out.println(\"Archivo XML creado correctamente!\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void crearModulo(Document document, Element curso, String nombre,\n                                    int horas, double calificacion) {\n        Element modulo = document.createElement(\"modulo\");\n        curso.appendChild(modulo);\n\n        Element nom = document.createElement(\"nombre\");\n        nom.appendChild(document.createTextNode(nombre));\n        modulo.appendChild(nom);\n\n        Element horasElem = document.createElement(\"horas\");\n        horasElem.appendChild(document.createTextNode(String.valueOf(horas)));\n        modulo.appendChild(horasElem);\n\n        Element calificacionElem = document.createElement(\"calificacion\");\n        calificacionElem.appendChild(document.createTextNode(String.valueOf(calificacion)));\n        modulo.appendChild(calificacionElem);\n    }\n}\n</code></pre> <p>\ud83c\udfd7\ufe0f Ejemplo 3: JAXB - Escritura y Lectura</p> <p>Clase Modulo para JAXB:</p> <p><pre><code>package org.dam;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport jakarta.xml.bind.annotation.XmlType;\n\n@XmlRootElement(name = \"m\u00f3dulo\")\n@XmlType(propOrder = {\"nombre\", \"horas\", \"calificacion\"})\npublic class Modulo {\n    private String nombre;\n    private int horas;\n    private double calificacion;\n\n    public Modulo() {\n        // Constructor por defecto necesario para JAXB\n    }\n\n    public Modulo(String nombre, int horas, double calificacion) {\n        this.nombre = nombre;\n        this.horas = horas;\n        this.calificacion = calificacion;\n    }\n\n    @XmlElement(name = \"nom\")\n    public String getNombre() { return nombre; }\n    public void setNombre(String nombre) { this.nombre = nombre; }\n\n    @XmlElement(name = \"horas\")\n    public int getHoras() { return horas; }\n    public void setHoras(int horas) { this.horas = horas; }\n\n    @XmlElement(name = \"calificaci\u00f3n\")\n    public double getCalificacion() { return calificacion; }\n    public void setCalificacion(double calificacion) { this.calificacion = calificacion; }\n\n    @Override\n    public String toString() {\n        return String.format(\"%-40s %d horas - %.2f\",\n                nombre.length() &gt; 35 ? nombre.substring(0, 35) + \"...\" : nombre,\n                horas, calificacion);\n    }\n}\n</code></pre> Clase Curso para JAXB:</p> <pre><code>package org.dam;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@XmlRootElement(name = \"curso\")\npublic class Curso {\n    private List&lt;Modulo&gt; modulos = new ArrayList&lt;&gt;();\n\n    @XmlElement(name = \"modulo\")\n    public List&lt;Modulo&gt; getModulos() { return modulos; }\n    public void setModulos(List&lt;Modulo&gt; modulos) { this.modulos = modulos; }\n\n    public void addModulo(Modulo modulo) {\n        modulos.add(modulo);\n    }\n}\n</code></pre> <p>Escritura con JAXB:</p> <pre><code>package org.dam;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.Marshaller;\nimport java.io.File;\n\npublic class EscrituraJAXBCurso {\n    public static void main(String[] args) {\n        try {\n            // Crear el curso con m\u00f3dulos\n            Curso curso = new Curso();\n            curso.addModulo(new Modulo(\"Acceso a Datos\", 6, 8.45));\n            curso.addModulo(new Modulo(\"Programaci\u00f3n de servicios y procesos\", 3, 9.0));\n            curso.addModulo(new Modulo(\"Desarrollo de interfaces\", 6, 8.0));\n            curso.addModulo(new Modulo(\"Programaci\u00f3n Multimedia y dispositivos m\u00f3viles\", 5, 7.34));\n            curso.addModulo(new Modulo(\"Sistemas de Gesti\u00f3n Empresarial\", 5, 8.2));\n            curso.addModulo(new Modulo(\"Empresa e iniciativa emprendedora\", 3, 7.4));\n\n            // Configurar JAXB\n            JAXBContext context = JAXBContext.newInstance(Curso.class);\n            Marshaller marshaller = context.createMarshaller();\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n            marshaller.setProperty(Marshaller.JAXB_ENCODING, \"UTF-8\");\n\n            // Escribir en archivo\n            marshaller.marshal(curso, new File(\"curso_jaxb.xml\"));\n            System.out.println(\"XML creado con JAXB exitosamente!\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>Lectura con JAXB:</p> <p><pre><code>package org.dam;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\n\npublic class LecturaJAXBCurso {\n    public static void main(String[] args) {\n        try {\n            JAXBContext context = JAXBContext.newInstance(Curso.class);\n            Unmarshaller unmarshaller = context.createUnmarshaller();\n\n            Curso curso = (Curso) unmarshaller.unmarshal(new File(\"curso_jaxb.xml\"));\n\n            System.out.println(\"=== M\u00d3DULOS DEL CURSO (JAXB) ===\");\n            System.out.printf(\"%-45s %-8s %-12s%n\", \"Nombre\", \"Horas\", \"Calificaci\u00f3n\");\n            System.out.println(\"--------------------------------------------------------------\");\n\n            for (Modulo modulo : curso.getModulos()) {\n                System.out.println(modulo);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> Recuerda a\u00f1adir la dependencia de jakarta en el pom.xml</p> <pre><code>        &lt;!-- https://mvnrepository.com/artifact/jakarta.xml.bind/jakarta.xml.bind-api --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.2&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Por lo que se refiere a este curso, no profundizaremos m\u00e1s en esta t\u00e9cnica, ya que para nuestros prop\u00f3sitos, el an\u00e1lisis XML que hemos visto en las secciones anteriores es suficiente, o no :)</p> <p>Cada vez m\u00e1s</p> <p>Utilizaremos muchas anotaciones en este curso, mantenga la calma...</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/","title":"4. Archivos JSON","text":"<p>JSON es otro formato de texto ligero para el intercambio de datos. JSON significa JavaScript Object Notation y es un subconjunto de la notaci\u00f3n literal de objetos del lenguaje, que se ha adoptado junto con XML como uno de los principales est\u00e1ndares para el intercambio y almacenamiento de datos.</p> <p>Una de las ventajas de JSON respecto a XML es la facilidad de escribir analizadores, pero lo que es m\u00e1s importante es que expresa lo mismo que XML pero de una forma mucho m\u00e1s concreta y concisa, por lo que se utiliza habitualmente en entornos donde el flujo de datos es importante, como es el caso de los servidores de Google, Yahoo, etc., que atienden a millones de usuarios.</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#41-formato-json","title":"4.1. Formato JSON","text":"<p>La especificaci\u00f3n completa puede verse aqu\u00ed</p> <p>Los tipos de datos que podemos representar en JSON son:</p> <ul> <li>N\u00fameros, tanto enteros como decimales.</li> <li>Cadenas de texto, expresadas entre comillas y con la posibilidad de incluir secuencias de escape.</li> <li>Booleans, para representar los valores <code>true</code> y <code>false</code>.</li> <li>Null, para representar el valor <code>null</code>.</li> <li>Array, para representar listas de cero o m\u00e1s valores, de cualquier tipo, cerradas entre corchetes y separadas por comas.</li> <li>Objetos, como colecciones de pares <code>&lt;clave&gt;:&lt;valor&gt;</code>, separados por comas y entre claves, y de cualquier tipo de valor.</li> </ul> <p>Lo veremos mejor con un ejemplo bien conocido: el de los m\u00f3dulos con los que estamos trabajando:</p> <pre><code>{ \n\"curso\": [ \n{ \n\"nombre\": \"Acceso a Datos\", \n\"horas\": 6, \n\"calificaci\u00f3n\": 8.45 \n}, \n{ \n\"nombre\": \"Programaci\u00f3n de servicios y procesos\", \n\"horas\": 3, \n\"calificaci\u00f3n\": 9.0 \n}, \n{ \n\"nombre\": \"Desarrollo de interfaces\", \n\"horas\": 6, \n\"calificaci\u00f3n\": 8.0 \n}, \n{ \n\"nombre\": \"Programaci\u00f3n Multimedia y dispositivos m\u00f3viles\", \n\"horas\": 5, \n\"calificaci\u00f3n\": 7.34 \n}, \n{ \n\"nombre\": \"Sistemas de Gesti\u00f3n Empresarial\", \n\"horas\": 5, \n\"calificaci\u00f3n\": 8.2 \n}, \n{ \n\"nombre\": \"Empresa e iniciativa emprendedora\", \n\"horas\": 3, \n\"calificaci\u00f3n\": 7.4 \n} \n]\n}\n</code></pre> <p>Veremos c\u00f3mo <code>curso</code> es un array o una lista de m\u00f3dulos (aunque ahora no utilizamos la etiqueta \"m\u00f3dulo\"), que en este caso son objetos con tres elementos: el nombre, que es una cadena de caracteres, las horas, que es un entero, y la calificaci\u00f3n, que se representa como un n\u00famero decimal. Cabe destacar que, como en XML, tambi\u00e9n necesitamos un objeto ra\u00edz, en este caso el elemento \"curso\".</p> <p>Internet est\u00e1 lleno de servicios que ofrecen informaci\u00f3n en formato JSON. Por ejemplo, puede visitar:</p> <ul> <li>https://arkhamdb.com/api/public/card/01001</li> <li>https://swapi.dev/api/films/1/</li> <li>http://hp-api.herokuapp.com/api/characters</li> </ul> <p>Existe una amplia gama de librer\u00edas de Java para manipular documentos JSON (GSON, Jackson, JSON.simple...). En nuestro caso, utilizaremos la librer\u00eda <code>org.json</code>, que podemos consultar en el repositorio Maven: https://mvnrepository.com/artifact/org.json/json</p> <p>En la siguiente secci\u00f3n comentaremos la funcionalidad de la librer\u00eda, y en un documento adjunto, veremos c\u00f3mo incorporarla a nuestros proyectos mediante el gestor de dependencias Gradle.</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#42-gson","title":"4.2. <code>Gson</code>","text":"<p>Gson es una biblioteca Java que permite convertir objetos Java a su representaci\u00f3n JSON. Tambi\u00e9n permite convertir una cadena JSON en un objeto Java equivalente. Gson puede trabajar con cualquier objeto Java, incluyendo objetos preexistentes cuyo c\u00f3digo fuente no se conoce.</p> <p>Existen algunos proyectos de c\u00f3digo abierto que permiten convertir objetos Java a JSON. Sin embargo, la mayor\u00eda requiere la inclusi\u00f3n de anotaciones Java en las clases, algo que no es posible si no se tiene acceso al c\u00f3digo fuente. Adem\u00e1s, la mayor\u00eda no admite completamente el uso de gen\u00e9ricos de Java. Gson considera ambos objetivos de dise\u00f1o muy importantes.</p> <p>Gson se centra principalmente en Java. Usarlo con otros lenguajes JVM como Kotlin o Scala puede funcionar correctamente en muchos casos, pero las caracter\u00edsticas espec\u00edficas de cada lenguaje, como los tipos no nulos de Kotlin o los constructores con argumentos predeterminados, no son compatibles. Esto puede generar un comportamiento confuso e incorrecto. Al usar lenguajes distintos de Java, es preferible una biblioteca JSON con soporte expl\u00edcito para ese lenguaje.</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#objetivos","title":"Objetivos","text":"<ul> <li>Proporcionar m\u00e9todos simples <code>toJson()</code> y <code>fromJson()</code> para convertir objetos Java a JSON y viceversa.</li> <li>Permitir la conversi\u00f3n de objetos preexistentes no modificables a y desde JSON.</li> <li>Amplio soporte para gen\u00e9ricos de Java.</li> <li>Permitir representaciones personalizadas de objetos.</li> <li>Admitir objetos de complejidad arbitraria (con jerarqu\u00edas de herencia profundas y uso extensivo de tipos gen\u00e9ricos).</li> </ul>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#42-clase-modulo","title":"4.2. Clase Modulo","text":"<p>Nuestros ejemplos se basan en los datos de los m\u00f3dulos de DAM vistos en las secciones anteriores. Considera este bloque de c\u00f3digo como punto de partida donde se crea un array <code>curso</code> y se llena con m\u00f3dulos. Para ello creamos la clase Modulo:</p> Modulo.java<pre><code>package org.example.pojo;\n\npublic class Modulo {\n    private String nombre;\n    private int horas;\n    private double nota;\n\n    // Constructores\n    public Modulo() {}  // Necesario para GSON\n\n    public Modulo(String nombre, int horas, double nota) {\n        this.nombre = nombre;\n        this.horas = horas;\n        this.nota = nota;\n    }\n\n    // Getters y Setters\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getHoras() {\n        return horas;\n    }\n\n    public double getNota() {\n        return nota;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s (%d horas) - Nota: %.2f\", nombre, horas, nota);\n    }\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#43-clase-curso","title":"4.3. Clase Curso","text":"<p>La clase Curso se va a considerar el contenedor principal. </p> <ul> <li>Se hace uso de <code>@SerializedName</code> para garantizar el mapeo exacto con el campo <code>curso</code>del JSON.</li> <li>M\u00e9todos de conversi\u00f3n integrados (<code>toJson()</code>/<code>fromJson()</code>).</li> </ul> Curso.java<pre><code>package org.example.pojo;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.annotations.SerializedName;\nimport java.util.List;\n\npublic class Curso {\n    @SerializedName(\"curso\")  // Anotaci\u00f3n para mapear exactamente el campo JSON\n    private List&lt;Modulo&gt; modulos;\n\n    // Constructor necesario para GSON\n    public Curso() {\n    }\n\n    // Constructor para creaci\u00f3n manual\n    public Curso(List&lt;Modulo&gt; modulos) {\n        this.modulos = modulos;\n    }\n\n    // Getter y Setter (obligatorios para GSON)\n    public List&lt;Modulo&gt; getModulos() {\n        return modulos;\n    }\n\n    public void setModulos(List&lt;Modulo&gt; modulos) {\n        this.modulos = modulos;\n    }\n\n    // M\u00e9todo para facilitar la conversi\u00f3n a JSON\n    public String toJson() {\n        return new GsonBuilder().setPrettyPrinting().create().toJson(this);\n    }\n\n    // M\u00e9todo est\u00e1tico para crear desde JSON\n    public static Curso fromJson(String json) {\n        return new Gson().fromJson(json, Curso.class);\n    }\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#44-clase-cursofileutils","title":"4.4. Clase CursoFileUtils","text":"<p>Esta clase contendr\u00e1 un par de m\u00e9todos que nos permitir\u00e1n guardar y leer los cursos del fichero JSON</p> CursoFileUtils.java<pre><code>package org.example.utils;\n\nimport org.example.pojo.Curso;\n\nimport java.io.*;\n\npublic class CursoFileUtils {\n    public static void guardarCurso(Curso curso, String filePath) throws IOException {\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(curso.toJson());\n        }\n    }\n\n    public static Curso cargarCurso(String filePath) throws IOException {\n        try (FileReader reader = new FileReader(filePath)) {\n            StringBuilder json = new StringBuilder();\n            int c;\n            while ((c = reader.read()) != -1) {\n                json.append((char) c);\n            }\n            return Curso.fromJson(json.toString());\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#44-clase-main","title":"4.4. Clase Main","text":"<p>Desde la clase Main podemos ver el funcionamiento del mismo</p> Main.java<pre><code>package org.example;\n\nimport org.example.pojo.Curso;\nimport org.example.pojo.Modulo;\nimport org.example.utils.CursoFileUtils;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            // 1. Crear datos\n            List&lt;Modulo&gt; modulos = Arrays.asList(\n                    new Modulo(\"Acceso a Datos\", 6, 8.45),\n                    new Modulo(\"Programaci\u00f3n\", 3, 9.0)\n            );\n\n            Curso curso = new Curso(modulos);\n\n            // 2. Guardar en archivo\n            CursoFileUtils.guardarCurso(curso, \"2dam.json\");\n            System.out.println(\"Datos guardados correctamente\");\n\n            // 3. Cargar desde archivo\n            Curso cursoCargado = CursoFileUtils.cargarCurso(\"2dam.json\");\n            System.out.println(\"\\nM\u00f3dulos cargados:\");\n            cursoCargado.getModulos().forEach(System.out::println);\n\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>Con esta separaci\u00f3n obtenemos la siguiente estructura:</p> <ol> <li>Anotaci\u00f3n @SerializedName: Garantiza el mapeo exacto con el campo \"curso\" del JSON.</li> <li>Separaci\u00f3n de responsabilidades:<ol> <li>Curso maneja la estructura contenedora</li> <li>Modulo maneja los datos individuales</li> <li>CursoFileUtils gestiona la persistencia</li> </ol> </li> <li>M\u00e9todos de conversi\u00f3n integrados (<code>toJson()</code>/<code>fromJson()</code>).</li> <li>Manejo seguro de recursos con try-with-resources.</li> </ol>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/","title":"5. Formatos extra","text":"<p>En esta secci\u00f3n estudiaremos dos tipos de archivos de texto que se utilizan ampliamente en inform\u00e1tica y la forma de trabajar con ellos.</p>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#51-archivos-csv","title":"5.1. Archivos CSV","text":"<p>Un archivo de valores separados por comas (CSV) es un archivo de texto est\u00e1ndar que utiliza una coma (<code>,</code>) para separar los valores. Cada l\u00ednea del archivo consiste en uno o m\u00e1s campos separados por comas. Cada campo puede o no estar cerrado entre comillas dobles. Adem\u00e1s, varios formatos utilizan distintos caracteres como separador, como el punto y coma (<code>;</code>) o el s\u00edmbolo de numeral (<code>#</code>). RFC 4180 define el formato o definiciones de un archivo CSV o archivo de texto/csv.</p> <p>En caso de que el s\u00edmbolo utilizado como separador aparezca dentro de los valores, es buena idea cerrar el contenido entre comillas. Se puede ver un ejemplo de archivo CSV aqu\u00ed:</p> <pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.0;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.0;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;0;8;383.0;170.0;3563.0;10.0;70;US\nPlymouth Cuda 340;0;8;340.0;160.0;3609.0;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.0;8.0;70;US\n</code></pre> <p>La forma de procesar un archivo CSV en Java es:</p> <ol> <li>Abrir el archivo como archivo de texto para la lectura. Debemos leer l\u00ednea por l\u00ednea, ya que cada l\u00ednea es un registro. Leer una l\u00ednea en una variable de tipo <code>String</code>.</li> <li>Procesar los registros individuales: </li> <li>Podemos separar cada campo. Una buena opci\u00f3n es utilizar el m\u00e9todo <code>split(char)</code> de la clase String. Obtengamos un array de cadenas con los valores de los campos individuales. </li> <li>Procesar cada valor de campo seg\u00fan sus necesidades.</li> </ol> <p>Atenci\u00f3n</p> <p>Es una buena idea empezar a utilizar las clases abstractas <code>Files</code> y <code>Paths</code>. Estas clases mejoran el uso de la clase File y sus clases derivadas, ofreciendo m\u00e9todos \u00fatiles que nos permiten realizar operaciones r\u00e1pidas con menos l\u00edneas de c\u00f3digo. Por ejemplo, la siguiente l\u00ednea, a partir del <code>filename</code>, la abre y despu\u00e9s lee todo el archivo, devolviendo una lista con las l\u00edneas separadas en cada elemento de la colecci\u00f3n. </p> <pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename)); \n</code></pre> <p>Veamos como podr\u00edamos estrcuturar nuestro programa para poder leer de un fichero CSV con esta estructura.</p> <p>Para ello nos definimos la clase Coche:</p> <pre><code>package org.dam;\n\n// Clase para representar un coche con los campos correctos\npublic class Coche {\n    String nombre;\n    int kilometros;\n    int velocidades;\n    double potenciaCV;\n    double potenciaKW;\n    double cilindrada;\n    double aceleracion0a100;\n    int decada;\n    String paisFabricacion;\n\n    public Coche(String[] datos) {\n        this.nombre = datos[0];\n        this.kilometros = Integer.parseInt(datos[1]);\n        this.velocidades = Integer.parseInt(datos[2]);\n        this.potenciaCV = Double.parseDouble(datos[3]);\n        this.potenciaKW = Double.parseDouble(datos[4]);\n        this.cilindrada = Double.parseDouble(datos[5]);\n        this.aceleracion0a100 = Double.parseDouble(datos[6]);\n        this.decada = Integer.parseInt(datos[7]);\n        this.paisFabricacion = datos[8];\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s - %d km, %d vel, %.1f CV, %.1f KW, %.1f cc, %.1f s (0-100), %ds, %s\",\n                nombre, kilometros, velocidades, potenciaCV, potenciaKW,\n                cilindrada, aceleracion0a100, decada, paisFabricacion);\n    }\n\n    // M\u00e9todo para mostrar informaci\u00f3n formateada\n    public String mostrarInfoDetallada() {\n        return String.format(\n                \"\\n=== %s ===\\n\" +\n                        \"Kil\u00f3metros: %d km\\n\" +\n                        \"N\u00famero de velocidades: %d\\n\" +\n                        \"Potencia: %.1f CV (%.1f KW)\\n\" +\n                        \"Cilindrada: %.1f cc\\n\" +\n                        \"Aceleraci\u00f3n 0-100 km/h: %.1f segundos\\n\" +\n                        \"D\u00e9cada: %ds\\n\" +\n                        \"Pa\u00eds de fabricaci\u00f3n: %s\",\n                nombre, kilometros, velocidades, potenciaCV, potenciaKW,\n                cilindrada, aceleracion0a100, decada, paisFabricacion\n        );\n    }\n}\n</code></pre> <p>Ahora el programa principal</p> <pre><code>package org.dam;\n\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LectorCSVCoches {\n\n    public static void main(String[] args) {\n        String fichero = \"coches.csv\";\n\n        try {\n            // Leer todas las l\u00edneas del archivo CSV\n            List&lt;String&gt; lines = Files.readAllLines(Paths.get(fichero));\n            List&lt;Coche&gt; coches = new ArrayList&lt;&gt;();\n\n            System.out.println(\"=== LECTURA DE ARCHIVO CSV DE COCHES ===\");\n            System.out.println(\"N\u00famero total de registros: \" + lines.size());\n\n            // Procesar cada l\u00ednea del archivo\n            for (int i = 0; i &lt; lines.size(); i++) {\n                String line = lines.get(i);\n                String[] campos = line.split(\";\");\n\n                // Verificar que tenga todos los campos necesarios\n                if (campos.length &gt;= 9) {\n                    try {\n                        Coche coche = new Coche(campos);\n                        coches.add(coche);\n                        System.out.println(coche.mostrarInfoDetallada());\n                    } catch (NumberFormatException e) {\n                        System.err.println(\"Error en formato num\u00e9rico en l\u00ednea \" + (i+1) + \": \" + line);\n                    }\n                } else {\n                    System.err.println(\"L\u00ednea incompleta \" + (i+1) + \": \" + line);\n                }\n            }\n\n            // Mostrar estad\u00edsticas generales\n            mostrarEstadisticas(coches);\n\n        } catch (IOException e) {\n            System.err.println(\"Error al leer el archivo: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    // M\u00e9todo para mostrar estad\u00edsticas de los coches\n    private static void mostrarEstadisticas(List&lt;Coche&gt; coches) {\n        if (coches.isEmpty()) return;\n\n        System.out.println(\"\\n=== ESTAD\u00cdSTICAS GENERALES ===\");\n\n        double totalPotenciaCV = 0;\n        double totalPotenciaKW = 0;\n        double totalCilindrada = 0;\n        double totalAceleracion = 0;\n        int totalKilometros = 0;\n\n        for (Coche coche : coches) {\n            totalPotenciaCV += coche.potenciaCV;\n            totalPotenciaKW += coche.potenciaKW;\n            totalCilindrada += coche.cilindrada;\n            totalAceleracion += coche.aceleracion0a100;\n            totalKilometros += coche.kilometros;\n        }\n\n        System.out.printf(\"N\u00famero de coches: %d%n\", coches.size());\n        System.out.printf(\"Potencia media: %.1f CV (%.1f KW)%n\",\n                totalPotenciaCV / coches.size(), totalPotenciaKW / coches.size());\n        System.out.printf(\"Cilindrada media: %.1f cc%n\", totalCilindrada / coches.size());\n        System.out.printf(\"Aceleraci\u00f3n media 0-100: %.1f segundos%n\", totalAceleracion / coches.size());\n        System.out.printf(\"Kil\u00f3metros totales: %d km%n\", totalKilometros);\n\n        // Agrupar por pa\u00eds\n        System.out.println(\"\\n=== COCHES POR PA\u00cdS ===\");\n        coches.stream()\n                .collect(java.util.stream.Collectors.groupingBy(c -&gt; c.paisFabricacion,\n                        java.util.stream.Collectors.counting()))\n                .forEach((pais, count) -&gt; System.out.printf(\"%s: %d coches%n\", pais, count));\n    }\n}\n</code></pre> <p>M\u00e1s informaci\u00f3n en: </p> <ul> <li>Files </li> <li>Paths</li> </ul>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#52-archivos-de-propiedades","title":"5.2. Archivos de propiedades","text":""},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#521-archivo-de-propiedades","title":"5.2.1. Archivo de propiedades","text":"<p>Por \u00faltimo, pero no menos importante, le mostraremos un tipo de archivo de texto importante, que son los archivos de propiedades. Estos archivos almacenan, como ya sab\u00e9is, varias propiedades que se utilizan durante la ejecuci\u00f3n del programa. Cuando el programa se inicia, carga estas propiedades y ajusta varias opciones. Ejemplos de estos archivos son <code>my.conf</code> en MySQL, <code>php.ini</code> en PHP, etc.</p> <p>El aspecto de este archivo consiste en varias l\u00edneas (una por propiedad) y cada l\u00ednea tiene el formato <code>atributo=valor</code>. Por ejemplo, un supuesto archivo:</p> <pre><code># properties of my program\npuerto=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>La forma de procesar un archivo de propiedades en Java es similar a un CSV:</p> <ol> <li>Abrir como archivo de texto para la lectura. Debemos leer l\u00ednea por l\u00ednea, ya que cada l\u00ednea es una propiedad distinta. Leer una l\u00ednea en una variable de tipo <code>String</code>.</li> <li>Procesar los registros individuales: </li> <li>Podemos separar cada campo. Una buena opci\u00f3n es utilizar el m\u00e9todo <code>split(char)</code> de la clase String. Obtengamos un array de cadenas con los valores de los campos individuales. Los separadores normalmente son <code>=</code>, <code>:</code>. </li> <li>La izquierda del separador es el nombre de la propiedad. </li> <li>La derecha del separador es el valor de la propiedad. </li> <li>Hay que tener en cuenta que si una l\u00ednea comienza con barra (<code>#</code>), es un comentario y se ignorar\u00e1.</li> </ol>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#522-propiedades-de-java","title":"5.2.2. Propiedades de Java","text":"<p>Java tiene un objeto muy \u00fatil para manejar este tipo de informaci\u00f3n. Con los objetos preperties de Java, podemos almacenar un conjunto de propiedades con una tabla de hash (b\u00e1sicamente una pareja clave-valor). Tiene m\u00e9todos preparados para cargar y guardar desde y hacia flujos de texto o, incluso, archivos XML. Algunos m\u00e9todos interesantes para las propiedades son:</p> <p>Lectura desde archivo (texto o XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Lee un conjunto de propiedades (parejas clave-elemento) desde el flujo de entrada de bytes.</li> <li><code>void load(Reader reader)</code> \u2192 Lee un conjunto de propiedades (parejas clave-elemento) desde el flujo de entrada de caracteres en un formato sencillo orientado a l\u00edneas.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Carga todas las propiedades representadas por el documento XML en el flujo de entrada especificado en esta tabla de propiedades.</li> </ul> <p>Escritura en archivo (texto o XML)</p> <ul> <li><code>void store(OutputStream out, Str.ing comments)</code> \u2192 Escribe este conjunto de propiedades (parejas clave-elemento) en esta tabla de propiedades en el flujo de salida en un formato adecuado para cargarlo en una tabla de propiedades utilizando el m\u00e9todo load(InputStream).</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Escribe este conjunto de propiedades (parejas clave-elemento) en esta tabla de propiedades en el flujo de caracteres de salida en un formato adecuado para utilizar el m\u00e9todo load(Reader).</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emite un documento XML que representa todas las propiedades contenidas en esta tabla.</li> </ul> <p>Trabajo con propiedades (heredado de HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Devuelve una vista de conjunto de las claves contenidas en este mapa.</li> <li><code>V get(Object key)</code> \u2192 Devuelve el valor (<code>V</code>) al que se asigna la clave especificada, o <code>null</code> si este mapa no contiene ninguna asignaci\u00f3n para la clave.</li> <li><code>boolean containsKey(Object key)</code> Comprueba si el objeto especificado es una clave de esta tabla de hash.</li> <li><code>V put(K key, V value)</code> \u2192 Asigna la clave especificada al valor especificado en esta tabla de hash.</li> <li><code>V remove(Object key)</code> \u2192 Elimina la clave (y se devuelve el valor correspondiente) de esta tabla de hash.</li> </ul>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#523-programa-de-ejemplo","title":"5.2.3. Programa de ejemplo","text":"<p>En el siguiente programa, puede ver un ejemplo de lectura y creaci\u00f3n de archivos de propiedades en Java.</p> <pre><code>package org.dam;\n\nimport java.io.*;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class PropertiesManager {\n\n    /**\n     * Carga el archivo especificado y muestra sus propiedades de diferentes maneras\n     * @param fichero\n     */\n    private void loadAndShowProperties(String fichero) {\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(fichero)));\n\n            System.out.println(\"=== CONJUNTO COMPLETO ===\");\n            System.out.println(properties);\n            System.out.println();\n\n            System.out.println(\"=== SALIDA DE LISTA ===\");\n            properties.list(System.out);\n            System.out.println();\n\n            Set&lt;Object&gt; keys = properties.keySet();\n\n                System.out.println(\"=== MI LISTADO ===\");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            System.err.println(\"Fichero no encontrado \" + fichero);\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.err.println(\"Error leyendo fichero: \" + fichero);\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Crear un objeto de propiedades, rellenado con muestras y almacenado\n     * en un archivo de texto y un archivo XML.\n     * @throws IOException\n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        // Almacenado en fichero de texto\n        props.store(new FileWriter(new File(\"promise.properties\")), \"Ejemplo fichero de propiedades\");\n\n        // Almacenado en fichero XML\n        props.storeToXML(new FileOutputStream(new File(\"promise.xml\")), \"Ejemplo de propiedades en XML\");\n\n        System.out.println(\"Fichero de Properties creado satisfactoriamente!\");\n        System.out.println(\"Fichero de texto: promise.properties\");\n        System.out.println(\"Fichero XML: promise.xml\");\n    }\n\n    /**\n     * M\u00e9todo principal para demostrar la funcionalidad\n     */\n    public static void main(String[] args) {\n        PropertiesManager manager = new PropertiesManager();\n\n        try {\n            // First, create the properties files\n            System.out.println(\"Creando ficheros...\");\n            manager.writeProperties();\n            System.out.println();\n\n            // Then, read and display the properties from the text file\n            System.out.println(\"Leyendo el fichero de propiedades...\");\n            manager.loadAndShowProperties(\"promise.properties\");\n            System.out.println();\n\n            // Also read and display from the XML file\n            System.out.println(\"Leyendo el fichero en XML..\");\n            manager.loadAndShowProperties(\"promise.xml\");\n\n        } catch (IOException e) {\n            System.err.println(\"Error en la ejecuci\u00f3n del programa principal: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#53-entorno-archivos-env-y-dot_env","title":"5.3. Entorno, archivos <code>.env</code> y <code>dot_env</code>","text":""},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#531-por-que-utilizar-variables-de-entorno","title":"5.3.1. \u00bfPor qu\u00e9 utilizar variables de entorno?","text":"<p>Las variables de entorno son un aspecto crucial para configurar y gestionar aplicaciones en distintos entornos, como desarrollo, pruebas y producci\u00f3n. Proporcionan una forma de pasar din\u00e1micamente datos de configuraci\u00f3n a las aplicaciones sin codificar valores directamente al c\u00f3digo fuente. Este enfoque mejora la flexibilidad, portabilidad y seguridad de las aplicaciones.</p> <p>En Java, acceder a las variables de entorno es sencillo gracias a la clase <code>System</code>, que proporciona m\u00e9todos para obtener las variables de entorno. Esta capacidad es especialmente \u00fatil para:</p> <ul> <li>Configurar par\u00e1metros de la aplicaci\u00f3n tales como URL de bases de datos, claves de API y rutas de archivos.</li> <li>Gestionar configuraciones espec\u00edficas del entorno sin alterar el c\u00f3digo fuente.</li> <li>Mantener informaci\u00f3n sensible, tales como contrase\u00f1as y tokens, fuera del c\u00f3digo fuente.</li> </ul> <p>Entendiendo c\u00f3mo utilizar de forma efectiva las variables de entorno en Java, los desarrolladores pueden crear aplicaciones m\u00e1s adaptables y seguras.</p>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#532-obtener-variables-de-entorno","title":"5.3.2. Obtener variables de entorno","text":"<p>Para acceder a las variables de entorno en Java, puede utilizar el m\u00e9todo <code>System.getenv()</code>. Este m\u00e9todo est\u00e1 sobrecargado y puede ser:</p> <ul> <li><code>System.getenv()</code> \u2192 devuelve un objeto <code>Map</code> que contiene todas las variables de entorno y sus valores correspondientes.</li> <li><code>System.getenv(String)</code> \u2192 devuelve una <code>String</code> con el valor de la variable de entorno espec\u00edfica o null si no existe.</li> </ul> <p>C\u00f3mo recuperar las variables de entorno en Java:</p> <pre><code>Map&lt;String, String&gt; env = System.getenv(); \n\n// Acceder a una variable de entorno espec\u00edfica \nString value = env.get(\"NOMBRE_VARIABLE\"); \n\n// Imprimir todas las variables de entorno \nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) { \nSystem.out.println(entry.getKey() + \" = \" + entry.getValue()); \n} \n</code></pre> <p>Tenga en cuenta que: </p> <ul> <li>La clase Map devuelve una colecci\u00f3n de entradas con parejas clave-valor. </li> <li>Las variables de entornorn distinguen entre may\u00fasculas y min\u00fasculas, as\u00ed que aseg\u00farese de utilizar las may\u00fasculas de forma correcta al acceder a ellas.</li> </ul>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#533-la-alternativa-dot-env","title":"5.3.3. La alternativa <code>dot-env</code>","text":"<p>Almacenar la configuraci\u00f3n en el entorno es uno de los principios de una aplicaci\u00f3n de doce factores. Cualquier cosa que pueda cambiar entre los entornos de despliegue, como los recursos de las bases de datos o las credenciales de los servicios externos, debe extraerse del c\u00f3digo y almacenarse en variables de entorno.</p> <p>Pero no siempre es pr\u00e1ctico establecer variables de entorno en m\u00e1quinas de desarrollo o servidores de integraci\u00f3n continua en los que se ejecutan varios proyectos. <code>Dotenv</code> carga las variables de un archivo <code>.env</code> en el entorno cuando se inicia.</p> <p>Desafortunadamente, Java no admite de forma nativa la carga de archivos <code>.env</code>, pero puede utilizar librer\u00edas externas para conseguir esta tarea. Una de las librer\u00edas populares para este prop\u00f3sito es <code>dotenv-java</code>. Esta librer\u00eda le permite cargar f\u00e1cilmente las variables de entorno de un archivo .env en su aplicaci\u00f3n Java. https://github.com/cdimascio/dotenv-java</p> <p>A\u00f1ada la dependencia</p> <p>Primero, debe a\u00f1adir la librer\u00eda <code>dotenv-java</code> a su proyecto. Si utiliza Maven, a\u00f1ada la siguiente dependencia al archivo pom.xml:</p> <pre><code>&lt;dependency&gt; \n&lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt; \n&lt;artifactId&gt;java-dotenv&lt;/artifactId&gt; \n&lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si utiliza Gradle, a\u00f1ada lo siguiente al archivo build.gradle:</p> <pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Cree el archivo <code>.env</code></p> <p>El archivo .env es como un archivo de configuraci\u00f3n. Puede almacenarlo en la ruta ra\u00edz de su aplicaci\u00f3n</p> <pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Cargue la configuraci\u00f3n</p> <pre><code>importe io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main { \npublic static void main(String[] args) { \n// Load the .env file \nDotenv dotenv = Dotenv.load(); \n\n// Retrieve environment variables \nString databaseUrl = dotenv.get(\"DATABASE_URL\"); \nString databaseUser = dotenv.get(\"DATABASE_USER\"); \nString databasePassword = dotenv.get(\"DATABASE_PASSWORD\"); \n\n// Print the values \nSystem.out.println(\"Database URL: \" + databaseUrl); \nSystem.out.println(\"Database User: \" + databaseUser); \nSystem.out.println(\"Database Password: \" + databasePassword); \n\n// Use the variables as needed \n// For example, establish a database connection using these variables \n}\n}\n</code></pre> <p>Atenci\u00f3n</p> <p>Tenga en cuenta que con la librer\u00eda java dotenv, utilizar\u00e1 <code>dotenv.get()</code> en lugar del m\u00e9todo <code>System.getenv()</code>, ya que est\u00e1 accediendo a un archivo local.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/","title":"Ejercicios sistema de archivos","text":""},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#ls-la","title":"<code>ls -la</code>","text":"<p>En este ejercicio, implementaremos una versi\u00f3n optimizada del programa <code>ls</code>. Listar\u00e1 un directorio en un modo de vista espec\u00edfico. Tanto el directorio como la vista se indicar\u00e1n al iniciar el programa.</p> <p>El modo de vista puede ser lista, columnas o tabla:</p> <ul> <li>Lista \u2192 Los nombres de los archivos se muestran uno encima del otro. </li> <li>Columnas \u2192 Igual que una lista, pero en varias columnas.</li> <li>Tabla \u2192 Se mostrar\u00e1 la informaci\u00f3n del archivo, con este patr\u00f3n: <code>DFRWH name size mod_data</code>:</li> <li><code>D</code> \u2192 es un directorio.</li> <li><code>F</code> \u2192 es un archivo.</li> <li><code>R</code> \u2192 podemos leer el archivo.</li> <li><code>W</code> \u2192 podemos escribir el archivo.</li> <li><code>H</code> \u2192 el archivo est\u00e1 oculto.</li> </ul>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#envio","title":"Env\u00edo","text":"<p>Un solo archivo <code>.java</code> con el programa. Para facilitarte la tarea, aqu\u00ed tienes c\u00f3digo para formatear una lista de cadenas en columnas. Se debe inicializar <code>MAX_FILES_BY_COLUMN = 4</code>.</p> <pre><code>public static void ListaColumnas(String[] filenames){\nint columnas = (filenames.length / MAX_FILES_BY_COLUMN)+1; String[][] salida = new String[MAX_FILES_BY_COLUMN][columnas];\nfor (int i=0;i&lt;filenames.length;i++){\nsalida[i % MAX_FILES_BY_COLUMN][i / MAX_FILES_BY_COLUMN]=\nfilenames[i];\n}\n//bucle para mostrar salida ls\nfor (int i=0;i&lt;MAX_FILES_BY_COLUMN;i++){\nfor (int j=0; j&lt;columnas;j++)\nSystem.out.print(salida[i][j] + \" - \");\nSystem.out.println(\" /n\");\n}\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-ocultos","title":"Archivos ocultos","text":"<p>Escribe un programa Java que encuentre todos los archivos ocultos de un directorio y sus subdirectorios recursivamente.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivo-mas-grande","title":"Archivo m\u00e1s grande","text":"<p>Escribe un programa Java para encontrar el archivo m\u00e1s grande de un conjunto de archivos en un directorio.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-de-texto","title":"Archivos de texto","text":""},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#cuantas-vocales","title":"\u00bfCu\u00e1ntas vocales?","text":"<p>Escribe un programa que reciba el nombre de un archivo de texto y una vocal. El programa mostrar\u00e1 el n\u00famero de veces que aparece esa vocal en el archivo.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#tail-y-head","title":"<code>tail</code> y <code>head</code>","text":"<p>Escribe tu propia versi\u00f3n de tail y head en las utilidades GNU. Puedes encontrar informaci\u00f3n en:</p> <ul> <li>tail</li> <li>head</li> </ul> <p>Nota</p> <p>Recuerda que estos programas muestran las \u00faltimas y las primeras diez l\u00edneas por defecto. Si quieres modificarlo, puedes usar <code>-nX</code>, donde X es el n\u00famero de l\u00edneas que quieres mostrar.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-binarios","title":"Archivos binarios","text":""},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#calcular-el-tamano-de-un-archivo-de-imagen-hard","title":"Calcular el tama\u00f1o de un archivo de imagen (HARD)","text":"<p>Seg\u00fan la especificaci\u00f3n de im\u00e1genes bmp o png, como se puede ver:</p> <ul> <li>Especificaci\u00f3n BMP</li> <li>Especificaci\u00f3n PNG</li> </ul> <p>Escribir un programa que reciba el nombre de un archivo png o bmp y devuelva el ancho y el alto de la imagen.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-csv","title":"Archivos CSV","text":"<p>Crear una funci\u00f3n para mostrar un archivo CSV, seg\u00fan los siguientes requisitos:</p> <ul> <li>Debemos indicar a la funci\u00f3n el car\u00e1cter separador.</li> <li>Debemos indicar a la funci\u00f3n si el CSV tiene una l\u00ednea de encabezado o no.</li> <li>(Mejora) La funci\u00f3n debe calcular el tama\u00f1o m\u00e1ximo de columna para cada l\u00ednea y mostrar cada columna con el tama\u00f1o calculado previamente, como MySQL muestra sus tablas.</li> </ul> <p>En la plataforma encontrar\u00e1s archivos CSV con los nombres de los jugadores de la MLB, pero puedes elegir el archivo que prefieras.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-xml","title":"Archivos XML","text":"<p>En la plataforma encontrar\u00e1s un archivo llamado <code>monaco2023.xml</code> con mucha informaci\u00f3n sobre la carrera del campeonato de F1 2023 en M\u00f3naco. Adem\u00e1s de otra informaci\u00f3n, encontramos:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;granPremio&gt;\n    &lt;nombre&gt;Gran Premio de M\u00f3naco&lt;/nombre&gt;\n    &lt;a\u00f1o&gt;2023&lt;/a\u00f1o&gt;\n    &lt;fecha&gt;2023-05-28&lt;/fecha&gt;\n    &lt;circuito&gt;\n        &lt;nombre&gt;Circuito de M\u00f3naco&lt;/nombre&gt;\n        &lt;ubicacion&gt;Montecarlo, M\u00f3naco&lt;/ubicacion&gt;\n        &lt;longitud&gt;3.337 km&lt;/longitud&gt;\n        &lt;vueltas&gt;78&lt;/vueltas&gt;\n        &lt;distanciaTotal&gt;260.286 km&lt;/distanciaTotal&gt;\n        &lt;recordVuelta&gt;1:12.909 (Lewis Hamilton, 2021)&lt;/recordVuelta&gt;\n    &lt;/circuito&gt;\n\n    &lt;clasificacion&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Max Verstappen&lt;/nombre&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.365&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Fernando Alonso&lt;/nombre&gt;\n            &lt;equipo&gt;Aston Martin&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.449&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Esteban Ocon&lt;/nombre&gt;\n            &lt;equipo&gt;Alpine&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.553&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;4&lt;/posicion&gt;\n            &lt;nombre&gt;Carlos Sainz&lt;/nombre&gt;\n            &lt;equipo&gt;Ferrari&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.630&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;5&lt;/posicion&gt;\n            &lt;nombre&gt;Lewis Hamilton&lt;/nombre&gt;\n            &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.725&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n    &lt;/clasificacion&gt;\n\n    &lt;carrera&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Max Verstappen&lt;/nombre&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;1:48:51.980&lt;/tiempo&gt;\n            &lt;puntos&gt;25&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Fernando Alonso&lt;/nombre&gt;\n            &lt;equipo&gt;Aston Martin&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+27.921&lt;/tiempo&gt;\n            &lt;puntos&gt;18&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Esteban Ocon&lt;/nombre&gt;\n            &lt;equipo&gt;Alpine&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+36.990&lt;/tiempo&gt;\n            &lt;puntos&gt;15&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;4&lt;/posicion&gt;\n            &lt;nombre&gt;Lewis Hamilton&lt;/nombre&gt;\n            &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+39.062&lt;/tiempo&gt;\n            &lt;puntos&gt;12&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;5&lt;/posicion&gt;\n            &lt;nombre&gt;George Russell&lt;/nombre&gt;\n            &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+56.284&lt;/tiempo&gt;\n            &lt;puntos&gt;10&lt;/puntos&gt;\n        &lt;/resultado&gt;\n    &lt;/carrera&gt;\n\n    &lt;vueltaRapida&gt;\n        &lt;piloto&gt;Lewis Hamilton&lt;/piloto&gt;\n        &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n        &lt;tiempo&gt;1:15.650&lt;/tiempo&gt;\n        &lt;vuelta&gt;33&lt;/vuelta&gt;\n    &lt;/vueltaRapida&gt;\n\n    &lt;abandonos&gt;\n        &lt;abandono&gt;\n            &lt;piloto&gt;Charles Leclerc&lt;/piloto&gt;\n            &lt;equipo&gt;Ferrari&lt;/equipo&gt;\n            &lt;vuelta&gt;53&lt;/vuelta&gt;\n            &lt;causa&gt;Da\u00f1os por colisi\u00f3n&lt;/causa&gt;\n        &lt;/abandono&gt;\n        &lt;abandono&gt;\n            &lt;piloto&gt;Nyck de Vries&lt;/piloto&gt;\n            &lt;equipo&gt;AlphaTauri&lt;/equipo&gt;\n            &lt;vuelta&gt;41&lt;/vuelta&gt;\n            &lt;causa&gt;Problemas mec\u00e1nicos&lt;/causa&gt;\n        &lt;/abandono&gt;\n    &lt;/abandonos&gt;\n\n    &lt;clasificacionMundialPilotos&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Max Verstappen&lt;/nombre&gt;\n            &lt;puntos&gt;144&lt;/puntos&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Sergio P\u00e9rez&lt;/nombre&gt;\n            &lt;puntos&gt;105&lt;/puntos&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Fernando Alonso&lt;/nombre&gt;\n            &lt;puntos&gt;93&lt;/puntos&gt;\n            &lt;equipo&gt;Aston Martin&lt;/equipo&gt;\n        &lt;/piloto&gt;\n    &lt;/clasificacionMundialPilotos&gt;\n\n    &lt;clasificacionMundialConstructores&gt;\n        &lt;equipo&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Red Bull Racing&lt;/nombre&gt;\n            &lt;puntos&gt;249&lt;/puntos&gt;\n        &lt;/equipo&gt;\n        &lt;equipo&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Aston Martin&lt;/nombre&gt;\n            &lt;puntos&gt;120&lt;/puntos&gt;\n        &lt;/equipo&gt;\n        &lt;equipo&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Mercedes&lt;/nombre&gt;\n            &lt;puntos&gt;119&lt;/puntos&gt;\n        &lt;/equipo&gt;\n    &lt;/clasificacionMundialConstructores&gt;\n\n    &lt;clima&gt;\n        &lt;temperaturaAmbiente&gt;24\u00b0C&lt;/temperaturaAmbiente&gt;\n        &lt;temperaturaPista&gt;42\u00b0C&lt;/temperaturaPista&gt;\n        &lt;humedad&gt;65%&lt;/humedad&gt;\n        &lt;condiciones&gt;Soleado&lt;/condiciones&gt;\n    &lt;/clima&gt;\n\n    &lt;curiosidades&gt;\n        &lt;curiosidad&gt;Fernando Alonso consigui\u00f3 su primer podio en M\u00f3naco desde 2010&lt;/curiosidad&gt;\n        &lt;curiosidad&gt;Esteban Ocon logr\u00f3 su segundo podio en la F\u00f3rmula 1&lt;/curiosidad&gt;\n        &lt;curiosidad&gt;Red Bull Racing extendi\u00f3 su racha de victorias a 6 carreras&lt;/curiosidad&gt;\n        &lt;curiosidad&gt;Primera vez que Alpine y Aston Martin comparten podio&lt;/curiosidad&gt;\n    &lt;/curiosidades&gt;\n&lt;/granPremio&gt;\n</code></pre> <p>Dentro de <code>resultado</code>, en <code>carrera</code> encontraremos como posicion (atributo <code>posicion</code>) que determinar\u00e1 la posici\u00f3n en la que acab\u00f3 en la carrera. Adem\u00e1s, encontraremos los siguientes elementos:</p> <ul> <li>nombre: nombre del piloto.</li> <li>equipo: informaci\u00f3n sobre la marca del coche.</li> <li>vueltas: vueltas completadas.</li> <li>tiempo: tiempo en completar la carrera.</li> <li>puntos: puntos obtenidos por el piloto.</li> </ul> <p>En la plataforma encontrar\u00e1s:</p> <ul> <li>Clase Carrera: Implementaci\u00f3n completa, que necesita la parte del controlador del XML para crear un objeto Carrera.</li> </ul> <pre><code>    private int posicion;\n    private String nombre;\n    private String equipo;\n    private int vueltas;\n    private String tiempo;\n    private int puntos;\n</code></pre> <ul> <li> <p>Clase Competicion: Esta no tendr\u00e1 constructor, constructor por defecto. Para esta se deber\u00e1 implementar lo siguiente:</p> <ul> <li><code>public ArrayList&lt;Carrera&gt; cargaResultadosXML(String nomXML)</code>, que recibe el nombre del archivo XML y carga todos los resultados. </li> <li><code>public void saveAsCSV(String nombreFichero, ArrayList&lt;Carrera&gt; losResultados)</code>, que guardar\u00e1 en un archivo de texto csv los resultados cargados previamente.</li> </ul> </li> <li> <p>La clase del programa principal ya se proporciona implementada.</p> </li> </ul>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-json","title":"Archivos JSON","text":"<p>En la plataforma encontrar\u00e1s un archivo llamado <code>SW.json</code>. Este recupera informaci\u00f3n sobre los personajes de la famosa saga. Escribe un programa para obtener:</p> <ul> <li>Personajes que no condujeron ning\u00fan veh\u00edculo.</li> <li>Lista de personajes, ordenados por n\u00famero de pel\u00edculas en las que aparecen.</li> <li>Crea un archivo XML como este, con un breve resumen:</li> </ul> <pre><code>&lt;character films=\"4\" vehicle=\"0\"&gt;\n&lt;name&gt;Luke Skywalker&lt;/name&gt;\n&lt;mass&gt;77&lt;/mass&gt;\n&lt;url&gt;https://swapi.dev/api/people/1/&lt;/url&gt;\n&lt;/character&gt;\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/","title":"1. Desfase objeto-relacional","text":"<p>Los Sistemas de Gesti\u00f3n de Bases de Datos (SGBD) se basan principalmente en el modelo Entidad-Relaci\u00f3n (E/R), donde la informaci\u00f3n se almacena en varias tablas relacionadas entre s\u00ed. Es una tecnolog\u00eda sencilla y eficiente, que ha resistido al paso de los a\u00f1os y que todav\u00eda es el modelo utilizado por la mayor\u00eda de bases de datos y SGBD actualmente. Pese a su \u00e9xito, el modelo tiene algunas limitaciones como la representaci\u00f3n de informaci\u00f3n mal estructurada o compleja.</p> <p>Los modelos conceptuales nos ayudan a moldear una realidad compleja y se basan en un proceso de abstracci\u00f3n de la realidad. Cada modelo tiene una forma de capturar esta realidad, pero todos ellos est\u00e1n m\u00e1s cercanos a la mentalidad humana que a la memoria de un ordenador.</p> <p>Cuando modelizamos una base de datos, utilizamos el modelo conceptual de Entidad-Relaci\u00f3n y posteriormente realizamos un proceso de transformaci\u00f3n en tablas y normalizaci\u00f3n de este modelo para obtener un modelo de datos relacional.</p> <p>En el caso de la programaci\u00f3n orientada a objetos, intentamos representar la realidad mediante objetos y las relaciones entre ellos. \u00c9ste es otro tipo de modelo conceptual, pero que tiene como objetivo representar la misma realidad que el modelo relacional.</p> <p>As\u00ed pues, tenemos dos aproximaciones distintas para representar la realidad de un problema: el Modelo Relacional de la base de datos y el modelo Orientado a Objetos de nuestras aplicaciones.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#11-representacion-de-la-informacion-con-el-modelo-relacional","title":"1.1. Representaci\u00f3n de la informaci\u00f3n con el modelo relacional","text":"<p>El modelo relacional se basa en tablas y la relaci\u00f3n entre ellas:</p> <ul> <li>Cada tabla tiene tantas columnas como atributos queremos representar y tantas filas como registros o elementos de ese tipo contiene.</li> <li>Las tablas tienen una clave primaria, que identifica cada uno de los registros, y puede estar formada por uno o m\u00e1s atributos.</li> <li>La relaci\u00f3n entre tablas se representa mediante claves externas, que consisten en incluir en una tabla la clave primaria de otra tabla, como referencia a la misma. Cuando se elimina un registro de una tabla, cuya clave primaria es referenciada por otra, debe garantizarse que se mantiene la integridad referencial de la base de datos. Entonces, antes de esta eliminaci\u00f3n de una clave primaria, podemos: </li> <li>No permitir la eliminaci\u00f3n (NO ACTION), </li> <li>Realizar la eliminaci\u00f3n en cascada, eliminando tambi\u00e9n todos los registros que hac\u00edan referencia a la clave primaria del registro eliminado (CASCADE), </li> <li>Establecer a null (SET NULL), de modo que la clave externa que hac\u00eda referencia a la clave primaria de la otra tabla tome el valor de <code>NULL</code>.</li> <li>Los diferentes campos de las tablas tambi\u00e9n pueden tener ciertas restricciones asociadas, como: </li> <li>Restricci\u00f3n de valor no nulo, por lo que el campo no puede ser nulo en ning\u00fan caso, </li> <li>Restricci\u00f3n de unicidad en uno o varios campos, por lo que el valor debe ser \u00fanico en toda la tabla. </li> <li>Restricci\u00f3n de dominio, o lo que es lo mismo, puede tener un conjunto de valores posibles por defecto.</li> </ul> <p>Atenci\u00f3n</p> <p>Las claves primarias tienen ambas propiedades: valor no nulo y unicidad.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#111-ejemplo","title":"1.1.1. Ejemplo","text":"<p>Una base de datos para almacenar informaci\u00f3n sobre jugadores, juegos, etc. puede ser as\u00ed:</p> <p></p> <p>Implementada con el SGBD <code>MySQL</code>:</p> <pre><code>CREATE SCHEMA IF NOT EXISTS `BDJuegos` DEFAULT CHARACTER SET utf8 ;\nUSE `BDJuegos` ;\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`jugador` ( \n`id` INT NOT NULL, \n`nick` VARCHAR(45) NULL, \n`fechaRegistro` DATETIME NULL, \nPRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`Genero` ( \n`id` INT NOT NULL, \n`nombre` VARCHAR(45) NULL, \n`descripcion` VARCHAR(256) NULL, \nPRIMARY KEY (`id`))\nENGINE = InnoDB;\n\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`Juego` ( \n`id` INT NOT NULL, \n`nombre` VARCHAR(45) NULL, \n`descripcion` VARCHAR(256) NULL, \n`Genero_id` INT NOT NULL, \nPRIMARY KEY (`id`), \nINDEX `fk_Juego_Genero1_idx` (`Genero_id` ASC), \nCONSTRAINT `fk_Juego_Genero1` \nFOREIGN KEY (`Genero_id`) \nREFERENCES `BDJuegos`.`Genero` (`id`) \nON DELETE NO ACTION \nON UPDATE NO ACTION)\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`Puntuaciones` ( \n`jugador_id` INT NOT NULL, \n`Juego_id` INT NOT NULL, \n`puntuacion` INT NULL, \nPRIMARY KEY (`jugador_id`, `Juego_id`), \nINDEX `fk_jugador_has_Juego_Juego1_idx` (`Juego_id` ASC), \nINDEX `fk_jugador_has_Juego_jugador1_idx` (`jugador_id` ASC), \nCONSTRAINT `fk_jugador_has_Juego_jugador1` \nFOREIGN KEY (`jugador_id`) \nREFERENCES `BDJuegos`.`jugador` (`id`) \nON DELETE NO ACTION \nON UPDATE NO ACTION, \nCONSTRAINT `fk_jugador_has_Juego_Juego1` \nFOREIGN KEY (`Juego_id`) \nREFERENCES `BDJuegos`.`Juego` (`id`) \nON DELETE NO ACTION \nON UPDATE NO ACTION)\nENGINE = InnoDB;\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#12-representacion-de-la-informacion-con-el-modelo-orientado-a-objetos","title":"1.2. Representaci\u00f3n de la informaci\u00f3n con el modelo orientado a objetos","text":"<p>Como la entidad-relaci\u00f3n, el modelo orientado a objetos es un modelo de datos conceptual, pero que da importancia a la modelizaci\u00f3n de los objetos.</p> <p>Un objeto puede representar cualquier elemento concibetual: entidades, procesos, acciones... Un objeto no s\u00f3lo representa las caracter\u00edsticas o propiedades, sino que tambi\u00e9n se centra en los procesos que sufren. En t\u00e9rminos del modelo orientado a objetos, decimos que un objeto es datos m\u00e1s operaciones o comportamiento.</p> <p>En la unidad introductoria ya revisamos la programaci\u00f3n orientada a objetos, as\u00ed que nos limitaremos a una breve revisi\u00f3n de los principales conceptos:</p> <ul> <li>Un objeto es una entidad con ciertas propiedades y cierto comportamiento.</li> <li>En t\u00e9rminos de POO, las propiedades se conocen como atributos, y el conjunto de sus valores determina el estado del objeto en un momento dado.</li> <li>El comportamiento est\u00e1 determinado por una serie de funciones y procedimientos que llamamos m\u00e9todos, y que modifican el estado del objeto.</li> <li>Un objeto tambi\u00e9n tendr\u00e1 un nombre con el que se identifica.</li> <li>Una clase es una abstracci\u00f3n de un conjunto de objetos, y un objeto debe pertenecer necesariamente a alguna clase.</li> <li>Las clases definen los atributos y m\u00e9todos que los objetos de esa clase tendr\u00e1n.</li> <li>Un objeto se dice que es una instancia de una clase.</li> </ul> <p>El mismo ejemplo que hemos representado recientemente, con una representaci\u00f3n orientada a objetos, podr\u00eda ser:</p> <p></p> <p>Como podemos ver, tiene una estructura similar, a la que tambi\u00e9n hemos a\u00f1adido algunos m\u00e9todos como getters y setters. Adem\u00e1s, las distintas clases no tienen un atributo identificador, puesto que cada objeto se identifica a s\u00ed mismo. Aqu\u00ed tenemos una peque\u00f1a aproximaci\u00f3n de c\u00f3mo implementar\u00edamos esta jerarqu\u00eda en Java.</p> <p>La clase <code>Genere</code> es una clase POJO, que s\u00f3lo almacena informaci\u00f3n (nombre y descripci\u00f3n del tipo de juego) e implementa getters y setters.</p> <pre><code>package org.dam;\n\npublic class Genero {\n    protected String nombre;\n    protected String descripcion;\n\n    public Genero(String nombre, String descripcion) {\n        this.nombre = nombre;\n        this.descripcion = descripcion;\n    }\n\n    public String getNombre() {return nombre;}\n    public void setNombre(String nombre) {this.nombre = nombre;}\n\n    public String getDescripcion() {return descripcion;}\n    public void setDescripcion(String descripcion) {\n        this.descripcion = descripcion;\n    }\n}\n</code></pre> <p>La clase <code>Juego</code> almacena el nombre, la descripci\u00f3n y el g\u00e9nero del juego. A diferencia del modelo relacional, donde lo que se almacena ser\u00eda una clave externa al g\u00e9nero, ya que aqu\u00ed no tenemos claves externas, almacenamos el propio objeto (la referencia).</p> <pre><code>package org.dam;\n\npublic class Juego {\n    protected String nombre;\n    protected String descripcion;\n    protected Genero genero;\n\n    public Juego(String nombre, String descripcion, Genero genero) {\n        this.nombre = nombre;\n        this.descripcion = descripcion;\n        this.genero = genero;\n\n    }\n\n    public String getNombre() {return this.nombre;}\n    public void setNombre(String nombre) {this.nombre = nombre;}\n\n    public String getDescripcion() {return this.descripcion;}\n    public void setDescripcion(String descripcion) {\n        this.descripcion= descripcion;\n    }\n\n    public Genero getGenero() {return this.genero;}\n\n    public void setGenero(Genero genero) {this.genero = genero;}\n}\n</code></pre> <p>La clase <code>Puntuaciones</code> presenta la relaci\u00f3n entre <code>Jugador</code> y <code>Juego</code> (cuando un jugador juega a un juego) y almacena los puntos y una referencia al juego.</p> <pre><code>package org.dam;\n\npublic class Puntuaciones {\n    private int puntuacion;\n    private Juego juego;\n\n    public Puntuaciones(int puntuacion, Juego juego) {\n        this.puntuacion = puntuacion;\n        this.juego = juego;\n    }\n\n    public int getPuntuacion() {return puntuacion;}\n    public void setPuntuacion(int puntuacion) {\n        this.puntuacion = puntuacion;\n    }\n\n    public Juego getJuego() {return juego;}\n\n    public void setJuego(Juego juego) {this.juego = juego;}\n}\n</code></pre> <p>Y finalmente, la clase <code>Jugador</code> almacena el apodo y la fecha de registro para cada jugador, y despu\u00e9s, un array con todos los juegos que el jugador ha jugado:</p> <pre><code>package org.dam;\n\nimport java.util.Date;\nimport java.util.Set;\n\npublic class Jugador {\n\n    private String nick;\n    private Date fechaRegistro;\n    private Set&lt;Puntuaciones&gt; puntuaciones;\n\n    public Jugador(String nick, Date fechaRegistro) {\n        this.nick = nick;\n        this.fechaRegistro = fechaRegistro;\n    }\n\n    public String getNick() {return nick;}\n    public void setNick(String nick) {this.nick = nick;}\n\n    public Date getFechaRegistro() {return fechaRegistro;}\n    public void setFechaRegistro(Date fechaRegistro) {\n        this.fechaRegistro = fechaRegistro;\n    }\n\n    public Set getPuntuaciones() {return this.puntuaciones;}\n    public void setPuntuacion(Juego juego, int puntuacion) {\n        Puntuaciones registro = new Puntuaciones(puntuacion, juego);\n        this.puntuaciones.add(registro);\n    }\n}\n</code></pre> <p>La interfaz <code>Set</code> y la clase <code>HashSet</code></p> <p><code>Set</code> es una interfaz del paquete <code>java.util</code> que trata una colecci\u00f3n o conjunto de elementos sin desorden y sin duplicados. </p> <p>Por otra parte, <code>HashSet</code> es una clase que implementa la interfaz <code>Set</code> y que se basa en una tabla de hash, una estructura de datos que permite localizar objetos bas\u00e1ndose en una clave que indica la posici\u00f3n en la tabla, permitiendoel acceso directo al elemento, lo que les hace ideales para b\u00fasquedas, inserciones y eliminaciones.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#13-modelo-relacional-vs-modelo-orientado-a-objetos","title":"1.3. Modelo Relacional vs Modelo Orientado a Objetos","text":"<p>Conceptualmente, el modelo orientado a objetos es un modelo din\u00e1mico, que se centra en los objetos y en los procesos que \u00e9stos experimentan, pero que no tiene en cuenta, desde el principio, su persistencia. Debemos ser capaces, por tanto, de guardar los estados de los objetos de forma permanente y cargarlos cuando la aplicaci\u00f3n los necesite, as\u00ed como mantener la consistencia entre estos datos almacenados y los objetos que los representan en la aplicaci\u00f3n.</p> <p>Una forma de ofrecer esta persistencia a los objetos ser\u00eda utilizar un SGBD Relacional, pero nos encontraremos con algunas complicaciones. La primera, desde un punto de vista conceptual, es que el modelo Entidad-Relaci\u00f3n se centra en los datos, mientras que el modelo orientado a objetos se centra en los objetos, entendidos como grupos de datos y operaciones realizadas sobre ellos.</p> <p>Otra diferencia, bastante importante, es la vinculaci\u00f3n de los elementos entre un modelo y otro. Por un lado, el modelo relacional a\u00f1ade informaci\u00f3n adicional a las tablas en forma de clave externa, mientras que en el modelo orientado a objetos no necesitamos este dato externo, sino que la vinculaci\u00f3n entre objetos se realiza a trav\u00e9s de referencias entre ellos. Un objeto, por ejemplo, no necesitar\u00e1 una clave primaria, ya que el objeto se identifica por s\u00ed mismo.</p> <p>Como hemos visto en el ejemplo de las secciones anteriores, las tablas en el modelo relacional ten\u00edan una clave primaria para identificar los objetos y claves externas para expresar las relaciones, mientras que en el modelo orientado a objetos \u00e9stas desaparecen, expresando las relaciones entre objetos mediante referencias. Adem\u00e1s, la forma en que se expresan estas relaciones tambi\u00e9n es diferente. En el modelo relacional, por ejemplo, el registro de puntuaciones es una tabla que enlaza la mesa de jugadores con la mesa de juegos y a\u00f1ade la puntuaci\u00f3n del jugador en el juego. Por otra parte, en la implementaci\u00f3n en Java que hemos hecho tenemos objetos de tipo <code>Registro</code> que almacenan una puntuaci\u00f3n y una referencia al juego, pero es la clase Jugador la que mantiene el conjunto de registros de sus puntuaciones.</p> <p>Por otra parte, al manipular los datos, hay que tener en cuenta que el modelo relacional dispone de lenguajes (principalmente SQL) dise\u00f1ados exclusivamente para este prop\u00f3sito, mientras que en un lenguaje orientado a objetos funciona de forma diferente, por lo que ser\u00e1 necesario incorporar mecanismos que permitan realizar estas consultas desde el lenguaje de programaci\u00f3n. Adem\u00e1s, cuando obtenemos los resultados de la consulta, tambi\u00e9n encontramos otro problema, y es la conversi\u00f3n de los resultados. Cuando se realiza una consulta a una base de datos, siempre se devuelve un resultado en forma de tabla, por lo que ser\u00e1 necesario transformar estos resultados en estados de los objetos de la aplicaci\u00f3n.</p> <p>Todas estas diferencias implican lo que se conoce como desfase relacional-objeto, y que nos obligar\u00e1 a realizar determinadas conversiones entre objetos y tablas cuando queremos guardar la informaci\u00f3n en un SGBD. En esta unidad y en las siguientes, veremos c\u00f3mo superar este retraso desde distintos enfoques.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/","title":"2. Conectores","text":""},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#21-la-arquitectura-cliente-servidor-en-sgbd","title":"2.1. La arquitectura cliente-servidor en SGBD","text":"<p>Una vez conocemos el retraso relacional-objeto, centr\u00e9monos en c\u00f3mo acceder a bases de datos relacionales desde los lenguajes de programaci\u00f3n. Los SGBD, se popularizaron en los a\u00f1os 80, siendo los m\u00e1s extendidos actualmente. Salvo algunas excepciones, funcionan siguiendo una arquitectura cliente-servidor, de modo que tenemos un servidor donde ejecuta el SGBD y varios clientes que se conectan al servidor y hacen las peticiones correspondientes.</p> <p>Los SGBD ofrec\u00edan sus propios lenguajes de programaci\u00f3n, pero estaban muy ligados a ellos y el mantenimiento de la aplicaci\u00f3n era muy caro. Por este motivo, la tendencia era desacoplar (separar) a los SGBD del lenguaje de programaci\u00f3n, y hacer uso de est\u00e1ndares de conexi\u00f3n entre ellos.</p> <p>Gracias a la arquitectura cliente-servidor, los SGBD pudieron separar los datos por un lado y los programas para acceder por otros. Esta versatilidad ten\u00eda un peque\u00f1o inconveniente, y es que era necesario desarrollar por un lado el servidor, pero por otro, tambi\u00e9n la parte del cliente para poder conectarse a los servidores. Estas conexiones entre clientes y servidores requerir\u00e1n de protocolos y lenguajes espec\u00edficos. Aqu\u00ed nace el concepto de middleware, entendido como una capa intermedia de persistencia, formada por bibliotecas, lenguajes y protocolos ubicados en el cliente y en el servidor y que permiten conectar la base de datos con las aplicaciones.</p> <p>Aunque inicialmente cada SGBD implement\u00f3 soluciones espec\u00edficas, se impusieron est\u00e1ndares, entre ellos el lenguaje de consulta SQL (Structured Query Language), y que supuso un gran avance, ya que unific\u00f3 la manera de acceder a las bases de datos, aunque las aplicaciones continuaron requieren una API para hacer uso de SQL.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#22-protocolos-de-acceso-a-bases-de-datos","title":"2.2. Protocolos de acceso a bases de datos","text":"<p>Cuando hablamos de protocolos de acceso a bases de datos, nos encontramos con dos reglas principales de conexi\u00f3n:</p> <ul> <li>ODBC (Open Data Base Connectivity): \u00c9sta es una API (Application Program Interface) desarrollada por Microsoft para sistemas Windows que permite a\u00f1adir diferentes conectores a varias bases de datos relacionales basadas en SQL, de una manera sencilla y transparente. Utilizando ODBC, las aplicaciones pueden abrir conexiones en la base de datos, enviar consultas, actualizaciones y gestionar los resultados.</li> <li>JDBC (Java Database Connectivity), que define una API multiplataforma que los programas Java pueden utilizar para conectarse al SGBD.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#23-jdbc","title":"2.3. JDBC","text":"<p>Como hemos dicho, JDBC es una API de conexi\u00f3n a bases de datos espec\u00edfica de Java. Su modo de funcionamiento es el siguiente:</p> <ul> <li>Se ofrece una API, encapsulada en clases, que garantiza uniformidad en la forma en que las aplicaciones se conectan a la base de datos, independientemente del SGBD subyacente.</li> <li>Necesitaremos un controlador para cada base de datos a la que queremos conectarnos. Java no tiene ninguna librer\u00eda ODBC espec\u00edfica, pero, para no perder el potencial de estas conexiones, se han incorporado controladores especiales que act\u00faan como adaptadores entre JDBC y ODBC, por lo que es posible, a trav\u00e9s de este puente, conectar cualquier aplicaci\u00f3n Java con cualquier conexi\u00f3n ODBC. Actualmente, casi todos los SGBD tienen controladores JDBC, pero en caso de que no tenga conocimiento, puede utilizar este puente ODBC-JDBC.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#231-arquitectura-jdbc","title":"2.3.1. Arquitectura JDBC","text":"<p>La biblioteca est\u00e1ndar JDBC proporciona un conjunto de interfaces independientes de la implementaci\u00f3n. Los controladores de cada DBMS ser\u00e1n los encargados de su implementaci\u00f3n. Las aplicaciones, para acceder a la base de datos, tendr\u00e1n que utilizar las interfaces JDBC, de modo que la implementaci\u00f3n de cada DBMS sea completamente transparente para la aplicaci\u00f3n.</p> JDBC <p>Como podemos ver, las aplicaciones Java acceden a los distintos m\u00e9todos que API especifica como interfaces, pero son los controladores los que acceden a la base de datos.</p> <p>Hay que decir que las aplicaciones pueden utilizar varios controladores JDBC simult\u00e1neamente y acceder, por tanto, a m\u00faltiples bases de datos. La aplicaci\u00f3n especifica un controlador JDBC utilizando una URL (Universal Resource Locator) en el gestor de controladores, y \u00e9ste es el responsable de establecer correctamente las conexiones con las bases de datos a trav\u00e9s de los controladores. Los controladores pueden ser de distintos tipos:</p> <ul> <li>Tipo I o controladores de puente, caracterizados por hacer uso de tecnolog\u00eda externa a JDBC y actuar como adaptadores entre JDBC y la tecnolog\u00eda espec\u00edfica utilizada. Un ejemplo es el puente JDBC-ODBC.</li> <li>Tipo II o controladores con API parcialmente nativa, o controladores nativos. Est\u00e1n entrenados por un lado en Java y por otro hacen uso de librer\u00edas del sistema operativo. Su uso se debe a algunos SGBD que incorporan conectores propietarios que no siguen ning\u00fan est\u00e1ndar (normalmente pre-ODBC/JDBC).</li> <li>Tipo III o controladores Java a trav\u00e9s de protocolo de red, que son controladores desarrollados en Java que traducen las llamadases JDBC en un protocolo de red contra un servidor proxy. Es un sistema muy flexible, ya que los cambios en la implementaci\u00f3n de la base de datos no afectan a las aplicaciones.</li> <li>Tipo IV o 100% Java puras, tambi\u00e9n llamados protocolo nativos, y \u00e9stos son controladores escritos \u00edntegramente en Java. Las solicitudes al SGBD se realizan a trav\u00e9s del protocolo de red que utiliza el propio SGBD, por lo que no es necesario ning\u00fan c\u00f3digo nativo al cliente ni un servidor proxy. Es la alternativa que se ha acabado imponiendo, puesto que no requiere ning\u00fan tipo de instalaci\u00f3n.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#24-mysql-docker-workbench","title":"2.4. MySQL, Docker, Workbench","text":"<p>Este a\u00f1o utilizaremos MySQL como SGBD, por su amplia utilizaci\u00f3n en diversos contextos y por su simplicidad. Para utilizarlo, debes instalar <code>mysql-server</code> como servicio en tu sistema, como has estudiado en los \u00faltimos a\u00f1os.</p> <p>El servidor MySQL se puede instalar en tu ordenador, o puedes instalarlo en una m\u00e1quina virtual o configurarlo como contenedor Docker. Por tener un sistema m\u00e1s limpio, la opci\u00f3n recomendada es con contenedor Docker, ya que podr\u00e1s ejecutar varias versiones de MySQL sin interferencias entre ellas.</p> <p>Note</p> <p>Tiene una documentaci\u00f3n adicional sobre c\u00f3mo crear un contenedor MySQL en un documento llamado Docker para MySQL. As\u00ed pues, y con respecto al resto del documento, asumiremos que ya tiene la imagen de Docker de MySQL y un contenedor en ejecuci\u00f3n en el puerto <code>3308</code> (MySQL utiliza el puerto 3306 por defecto, pero en nuestro contenedor expondremos el servicio en el puerto 3308, en caso de que ya tenga un servidor MySQL 3 local).</p> <pre><code># Remember that to create the container (only fisrt time)\n\ndocker run --name mysql-srv \n-p 3308:3306 \n-e MYSQL_ROOT_PASSWORD=\"root\" \n-d mysql:latest\n\n# Se crea y start el container\n\n# To stop the container\ndocker stop mysql-srv\n\n# And to start the container ( AVOID TO run IT AGAIN !!!)\ndocker start mysql-srv\n</code></pre> <p>Y finalmente, pero no menos importante, evidentemente, puede utilizar una herramienta gr\u00e1fica para acceder a MySQL, como <code>mysql-workbench</code> o <code>dbeaver</code>. Debe configurar una conexi\u00f3n al puerto de Docker:</p> mysql-workbench <p>Espacio</p> <p>Revisa las notas de tu m\u00f3dulo de bases de datos sobre c\u00f3mo trabajar con Workbench: </p> <ul> <li>Carga y ejecuta scripts SQL </li> <li>Recupera la estructura de la base de datos </li> <li>Edita y crea SQL </li> <li>Edita y guarda datos</li> </ul> <p>Dispones del scrip Esquema BD Juegos para cargar los ejemplos de los apuntes</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/","title":"3. Conectando a bases de datos","text":""},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#31-controlador-jdbc-de-mysql","title":"3.1. Controlador JDBC de MySQL","text":"<p>Para crear programas Java utilizando el controlador de MySQL, necesitamos cargarlo en nuestro programa y previamente en nuestro entorno de desarrollo. C\u00f3mo utilizaremos <code>Maven</code> vamos a ver c\u00f3mo hacerlo:</p> <ol> <li>Debemos encontrar la versi\u00f3n del controlador de nuestro servidor JDBC, y podemos encontrarlo en el repositorio central de Maven https://mvnrepository.com.</li> <li>Buscamos <code>mysql jdbc</code>, y obtendremos como primer resultado MySQL Connector/J.</li> <li>Aseg\u00farese de seleccionar la versi\u00f3n correcta, y luego seleccione el gestor de paquetes (gradle, maven, etc.) y obtendr\u00e1:</li> </ol> <pre><code>&lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n    &lt;version&gt;9.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ol> <li>Cuando guarde o compile su proyecto, podr\u00e1 importar los controladores correctamente.</li> </ol> mysql-maven"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#32-url-de-conexion","title":"3.2. URL de conexi\u00f3n","text":"<p>Una vez haya importado el controlador, debe decirle a su programa Java c\u00f3mo conectarse a su base de datos y finalmente conectarse a su programa. Para esta tarea, debemos crear una <code>Connection</code> utilizando una URL especial llamada URL de conexi\u00f3n. Como otras URL, una URL de conexi\u00f3n puede contener:</p> <ul> <li>Protocolo \u2192  utilizaremos <code>jdbc</code>.</li> <li>SGBD \u2192  podr\u00edamos utilizar <code>mysql</code>, <code>postgres</code>, <code>sqlite</code>, <code>sqlserver</code> o cualquier SGBD con un conector JDBC.</li> <li>Direcci\u00f3n del servidor \u2192  podemos utilizar tanto un nombre completo como la direcci\u00f3n IP del servidor.</li> <li>[opcional]Port \u2192 el puerto donde el servidor est\u00e1 escuchando. Si no se utiliza ninguna, el controlador intentar\u00e1 conectarse al puerto predeterminado. Recuerde separar el puerto de la direcci\u00f3n con <code>:</code>.</li> <li>Otros par\u00e1metros, separ\u00e1ndolos con <code>?</code> al principio y con <code>&amp;</code> entre los par\u00e1metros. Por ejemplo: </li> <li>user=<code>usuario</code> </li> <li>pass=<code>contrase\u00f1a</code> </li> <li>useUnicode=<code>true</code> </li> <li>characterEncoding=<code>UTF-8</code></li> </ul> <p>Una muestra de URL de conexi\u00f3n puede ser:</p> <pre><code>String connectionUrl = \"jdbc:mysql://localhost:3308/Cycling?useUnicode=true&amp;characterEncoding=UTF-8&amp;user=root&amp;password=root\";\n</code></pre> <p>Una mejor opci\u00f3n ser\u00eda:</p> <pre><code>String server=\"localhost\";\nint puerto=3308;\nString user=\"root\";\nString pass=\"root\";\nString DBName=\"BDJuegos\";\nString connectionUrl = \"jdbc:mysql://\"+server+\":\"+puerto;\nconnectionUrl+=\"/\" + DBName;\nconnectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\nconnectionUrl+=\"&amp;user=\"+user;\nconnectionUrl+=\"&amp;password=\"+pass;\n</code></pre> <p>Atenci\u00f3n</p> <p>Tenga en cuenta que ambos ejemplos son c\u00f3digo hard-coded, ya que tiene los valores del servidor (usuario y contrase\u00f1a) escritos dentro de cadenas de texto. Es mejor opci\u00f3n almacenar estos valores dentro de variables o archivos de propiedades.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#33-clase-connection","title":"3.3. Clase <code>Connection</code>","text":"<p>En Java, la clase necesaria para gestionar el controlador es <code>java.sql.DriverManager</code>. Intenta cargar los controladores del sistema cuando lee la propiedad de los controladores JDBC, pero podemos indicar que se cargue utilizando la instrucci\u00f3n:</p> <pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>La clase que centralizar\u00e1 todas las operaciones con la base de datos es <code>java.sql.Connection</code>, y debemos obtenerla desde el <code>DriverManager</code> con cualquiera de los 3 m\u00e9todos est\u00e1ticos que tiene:</p> <ul> <li><code>static Connection getConnection(String url)</code> $\\rightarrow$ Devuelve una conexi\u00f3n, si es posible, a la base de datos con los par\u00e1metros especificados en la URL de conexi\u00f3n. Recuerde crear una URL de conexi\u00f3n a partir de la parte anterior.</li> <li><code>static Connection getConnection(String url, Properties info)</code> $\\rightarrow$ Devuelve una conexi\u00f3n, si es posible, a la base de datos, con algunos par\u00e1metros especificados en la URL y otros en un objeto de propiedades (<code>Properties</code> clase estudiada en la unidad 1). Veremos ejemplos m\u00e1s adelante.</li> <li><code>static Connection getConnection(String url, String user, String pass)</code> $\\rightarrow$ Devuelve una conexi\u00f3n, si es posible, a la base de datos con los par\u00e1metros especificados en la URL. Los datos de usuario y contrase\u00f1a se proporcionan en dos par\u00e1metros adicionales, por lo que no es necesario escribirlos en la URL de conexi\u00f3n.</li> </ul> <p>Una muestra inicial ser\u00e1:</p> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args)\n            throws ClassNotFoundException, SQLException {\n\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        String server = \"localhost\";\n        int puerto = 3308;\n        String user = \"root\";\n        String pass = \"root\";\n        String DBName = \"BDJuegos\";\n        String connectionUrl = \"jdbc:mysql://\" + server + \":\" + puerto;\n        connectionUrl += \"/\" + DBName;\n        connectionUrl += \"?useUnicode=true&amp;characterEncoding=UTF-8\";\n\n        Connection conn = DriverManager.getConnection(connectionUrl, user, pass);\n\n// if no excepto se catched, you connected to your DBMS\n    }\n}\n</code></pre> <p>Con el objeto <code>Connection</code> que tenemos ahora conectado, enviaremos nuestras consultas y pediremos informaci\u00f3n, como veremos m\u00e1s adelante.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#34-organizando-nuestra-conexion","title":"3.4. Organizando nuestra conexi\u00f3n","text":"<p>Nuestra aplicaci\u00f3n debe conectarse a una (o m\u00e1s) bases de datos. Podemos realizar muchas peticiones a estas base de datos, y si estamos implementando una aplicaci\u00f3n multithreaded, el n\u00famero de peticiones puede aumentar mucho. Por eso, debemos controlar d\u00f3nde y cu\u00e1ndo se crean y se cierran las conexiones. Una buena idea es crear una clase que encapsule todos estos procesos. El esqueleto de esta clase ser\u00eda el siguiente:</p> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class ConnexionBD {\n\n    private Connection laConexion = null;\n\n// write here access variables, like user, server or whatever\n\n    private void connect() {\n// do the connetion (look the sample).\n// Take care. private method. It will be called inside the class\n    }\n\n    // close connection, if it's opened\n    public void disConnect() throws SQLException {\n        if (laConexion != null) {\n            laConexion.close();\n        }\n    }\n\n    // returns the connection.\n// It will be create first time of after closed\n    public Connection getConexion(){\n        if (laConexion == null) {\n            this.connect();\n        }\n        return this.laConexion;\n    }\n}\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#341-ejercicio-resuelto","title":"3.4.1. Ejercicio resuelto","text":"<p>Crea un proyecto \u00fanico con dos clases. Una para conectarte a tu base de datos, como el \u00faltimo ejemplo, y una clase principal que se conecte y muestre si ha habido alg\u00fan error.</p> <p>La soluci\u00f3n del ejercicio est\u00e1 enlazada aqu\u00ed conexion.properties y ConexionDB.java</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/","title":"4. Clase <code>ResultSet</code>.","text":"<p>Ahora que estamos conectados a la base de datos, es hora de empezar a pedir informaci\u00f3n a DBMS. Esta informaci\u00f3n se proporcionar\u00e1 en forma de consultas (SQL) u otros m\u00e9todos, pero casi el 90% de las veces, como en el caso de las consultas SQL, la informaci\u00f3n devuelta se encuentra en un formato tabular. Los formatos tabulares son bien conocidos porque programas como MySQL Workbench o DBeaver muestran los datos de esta forma.</p> <p>En Java, la clase que permite trabajar con datos en formato tabular provenientes de bases de datos se llama <code>Resultset</code>. Un <code>Resultset</code> est\u00e1 compuesto por una tabla (filas y columnas) y un puntero en una fila, llamado cursor.</p> <p></p> <ol> <li>Cuando recuperamos datos de las bases de datos, la informaci\u00f3n se guarda en la tabla y el cursor apunta a una fila imaginaria vac\u00eda llamada <code>beforeFirst</code>.</li> <li><code>Resultset</code> contiene un m\u00e9todo especial llamado <code>next()</code>, que realiza dos acciones: </li> <li>Devuelve <code>true</code> si hay una fila de datos despu\u00e9s de la fila actual apuntada por el cursor y <code>false</code> de lo contrario. </li> <li>Avanza el cursor y apunta a la siguiente fila, s\u00f3lo si hab\u00eda una.</li> <li>Cuando el cursor de un <code>Resultset</code> devuelve <code>false</code>, significa que se han visitado todas las filas y ahora el cursor apunta a otra fila imaginaria llamada <code>afterLast</code>.</li> </ol> <p>Cuando el cursor apunta a una fila real, es cuando podemos recuperar los datos de las columnas de la fila actual. Podemos utilizar un m\u00e9todo especial y sobrecargado, de la siguiente forma:</p> <ul> <li><code>getXXX(int posici\u00f3nColumna)</code> \u2192  devuelve los datos, donde <code>XXX</code> es un tipo de datos (Int, Float, Double, String, etc.) de la posici\u00f3n de la columna, empezando por 1.</li> <li><code>getXXX(String nombreColumna)</code> \u2192  devuelve los datos, donde <code>XXX</code> es un tipo de datos (Int, Float, Double, String, etc.) de la columna con el nombre proporcionado.</li> </ul> <p>Peligro</p> <p>Tenga en cuenta: </p> <ul> <li>Las columnas comienzan en 1 en lugar de 0, a diferencia de los arrays. </li> <li>Si no conoce el tipo de datos de una columna, puede utilizar <code>getObject</code> y \u00e9ste devolver\u00e1 un <code>Object</code> gen\u00e9rico. </li> <li>Estos m\u00e9todos pueden generar una <code>SQLException</code> si el rango o el nombre de la columna est\u00e1 fuera de rango o no existe.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/#41-resulsetmetadata","title":"4.1. ResulSetMetaData","text":"<p>Los ResultSets de una consulta tambi\u00e9n tienen un conjunto de metadatos. Estos metadatos se pueden obtener utilizando <code>ResultSetMetaData</code>. Los m\u00e9todos m\u00e1s relevantes de esta clase son:</p> <ul> <li><code>int getColumnCount()</code> \u2192 Obtiene el n\u00famero de columnas en el ResultSet.</li> <li><code>String getColumnName(index)</code> \u2192  Obtiene el nombre de la columna indicada en el \u00edndice (recuerda que el primero es 1).</li> <li><code>String getColumnTypeName(index)</code> \u2192  Obtiene el tipo de la columna.</li> </ul> <p>ResulSetMetaData se obtiene de cada ResultSet generado previamente, con el m\u00e9todo <code>getMetaData()</code>.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/#42-algoritmo-resultset","title":"4.2. Algoritmo ResultSet","text":"<p>Independientemente del contenido de datos de tu ResultSet, la forma en que debemos trabajar es la siguiente:</p> <pre><code>// Connect to DB\nConnection conn = ...;\n\n// recover data\nResultSet rst=con...\n\n// while data available exists\nwhile (rst.next()){ \n//process the current row\n}\n</code></pre> <p>S\u00e9 consciente de que:</p> <ul> <li>Dentro del bucle while no es necesario llamar <code>next()</code> de nuevo. Se salta una fila de lo contrario.</li> <li>Cuando se han procesado las \u00faltimas filas, <code>next()</code> devuelve <code>false</code> y el bucle finaliza.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/#43-ejemplo","title":"4.3. Ejemplo","text":"<p>En este blog de c\u00f3digo, vamos a ver un ejemplo breve para ejecutar una consulta (<code>Select * from table</code>). Veremos otras consultas en las siguientes secciones.</p> <pre><code> try {\n            ConnexionDB laConexionDB = new ConnexionDB(\"BDJuegos\");\n\n            Connection con = laConexionDB.getConnexion();\n\n            DatabaseMetaData dbmd = con.getMetaData();\n\n            System.out.println(\"\\nDBMS information--------\" );\n            System.out.println(\"DBMS:\\t\" + dbmd.getDatabaseProductName());\n            System.out.println(\"DBMS:\\t\"+ dbmd.getDriverName());\n            System.out.println(\"DBMS:\\t\" + dbmd.getURL());\n            System.out.println(\"DBMS:\\t\" + dbmd.getUserName());\n\n            System.out.println(String.format(\"%-15s %-15s %-15s \", \"Database\", \"Table\", \"Type\"));\n            System.out.println(\"-------------------------------------------------------\");\n            ResultSet rsmd = dbmd.getTables(\"BDJuegos\", null, null, null);\n            while (rsmd.next()) {\n                System.out.println(String.format(\"%-15s %-15s %-15s\", rsmd.getString(1), rsmd.getString(3), rsmd.getString(4)));\n            }\n\n            rsmd.close();\n\n            String table = \"Genero\"; // we set the name of an existing table\n            ResultSet columnas = dbmd.getColumns(\"BDJuegos\", null, table, null);\n\n            System.out.println(String.format(\"%-25s %-15s %-15s \", \"Atributo/Claves\", \"Tipo\", \"\u00bfPuede ser nulo?\"));\n            while (columnas.next()) {\n                String columnName = columnas.getString(4);\n                String tipo = columnas.getString(6);\n                String nullable = columnas.getString(18);\n\n                System.out.println(String.format(\"%-25s %-15s %-15s\", columnName,tipo,nullable));\n            }\n            con.close();\n\n        } catch (SQLException ex) {\n            System.out.println(ex);\n        }   \n</code></pre> <p>La soluci\u00f3n del ejercicio est\u00e1 enlazada aqu\u00ed conexion.properties, ConexionDB.java y el Main.java</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/","title":"5. Metadata de la base de datos","text":"<p>Antes de recuperar datos, estudiaremos c\u00f3mo obtener informaci\u00f3n sobre la base de datos a la que estamos conectados. Los metadatos de una base de datos describen su estructura: las tablas que componen la base de datos, los campos que forman estas tablas, los tipos de estos campos, etc. Aunque normalmente conocemos esta estructura previamente, es posible que necesitemos informaci\u00f3n en alguna ocasi\u00f3n, por eso tenemos las interfaces <code>DatabaseMetaData</code> y <code>ResultSetMetaData</code>.</p> <p>La interfaz <code>DatabaseMetaData</code> nos proporciona informaci\u00f3n sobre las tablas y vistas de la base de datos, as\u00ed como su estructura. A continuaci\u00f3n tenemos algunos de los m\u00e9todos m\u00e1s relevantes de esta interfaz.</p> <ul> <li><code>String getDatabaseProductName()</code> \u2192  Obtiene el nombre de SGBD.</li> <li><code>String getDriverName()</code> \u2192  Obtiene el nombre del controlador JDBC que se est\u00e1 utilizando.</li> <li><code>String getURL()</code> \u2192  Obtiene la URL de la conexi\u00f3n.</li> <li><code>String getUserName()</code> \u2192  Obtiene el nombre del usuario conectado a la base de datos.</li> <li><code>ResultSet getTables(String catalog, String schema, String patternTableName, String[] type)</code> \u2192  Obtiene informaci\u00f3n de las tablas disponibles en el cat\u00e1logo indicado.</li> <li><code>ResultSet getColumns(String catalog, String schema, String patternNameTable, String patternColumnName)</code> \u2192  Obtiene informaci\u00f3n de los campos de la tabla especificada en el cat\u00e1logo y esquema indicados.</li> <li><code>ResultSet getPrimaryKeys(String catalog, String schema, String patternNameTable)</code> \u2192  Obtiene la lista de campos que forman la clave primaria.</li> <li><code>ResultSet getImportedKeys(String catalog, String schema, String patternNameTable)</code> \u2192  Obtiene una lista con las claves externas definidas en la tabla.</li> <li><code>ResultSet getExportedKeys(String catalog, String schema, String patternNameTable)</code> \u2192  Obtiene una lista con las claves externas que apuntan a esta tabla.</li> </ul> <p>Informaci\u00f3n</p> <p>En este punto, cabe se\u00f1alar que los t\u00e9rminos cat\u00e1logo y esquema tienden a confundirse. Seg\u00fan los est\u00e1ndares, un cat\u00e1logo contiene varios esquemas, con informaci\u00f3n detallada del sistema, desde la forma de almacenamiento interno hasta los esquemas conceptuales. En un cat\u00e1logo, parece que existe un esquema llamado INFORMATION_SCHEMA, con las vistas y dominios del esquema de informaci\u00f3n del sistema. </p> <p>En cualquier caso, la mayor\u00eda de los SGBD coinciden el cat\u00e1logo con el nombre de la base de datos. Adem\u00e1s, en esta consulta especificamos el nombre de la base de datos como cat\u00e1logo, mientras que si abrimos MySQLWorkbench, la base de datos se representa como un esquema. Puede encontrar m\u00e1s informaci\u00f3n al respecto en estos enlaces: </p> <ul> <li>https://stackoverflow.com/questions/7022755/whats-the-difference-between-a-catalog-and-a-schema-in-a-relational-database </li> <li>https://www.quora.com/What-is-the-difference-between-system-catalog-and-database-schemain-a-Database</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#51-ejercicio-resuelto","title":"5.1. Ejercicio resuelto","text":"<p>Vamos a crear un programa Java que muestre informaci\u00f3n interna de una base de datos <code>BDJuegos</code>, mediante <code>DataBaseMetaData</code>. Veremos el programa paso a paso.</p> <p>Info</p> <p>Puede ver toda la informaci\u00f3n del m\u00e9todo y c\u00f3mo los datos se almacenan en cada ResultSet del m\u00e9todo en este enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#511-crear-la-connection","title":"5.1.1. Crear la connection","text":"<p>Recuerda c\u00f3mo conectarte a un SGBD de forma sencilla:</p> <pre><code>// load JDBC driver\n2 Class.forName(\"com.mysql.cj.jdbc.Driver\");\n3 // Conecto a DBMS and DB BDJuegos, with user and pass\n4 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3308/BDJuegos\", \"root\", \"root\");\n</code></pre> <p>Muy sencillo, carga el controlador y con\u00e9ctate a la base de datos de la forma que hemos estudiado.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#512-recupera-los-metadatos-del-sgbd-y-muestralos-en-un-formato-amigable","title":"5.1.2. Recupera los metadatos del SGBD y mu\u00e9stralos en un formato amigable","text":"<p>Utilizaremos la clase Color para mostrar los datos en formato de texto en la consola.</p> <pre><code>// get the metadata\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(Colores.Blue+\"\\nDBMS information--------\"+Colores.Reset);\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getDatabaseProductName());\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getDriverName());\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getURL());\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getUserName());\n</code></pre> <p>Como puede ver, obtenemos el nombre del SGBD, el controlador, el URL y el usuario que estamos utilizando. Obviamente, es lo mismo que pusimos al crear el objeto <code>Connection</code>, pero es un buen ejemplo para mostrar informaci\u00f3n.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#513-recuperar-tablas-en-un-esquemabase-de-datos","title":"5.1.3. Recuperar tablas en un esquema/base de datos","text":"<p>Utilizando el m\u00e9todo <code>getTables()</code> podemos recuperar las tablas y m\u00e1s informaci\u00f3n. Supongamos que <code>BDJuegos</code> existe en nuestro SGBD:</p> <pre><code>System.out.println(Colores.Bright_White+String.format(\"%-15s %-15s %-15s\",\"Database\",\"Table\",\"Type\"));\nSystem.out.println(\"-------------------------------------------------------\"+Colores.Reset);\nResultSet rsmd = dbmd.getTables(\"BDJuegos\", null, null, null);\nwhile (rsmd.next()) { \nSystem.out.println(String.format(\"%-15s %-15s %-15s\",rsmd.getString(1),rsmd.getString(3),rsmd.getString(4)));\n}\n</code></pre> <p>Comentarios:</p> <p>Repasa <code>String.format()</code> para establecer una longitud espec\u00edfica de cada columna.</p> <p>Seg\u00fan la documentaci\u00f3n de javadoc, obtenemos que el ResultSet devuelto por <code>getTables</code> tiene las siguientes columnas: </p> <ol> <li>TABLE_CAT String \u2192 cat\u00e1logo de la tabla (puede ser nulo) </li> <li>TABLE_SCHEM String \u2192 esquema de la tabla (puede ser nulo) </li> <li>TABLE_NAME String \u2192 nombre de la tabla </li> <li>TABLE_TYPE String \u2192 tipos de tabla. Los tipos t\u00edpicos son \"TABLE\", \"VIEW\", \"SYSTEM TABLE\", \"GLOBAL TEMPORARY\", \"LOCAL TEMPORARY\", \"ALIAS\", \"SYNONYM\". </li> <li>REMARKS String \u2192 comentario explicativo sobre la mesa </li> <li>TYPE_CAT String \u2192 cat\u00e1logo de los tipos (puede ser nulo) </li> <li>TYPE_SCHEM String \u2192 esquema de los tipos (puede ser nulo) </li> <li>TYPE_NAME String \u2192 nombre del tipo (puede ser nulo) </li> <li>SELF_REFERENCING_COL_NAME String \u2192 nombre de la columna \"identificador\" designada de una tabla indicada (puede ser nulo) </li> <li>REF_GENERATION String \u2192 especifica c\u00f3mo se crean los valores en SELF_REFERENCING_COL_NAME Los valores pueden ser \"SYSTEM\", \"USER\", \"DERIVED\" (puede ser nulo).</li> </ol> <p>Obtenemos las columnas 1, 3 y 4.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#514-obtener-las-columnas-de-la-tabla","title":"5.1.4. Obtener las columnas de la tabla","text":"<p>Es el momento de obtener las columnas de una tabla, utilizando el m\u00e9todo <code>getColumns()</code>:</p> <pre><code>String table=...; // we set the name of an existing table\nResultSet columnas = dbmd.getColumns(\"BDJuegos\",null , tabla, null);\nSystem.out.println(Colores.Bright_White+String.format(\"%-25s %-15 s%-15s\",\"Atributo/Claves\",\"Tipos\",\"\u00bfPuede ser nulo?\"+Colores.reset));\n\nwhile (columnas.next()){ \nString columnName=columnes.getString(4); \nString tipo=columnes.getString(6); \nString nullable=columnes.getString(18); \n\nSystem.out.println(String.format(\"%-25s %-15s %15s\",columnName,tipo,nullable));\n}\n</code></pre> <p>Comentarios:</p> <ul> <li><code>getColumns()</code> devuelve un ResultSet con 24 columnas, con mucha informaci\u00f3n de la tabla. S\u00f3lo obtenemos las columnas 4, 6 y 18 con el nombre, el tipo y si puede ser nulo.</li> <li>Del mismo modo, para obtener informaci\u00f3n sobre las claves, podemos utilizar: </li> <li><code>getPrimaryKeys()</code> devuelve un ResultSet con las claves primarias de las tablas. </li> <li><code>getExportedKeys()</code> devuelve un ResultSet con las columnas que apuntan a la clave primaria de la tabla actual. Esto significa todos los campos de otras tablas que apuntan a la clave primaria de la tabla actual. </li> <li><code>getImportedKeys()</code> devuelve un ResultSet con las columnas que son claves primarias importadas en la tabla actual. Esto significa las columnas que son claves externas (y apuntan a una clave primaria de otras tablas).</li> </ul> <p>Tiene todo el ejemplo en la carpeta <code>DatabaseMeta</code> de la aplicaci\u00f3n de ejemplo y en el siguiente enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/","title":"6. Statements and CRUD operations","text":"<p>En esta secci\u00f3n estudiaremos el principal objetivo de trabajar con bases de datos: manipular datos. Siempre trabajaremos con la misma plantilla:</p> <ol> <li>Conectar a la base de datos.</li> <li>Preparar la consulta.</li> <li>Ejecutar la consulta.</li> <li>Procesamiento de los datos, si es necesario.</li> </ol> <p>El punto 1 se ha estudiado en las secciones anteriores.</p> <p>Para crear las consultas, deberemos utilizar las siguientes clases/interfaces:</p> <ul> <li><code>Statement</code> \u2192 Se utiliza de forma general y es \u00fatil cuando queremos realizar sentencias SQL est\u00e1ticas, ya que no acepta par\u00e1metros. Creamos un <code>Statement</code> con el m\u00e9todo <code>createStatement()</code> de la clase <code>Connection</code>.</li> <li><code>PreparedStatement</code> \u2192 Se utiliza cuando queremos lanzar varias consultas y, adem\u00e1s, se permite realizar sentencias din\u00e1micas. Creamos un <code>PreparedStatement</code> con el m\u00e9todo <code>prepareStatement()</code> de la clase <code>Connection</code>.</li> <li><code>CallableStatement</code> \u2192 Se utiliza para acceder a procedimientos almacenados en la base de datos y tambi\u00e9n acepta par\u00e1metros de entrada. Creamos un <code>CallableStatement</code> con el m\u00e9todo <code>prepareCall()</code> de la clase <code>Connection</code>.</li> </ul> <p>Cuando la sentencia est\u00e1 preparada, podemos ejecutarla con:</p> <ul> <li><code>executeQuery</code> \u2192 Ejecuta sentencias que esperamos que devuelvan datos (consultas SELECT). El valor de retorno de esta ejecuci\u00f3n es, como ya supondr\u00e1, un ResultSet.</li> <li><code>executeUpdate</code> \u2192 Ejecuta sentencias que no se espera que devuelvan datos, pero que se utilizar\u00e1n para modificar la base de datos conectada (consultas INSERT, DELETE, UPDATE y CREATE TABLE).</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#61-create-insert","title":"6.1. Create (Insert)","text":"<p>Vamos a ver un ejemplo sencillo de declaraci\u00f3n <code>INSERT</code>.</p> <pre><code>ConnexionDB conDB=new ConnexioDB(\"BDJuegos\");\nConnection con=conDB.getConnexio();\n\nString SQL=\"INSERT INTO Juego VALUES (1, 'Double Dragon', 'Dos hermanos gemelos expertos en artes marciales deben hacerse camino en un escenario urbano donde miembros de bandas rivales quieren dejarlos fuera de combate.', 1);\";\n\nStatement st=con.createStatement();\n\nint affectedRows=st.executeUpdate(SQL);\n\nSystem.out.println(affectedRows+ \"row has been inserted\");\n</code></pre> <p>Como puede ver, es muy f\u00e1cil de entender el c\u00f3digo. Creamos una declaraci\u00f3n vac\u00eda y despu\u00e9s ejecutamos el SQL \"per se\". La ejecuci\u00f3n devuelve el n\u00famero de filas insertadas. Veremos mejores formas de insertar datos, utilizando scripts.</p> <p>Info</p> <p>Este c\u00f3digo es una versi\u00f3n reducida, puesto que cuando trabajamos con bases de datos pueden aparecer <code>SQLException</code>. Supongamos que el proceso de conexi\u00f3n ya se ha realizado.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#62-read-select","title":"6.2. Read (Select)","text":"<p>La lectura es el proceso m\u00e1s importante que realizaremos, ya que s\u00f3lo con el proceso de inicio de sesi\u00f3n dentro de una aplicaci\u00f3n estamos recuperando informaci\u00f3n de una base de datos. En todos los casos, debemos escribir la sentencia (SQL), ejecutarla y finalmente procesar los datos devueltos. Dependiendo de c\u00f3mo preparamos la sentencia, podemos distinguir entre:</p> <ol> <li>Sentencias fijas</li> <li>Sentencias variables</li> <li>Sentencias preparadas</li> </ol> <p>Veremos con detalle ambos modos. Utilizaremos para ello el script <code>instituto</code>  en el siguiente enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#621-sentencias-fijas","title":"6.2.1. Sentencias fijas","text":"<p>Estas sentencias, como su nombre indica, son sentencias fijas o constantes. SQL es fija y no tiene ninguna variable.</p> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) throws SQLException {\n\n        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        String SQL = \"Select * from persona\";\n        // The statement\n        Statement st = con.createStatement();\n        // The execution\n        ResultSet rst = st.executeQuery(SQL);\n\n        // processing\n        while (rst.next()) {\n            System.out.print(Colores.Bright_Blue + \"Person: \" + Colores.Reset);\n            /*\n            System.out.println(\n            rst.getString(3)+ \", \"+\n            rst.getString(2)+ \" - \"+\n            rst.getInt(4));\n            */\n            System.out.println(\n                    rst.getString(\"apellidos\") + \", \" +\n                            rst.getString(\"nombre\") + \" - \" +\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n    }\n}\n</code></pre> <p>En el procesamiento de la informaci\u00f3n, ResultSet tiene:</p> <ul> <li><code>type getType(int columnIndex)</code> \u2192 m\u00e9todo sobrecargado que devuelve el tipo de datos dado, utilizando el \u00edndice de columna del ResultSet. Recuerda que la primera columna es 1 en lugar de 0. El tipo puede ser Int, String, Double, etc. si conoces el tipo. Para columnas desconocidas, puedes utilizar <code>Object</code> como tipo gen\u00e9rico.</li> <li><code>type getType(String columnName)</code> \u2192 mismo que el m\u00e9todo anterior, pero accediendo a la columna con el nombre que hemos seleccionado en la consulta o el nombre en la tabla.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#622-sentencias-variables","title":"6.2.2. Sentencias variables","text":"<p>Imagina que quieres recuperar nombres que contengan la cadena <code>Ma</code> en su interior.</p> <pre><code>String SQL=\"Select * from persona where nombre like '%Ma%'\";\n</code></pre> <p>En ese caso, esta consulta est\u00e1 codificada directamente, y si quieres cambiar la parte del texto, debes modificar tu c\u00f3digo. Para evitar la codificaci\u00f3n directa, podemos escribir:</p> <pre><code>ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        // String SQL=\"Select * from persona where nombre like '%Ma%'\";\n\n        String nombre=Utilidades.leerTextoC(\"Introduce una parte del nombre: \");\n        // The query\n        String SQL=\"Select * from persona where nombre like '%\" + nombre + \"%'\";\n        // The statement\n        Statement st=con.createStatement();\n        // The execution\n        ResultSet rst=st.executeQuery(SQL);\n\n        // processing\n        while(rst.next()){\n            System.out.print(Colores.Bright_Blue+ \"Personas con \" +nombre+\": \"+ Colores.Reset);\n            System.out.println(\n                    rst.getString(\"apellidos\")+ \", \"+\n                            rst.getString(\"nombre\")+ \" \"+\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n    }\n</code></pre> <p>Como podemos ver, los datos est\u00e1n ahora en variables, pero la construcci\u00f3n de SQL es m\u00e1s compleja. Hay que tener en cuenta que los textos deben estar entre comillas y los n\u00fameros no, lo que facilita cometer errores. Pero puede ser peor, este tipo de c\u00f3digo puede incurrir en problemas de inyecci\u00f3n SQL, como vemos en el siguiente ejemplo:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        String id_persona=Utilidades.leerTextoC(\"Dame el id: \");\n        // The query\n        String SQL=\"Select * from persona where id_persona =\"+id_persona;\n        // The statement\n        Statement st=con.createStatement();\n        // The execution\n        ResultSet rst=st.executeQuery(SQL);\n\n        // processing\n        while(rst.next()){\n            System.out.print(Colores.Bright_Blue+ \"Personas con \" +id_persona+\": \"+ Colores.Reset);\n            System.out.println(\n                    rst.getString(\"apellidos\")+ \", \"+\n                            rst.getString(\"nombre\")+ \" \"+\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n    }\n</code></pre> <ul> <li>Si el usuario introduce <code>4</code> \u2192 Se mostrar\u00e1 las persona con ID igual a 4</li> <li>Si el usuario introduce <code>4 or 1</code> \u2192 Se mostrar\u00e1n todas las personas</li> </ul> <p>Debe evitarse este tipo de consultas en las declaraciones de validaci\u00f3n de usuario, para las que utilizaremos las sentencias preparadas y, obviamente, ser muy cautelosos en la verificaci\u00f3n de las entradas.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#623-sentencias-preparadas","title":"6.2.3. Sentencias preparadas","text":"<p>Para evitar el problema de la inyecci\u00f3n SQL, siempre que tengamos par\u00e1metros en nuestra consulta, utilizaremos sentencias preparadas. En las sentencias preparadas, donde debemos utilizar un marcador, en lugar de componerla con concatenaciones dentro de la cadena, le indicaremos con un interrogante (<code>?</code>), un car\u00e1cter llamado placeholder.</p> <p>A continuaci\u00f3n, deberemos asignar valores a estos placeholders, utilizando los m\u00e9todos <code>setType(int pos)</code> donde <code>Type</code> es el tipo de datos que asignaremos y <code>pos</code> es la posici\u00f3n del placeholder, empezando por <code>1</code>. Veremos el ejemplo:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        String id_persona=Utilidades.leerTextoC(\"Dame el id: \");\n        // The query\n        String SQL=\"Select * from persona where id_persona = ?\";\n\n        // The statement\n        PreparedStatement pst = con.prepareStatement(SQL);\n\n        pst.setString(1, id_persona);\n\n        // The execution\n        ResultSet rst=pst.executeQuery();\n\n        // processing\n        while(rst.next()){\n            System.out.print(Colores.Bright_Blue+ \"Personas con \" +id_persona+\": \"+ Colores.Reset);\n            System.out.println(\n                    rst.getString(\"apellidos\")+ \", \"+\n                            rst.getString(\"nombre\")+ \" \"+\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n</code></pre> <p>Consejo</p> <p>Puedes combinar ResultSet con ResultSetMetaData para obtener los nombres de las columnas y tipos de datos almacenados en la base de datos.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#63-actualizacion-update-y-borrado-delete","title":"6.3. Actualizaci\u00f3n (Update) y Borrado (Delete)","text":"<p>La actualizaci\u00f3n y borrado de una fila se consideran como actualizaciones de la base de datos, ya que modifican el estado de la base de datos. De hecho, tambi\u00e9n consideramos la inserci\u00f3n como una actualizaci\u00f3n de la base de datos. Ambas tareas se incluyen en el m\u00e9todo <code>executeUpdate()</code>. Vamos a estudiarlo a trav\u00e9s de ejemplos:</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#631-ejemplo-de-borrado","title":"6.3.1. Ejemplo de borrado","text":"<p>Vamos a borrar filas de una mesa de personas entre las edades dadas:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        // give the age's bounds\n        int minEdad = Utilidades.leerEnteroC(\"Dame la edad m\u00ednima: \");\n        int maxEdad = Utilidades.leerEnteroC(\"Dame la edad m\u00e1xima: \");\n        // The query\n        String SQL=\"Delete from persona where edad between ? and ?\";\n\n        // The statement\n        PreparedStatement pst = con.prepareStatement(SQL);\n\n        pst.setInt(1, minEdad);\n        pst.setInt(2, maxEdad);\n\n        System.out.println(pst);\n        // The execution\n        int deletedRows = pst.executeUpdate();\n\n        System.out.println(deletedRows + \" han sido eliminadas\");\n\n        pst.close();\n</code></pre> <p>Peligro</p> <p>Eliminar datos es una operaci\u00f3n muy delicada. Cuida de: </p> <ul> <li>No olvides la cl\u00e1usula <code>WHERE</code> cuando eliminas, ya que eliminar\u00e1s todos los datos de la tabla. </li> <li>Si quieres eliminar toda la tabla, incluyendo la estructura (definici\u00f3n + tabla), debes utilizar <code>DROP TABLE</code> en lugar de <code>DELETE</code>. </li> <li>Si intentas eliminar una fila que est\u00e1 referenciada por una clave externa, obtendr\u00e1s la excepci\u00f3n <code>SQLIntegrityConstraintViolationException</code> y un mensaje como No se puede eliminar o actualizar una fila padre: falla una restricci\u00f3n de clave externa.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#632-ejemplo-de-actualizacion","title":"6.3.2. Ejemplo de Actualizaci\u00f3n","text":"<p>Vamos a a\u00f1adir a\u00f1os a las personas con el ID dado:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        // give the age's bounds\n        int difEdad = Utilidades.leerEnteroC(\"Dame el n\u00famero de a\u00f1os: \");\n        int idMin = Utilidades.leerEnteroC(\"Dame el id m\u00ednimo: \");\n        // The query\n        String SQL=\"Update persona set edad=edad+ ? where id_persona&gt; ?\";\n\n        // The statement\n        PreparedStatement pst = con.prepareStatement(SQL);\n\n        pst.setInt(1, difEdad);\n        pst.setInt(2, idMin);\n\n        System.out.println(pst);\n        // The execution\n        int updatedRows = pst.executeUpdate();\n\n        System.out.println(updatedRows + \" han sido actualizadas\");\n\n        pst.close();\n</code></pre> <p>Warning</p> <p>Recuerda que: </p> <ul> <li>La cl\u00e1usula <code>UPDATE</code> no necesita <code>FROM</code> para que indiquemos directamente el nombre de la tabla. </li> <li>Aparece la cl\u00e1usula <code>SET</code>, con pares <code>campo=valor_actualizado</code>, para asignar el nuevo valor a los campos seleccionados. </li> <li>Si olvidamos la cl\u00e1usula <code>FROM</code>, se actualizar\u00e1n todas las filas.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#64-scripts","title":"6.4. Scripts","text":"<p>Un script, que normalmente se ha creado en un archivo externo, es un conjunto de instrucciones SQL ejecutadas en orden de arriba abajo. Podemos tomar como estrategia leer el archivo l\u00ednea por l\u00ednea y ejecutarlo una por una, pero JDBC permite ejecutar un conjunto de instrucciones en bloque. Para ello, lo primero que debemos hacer es habilitar m\u00faltiples ejecuciones a\u00f1adiendo un par\u00e1metro a la conexi\u00f3n, que es <code>allowMultiQueries=true</code>.</p> <p>A continuaci\u00f3n, debemos cargar el archivo y componer una cadena con todo el script. Para normalizarlo y hacerlo totalmente port\u00e1til, debemos tener cuidado con los saltos de l\u00ednea, ya que dependiendo del sistema es una combinaci\u00f3n <code>\\n</code> o <code>\\r\\n</code>. Podemos leer l\u00ednea por l\u00ednea y guardarlo en un <code>StringBuilder</code>, a\u00f1adiendo <code>System.getProperty(\"line.separator\")</code> o <code>System.lineSeparator()</code>como separadores.</p> <p>Despu\u00e9s s\u00f3lo necesitaremos crear una declaraci\u00f3n con esta cadena y ejecutarla con <code>executeUpdate()</code>. Lo veremos a continuaci\u00f3n:</p> <pre><code>ConexionDB conDB = new ConexionDB(\"instituto\");\n\n        Connection con = conDB.getConexion();\n\n        File script = new File(\"EsquemaCine.sql\");\n\n        try (BufferedReader bfr = new BufferedReader(new FileReader(script))) {\n\n            StringBuilder sb = new StringBuilder();\n            String linea;\n\n            while ((linea = bfr.readLine()) != null) {\n                // Elimina los comentarios y espacios en blanco\n                linea = linea.trim();\n                if (linea.isEmpty() || linea.startsWith(\"--\") || linea.startsWith(\"#\")) {\n                    continue; // Omite l\u00edneas vac\u00edas y comentarios\n                }\n\n                sb.append(linea);\n\n                // Si la l\u00ednea termina en ';', es el final de una sentencia y deberemos ejecutar esta.\n                if (linea.endsWith(\";\")) {\n                    String query = sb.toString();\n                    try (Statement stm = con.createStatement()) {\n                        stm.execute(query);\n                    }\n                 catch (SQLException e) {\n                     System.out.println(\"Error SQL ejecutando el script: \" + e.getMessage());\n                 }\n                    // Reinicia el StringBuilder para la pr\u00f3xima sentencia\n                    sb.setLength(0);\n\n                } else {\n                    // Si no, a\u00f1ade un espacio para separar partes de la misma sentencia\n                    sb.append(\" \");\n                }\n\n            }\n            System.out.println(\"Script ejecutado correctamente.\");\n\n        } catch (IOException e) {\n            System.out.println(\"Error de I/O al leer el script: \" + e.getMessage());\n        }\n</code></pre> <p>Consejo</p> <p>\u00bfRecuerdas las clases <code>Files</code> y <code>Paths</code>? Reescribe el \u00faltimo ejemplo para obtener un c\u00f3digo m\u00e1s limpio.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#65-transacciones","title":"6.5. Transacciones","text":"<p>Si queremos proteger la integridad de los datos, as\u00ed como evitar situaciones de bloqueo inesperadas en aplicaciones multithread, debemos proteger nuestras operaciones, especialmente aqu\u00e9llas que modifican los datos mediante el uso de transacciones.</p> <p>Una transacci\u00f3n define un entorno de ejecuci\u00f3n en el que las operaciones de guardado se mantienen almacenadas en la memoria hasta que la transacci\u00f3n se complete. Si en un momento determinado algo falla, el estado se devuelve al punto inicial de la misma (punto inicial) oa alg\u00fan punto de marca intermedio. Por defecto, abrir una conexi\u00f3n inicia una transacci\u00f3n:</p> <ul> <li>Cada ejecuci\u00f3n en la conexi\u00f3n genera una transacci\u00f3n por s\u00ed misma.</li> <li>Si queremos desactivar esta opci\u00f3n para que la transacci\u00f3n abarque varias ejecuciones, debemos marcarlo mediante <code>Connection.setAutoCommit(false);</code>.</li> <li>Para aceptar definitivamente la transacci\u00f3n lo haremos mediante <code>Connection.commit();</code></li> <li>Para cancelar la transacci\u00f3n <code>Connection.rollback();</code></li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#66-resultsets-actualizables","title":"6.6. ResultSets actualizables","text":"<p>Los m\u00e9todos de trabajo revisados en las secciones anteriores, especialmente cuando se actualizan o borran filas, funcionan directamente en la base de datos. Esto significa que borre o actualice una fila sin cargarla previamente en la memoria. \u00bfQu\u00e9 ocurre si desea mostrar los datos al usuario y luego el usuario decide borrar o actualizar la fila? En este caso, es mejor utilizar ResultSets actualizables.</p> <p>Hemos estudiado ResultSet como una colecci\u00f3n de filas y lo utilizamos s\u00f3lo para la lectura. Tambi\u00e9n podemos utilizarlo para editar y borrar datos. Para ello, debemos abrir el ResultSet de una forma diferente a la que hemos visto hasta ahora. Y, por \u00faltimo, pero no menos importante, depender\u00e1 de la base de datos la disponibilidad de crear este tipo de ResultSets.</p> <p>Para ello, no depende del ResultSet ni de c\u00f3mo se cre\u00f3 el Statement. Debemos utilizar este constructor:</p> <pre><code>public abstract Statement createStatement( \nint arg0, // resultSetType \nint arg1, // resultSetConcurrency \nint arg2) // resultSetHoldability \nthrows SQLException\n</code></pre> <p>Como puede ver, hay 3 argumentos para indicar qu\u00e9 tipo de ResultSet damos al final. Estos tres argumentos pueden ser:</p> <ul> <li><code>resultSetType</code> \u2192 \u00e9stas son opciones sobre c\u00f3mo moverse y pasar por las filas del ResultSet: </li> <li><code>TYPE_FORWARD_ONLY</code> \u2192 opci\u00f3n por defecto. El ResultSet s\u00f3lo puede ocurrir una vez. </li> <li><code>TYPE_SCROLL_INSENSITIVE</code> \u2192 Permite rebobinar y saltar a una posici\u00f3n absoluta o relativa. </li> <li><code>TYPE_SCROLL_SENSITIVE</code> \u2192 Al igual que antes, pero permite ver los cambios realizados en la base de datos.</li> <li><code>ResultSetConcurrency</code> \u2192 \u00e9stas son opciones sobre si se puede actualizar el ResultSet o no: </li> <li><code>CONCUR_READ_ONLY</code> \u2192 opci\u00f3n por defecto. S\u00f3lo lectura. Si queremos actualizar algo, s\u00f3lo podemos utilizar las cl\u00e1usulas <code>DELETE</code> o <code>UPDATE</code>. </li> <li><code>CONCUR_UPDATABLE</code> \u2192 Las filas de ResultSet se pueden actualizar o borrar.</li> <li><code>ResultSetHoldability</code> \u2192 estas opciones son sobre el comportamiento al cerrar el ResultSet: </li> <li><code>HOLD_CURSORS_OVER_COMMIT</code> \u2192 El ResultSet se mantiene abierto despu\u00e9s de confirmar la transacci\u00f3n. </li> <li><code>CLOSE_CURSORS_AT_COMMIT</code> \u2192 El ResultSet se cierra despu\u00e9s de confirmar la transacci\u00f3n. Mejora el rendimiento.</li> </ul> <p>En el siguiente ejemplo, podemos preguntar a nuestro DBMS si estos tipos de ResultSet est\u00e1n soportados:</p> <pre><code>ConexionDB conDB = new ConexionDB(\"instituto\");\nConnection con = conDB.getConexion();\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(\"TYPE_FORWARD_ONLY: \" + dbmd.supportsResultSetType(ResultSet.TYPE_FORWARD_ONLY));\nSystem.out.println(\"TYPE_SCROLL_INSENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));\nSystem.out.println(\"TYPE_SCROLL_SENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));\nSystem.out.println(\"CONCUR_READ_ONLY: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));\nSystem.out.println(\"CONCUR_UPDATABLE: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#661-movimiento-del-resultset","title":"6.6.1. Movimiento del ResultSet","text":"<p>Como podemos ver, no s\u00f3lo podemos mover el cursor hacia delante:</p> <ul> <li><code>next</code>, <code>previous</code>, <code>first</code> y <code>last</code> \u2192 como su nombre indica, se mueven hacia delante, hacia atr\u00e1s, al principio ya la \u00faltima fila. Devuelve true si el cursor apunta a una fila y false de lo contrario.</li> <li><code>beforeFirst</code> y <code>afterLast</code> \u2192 el cursor apuntar\u00e1 fuera de las filas, antes de la primera o despu\u00e9s de la \u00faltima fila.</li> <li><code>relative(int n)</code> \u2192 el cursor se mueve n files (hacia adelante o hacia atr\u00e1s, dependiendo del signo).</li> <li><code>absolute(int n)</code> \u2192 el cursor apunta a la fila n.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#662-eliminacion-de-filas-en-un-resultset","title":"6.6.2. Eliminaci\u00f3n de filas en un ResultSet","text":"<p>Despu\u00e9s de colocar el cursor en la fila que se desea eliminar, se puede eliminar del ResultSet (y de la base de datos) con el m\u00e9todo <code>deleteRow()</code>. Cuando se elimina una fila, el cursor apuntar\u00e1 a la fila anterior a la que se ha eliminado.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#663-actualizacion-de-filas-en-un-resultset","title":"6.6.3. Actualizaci\u00f3n de filas en un ResultSet","text":"<p>Despu\u00e9s de colocar el cursor en la fila deseada, se debe:</p> <ol> <li>Actualizar las columnas deseadas, utilizando el m\u00e9todo <code>updateType(int column, type newValue)</code>, donde la columna i-\u00e9sima (o con su nombre) se asigna el nuevo valor del tipo dado.</li> <li>Una vez que se hayan modificado todas las columnas deseadas, se guardan los cambios con <code>updateRow()</code>.</li> </ol> <p>Consejo</p> <p>No podemos actualizar una fila entera, debemos actualizar columna por columna y despu\u00e9s actualizar la fila.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#164-insercion-de-filas-en-un-resultset","title":"1.6.4. Inserci\u00f3n de filas en un ResultSet","text":"<p>Si queremos insertar una nueva fila en un ResultSet, debemos:</p> <ol> <li>Generar una nueva fila vac\u00eda, y esto se logra con el m\u00e9todo <code>moveToInsertRow()</code>.</li> <li>En esta fila, aplicamos el m\u00e9todo <code>updateType(int column, type newValue)</code> a todas las columnas a las que queremos asignar un valor, y finalmente</li> <li>Procedemos a insertar la nueva fila con <code>insertRow()</code>.</li> </ol> <p>Importante</p> <ul> <li>Estas operaciones de actualizaci\u00f3n, eliminaci\u00f3n e inserci\u00f3n s\u00f3lo pueden realizarse en consultas que provienen de una tabla sin agrupaciones. </li> <li>Para evitar complejidad en nuestros programas, vale la pena evaluar la conveniencia de traducir las actualizaciones del ResultSet a SQL puro y ejecutarlas directamente en las bases de datos mediante nuevas sentencias.</li> </ul> <p>Disponemos de todos los ejemplos en el proyecto <code>SentFija</code> en el siguiente enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/","title":"7. De filas a Objetos","text":"<p>Finalmente, para cerrar la unidad, trabajaremos de forma natural: recuperaremos datos de la base de datos, crearemos objetos a partir del ResultSet y guardaremos los datos en la base de datos.</p> <p>Estudiaremos una nueva forma de crear nuestros POJO (y BEAN), utilizando una librer\u00eda moderna llamada Lombok.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#71-pojo-bean-y-proyecto-lombok","title":"7.1. POJO, BEAN y Proyecto Lombok","text":"<p>Debemos crear clases seg\u00fan nuestro modelo orientado a objetos. Dependiendo de c\u00f3mo hayamos dado las clases, pueden ser POJO o BEAN u otro tipo de clases. Vamos a entenderlo (extra\u00eddo de aqu\u00ed: enlace).</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#711-pojo","title":"7.1.1. POJO","text":"<p>Esto significa Plain Old Java Object. Es una clase que:</p> <ul> <li>No debe extender ninguna clase.</li> <li>No debe implementar ninguna interfaz.</li> <li>No debe contener anotaciones espec\u00edficas.</li> </ul> <p>No existen restricciones en los modificadores de acceso de los campos. Pueden ser privados, por defecto, protegidos o p\u00fablicos. Tampoco es necesario incluir ning\u00fan constructor en \u00e9ste.</p> <p>Un ejemplo de POJO ser\u00eda, por ejemplo:</p> <pre><code>// AS POJO\npublic class Modulo { \n// atributos \nString nombre; \nint horas; \ndouble nota; \n// constructor \npublic ModulO(String nombre, int horas, double nota) { \nthis.nombre = nombre; \nthis.horas = horas; \nthis.nota = nota; \n} \n// getters \npublic String getModulO(){return this.nombre;} \npublic int getHorAs() {return this.horas;} \npublic double getNota() {return this.nota;} \n\n@Override \npublic String toString() { \nreturn \"Modulo{\" + \"nombre=\" + nombre + \", horas=\" + horas + \", nota=\" + nota + \"}\"; \n}\n}\n</code></pre> <p>Como puede ver, un POJO es la m\u00ednima clase que podemos hacer.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#712-bean","title":"7.1.2. BEAN","text":"<p>Los Beans son un tipo especial de POJO. Hay algunas restricciones para que un POJO sea un Bean.</p> <ul> <li>Todos los JavaBeans son POJOs, pero no todos los POJOs son JavaBeans.</li> <li><code>Serializable</code>, deben implementar la interfaz Serializable. Sin embargo, algunos POJOs que no implementan la interfaz Serializable se llaman POJOs porque Serializable es una interfaz marcadora y, por tanto, no supone una carga excesiva.</li> <li>Los campos deben ser privados. Esto proporciona un control completo sobre los campos.</li> <li>Los campos deben tener getters o setters o ambos.</li> <li>Debe haber un constructor sin argumentos en un Bean.</li> <li>Los campos s\u00f3lo se acceden mediante constructor o getters y setters.</li> </ul> <pre><code>// AS POJO\npublic class Modulo { \n// atributos \nprivate String nombre; \nprivate int horas; \nprivate double nota; \n// constructor \npublic Modulo() { } \n// getters \npublic String getModulo(){return this.nombre;} \npublic int getHoras() {return this.horas;} \npublic double getNota() {return this.nota;}\n// setters \npublic void getModulo(){return this.nombre;} \npublic void getHoras() {return this.horas;} \npublic void getNota() {return this.nota;} \n\n@Override \npublic String toString() { \nreturn \"Modulo{\" + \"nombre=\" + nombre + \", horas=\" + horas + \", nota=\" + nota + \"}\"; \n}\n}\n</code></pre> <p>Para resumir, las clases POJO y Beans se utilizan para definir objetos Java para aumentar su legibilidad y reutilizaci\u00f3n. Los POJOs no tienen otras restricciones mientras que los beans son POJOs especiales con algunas restricciones.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#713-lombok","title":"7.1.3. Lombok","text":"<p>Independientemente de si utilizamos POJO o BEAN, hay algunas tareas repetitivas que debemos realizar para crear nuestras clases. La mayor\u00eda de estas tareas son implementadas por los IDE, como crear getters, setters, encapsular campos, crear constructores, etc. Project Lombok es una librer\u00eda que evita realizar estas tareas repetitivas, y decimos lo que queremos y la librer\u00eda y el compilador hacen el resto.</p> <p>En este enlace configuraci\u00f3n de Lombok encontrar\u00e1s c\u00f3mo configurar la librer\u00eda en cada gestor de proyectos (gradle, maven, etc.) y en cada IDE (Netbeans, Eclipse, IntelliJ, etc.).</p> <p>Una vez instalada, basta con decir mediante anotaciones lo que quieres:</p> <ul> <li><code>@Getter</code> \u2192 generar\u00e1 todos los getters.</li> <li><code>@Setter</code> \u2192 generar\u00e1 todos los setters.</li> <li><code>@Data</code> \u2192 todos los m\u00e9todos que necesitan un POJO, incluyendo <code>ToString</code>.</li> <li><code>@AllArgsConstructor</code> o <code>@NoArgsConstructor</code> \u2192 generar\u00e1 el constructor que quieras.</li> </ul> <p>En el siguiente v\u00eddeo v\u00eddeo se explica como a\u00f1adir la dependencia a Maven y como hacer usp de lombok.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#72-cargando-objetos","title":"7.2. Cargando objetos","text":"<p>Vamos a finalizar con un ejemplo:</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#721-clase-persona","title":"7.2.1. Clase Persona","text":"<p>Esta clase es el POJO de una persona. Crear\u00e1 getters, setters, toString y los m\u00e9todos principales con s\u00f3lo unas pocas l\u00edneas y algunas anotaciones.</p> <pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Persona { \nprivate int id_persona; \nprivate String nombre; \nprivate String apellidos; \nprivate int edad;\n}\n</code></pre> <p>Hay que tener en cuenta que con Lombok el trabajo resulta f\u00e1cil.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#722-llenando-un-array","title":"7.2.2. Llenando un Array","text":"<p>Para llenar una estructura de datos desde la base de datos, primero es necesario obtener los datos. Es necesario crear el objeto <code>Statement</code> o <code>PreparedStatement</code> y ejecutar la consulta.</p> <p>La tarea principal es transformar el <code>ResultSet</code> en una lista, pero es una tarea sencilla:</p> <ul> <li>Recorre el ResultSet (con next), y para cada fila: </li> <li>Crea un objeto con los valores almacenados en las columnas </li> <li>A\u00f1ade este objeto a la lista</li> </ul> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\n\n\npublic class Main {\n    public static void main(String[] args) throws SQLException {\n        ArrayList&lt;Persona&gt; lasPersonas = new ArrayList();\n\n        ConexionDB conDB = new ConexionDB(\"instituto\");\n\n        Connection con = conDB.getConexion();\n\n        String SQL = \"Select * from persona\";\n        // The statement\n        Statement st = con.createStatement(\n                ResultSet.TYPE_SCROLL_INSENSITIVE,\n                ResultSet.CONCUR_READ_ONLY);\n\n        // The execution\n        ResultSet rst = st.executeQuery(SQL);\n\n        if (!rst.next()) {\n            System.out.println(\"No hay personas en la BD2\");\n            rst.beforeFirst();\n            while (rst.next()) {\n                Persona p = new Persona(\n                        rst.getInt(1),\n                        rst.getString(2),\n                        rst.getString(3),\n                        rst.getInt(4));\n                System.out.println(\"A\u00f1adiendo\" + p);\n                lasPersonas.add(p);\n            }\n        }\n\n        System.out.println(\"A\u00f1adido \" + lasPersonas.size() + \" personas\");\n        rst.close();\n    }\n}\n</code></pre> <p>Ahora podr\u00e1s cambiar la informaci\u00f3n en los objetos y, finalmente, si se ha realizado alguna modificaci\u00f3n, deber\u00e1s guardarla en la base de datos. Las preguntas son:</p> <ul> <li>\u00bfC\u00f3mo puedo saber si se ha actualizado un objeto?</li> <li>\u00bfC\u00f3mo puedo saber qu\u00e9 campo debe guardarse?</li> </ul> <p>Como puedes ver, existen varias tareas que requieren un control de la modificaci\u00f3n de los datos y c\u00f3mo guardarlos. Esta tarea ser\u00e1 f\u00e1cil con ORM y la estudiaremos.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/","title":"Actividad Cliente MySQL","text":"<p>Vamos a crear un cliente de SGBD, como MySQL Workbench, pero en una versi\u00f3n de consola con una shell y un prompt. Nuestro cliente nos permite conectarnos a un servidor, seleccionar una base de datos y por \u00faltimo ejecutar varias consultas SQL.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#11-modo-de-servidor","title":"1.1. Modo de servidor","text":"<p>Al iniciar nuestro programa, pedir\u00e1 los datos del servidor.</p> <pre><code>java -jar cliente\n...\n$ Server: 127.0.0.1\n$ Port: 3308\n$ Username: root\n$ Password:\n$ (root) on 127.0.0.1:3308&gt;\n</code></pre> <p>Como puede ver en la \u00faltima l\u00ednea, el prompt es <code>(usuario) on IP:port&gt;</code>. Nuestro cliente muestra siempre d\u00f3nde estamos conectados.</p> <p>La lista de \u00f3rdenes que nuestro cliente aceptar\u00e1 cuando est\u00e9 conectado es (modo servidor):</p> <ul> <li><code>show database</code> o <code>show db</code> \u2192 muestra una lista con todas las bases de datos de nuestro SGBD.</li> <li><code>info</code> \u2192 muestra informaci\u00f3n sobre el SGBD y la configuraci\u00f3n de la conexi\u00f3n.</li> <li><code>import nombre_del_script</code> \u2192 permite cargar un script SQL desde un archivo.</li> <li><code>use nombre_de_la_bd</code> \u2192 cambia nuestro programa al modo base de datos.</li> <li><code>quit</code> \u2192 finaliza nuestro programa.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#12-mode-de-base-de-dades","title":"1.2. Mode de Base de Dades","text":"<p>Una vez que estemos conectados a un servidor y hayamos seleccionado una base de datos, nuestro cliente entrar\u00e1 en el modo de base de datos:</p> <pre><code>$ (root) on 127.0.0.1:3308&gt;use instituto\n$ (root) on 127.0.0.1:3308[instituto]&gt;\n</code></pre> <p>Puedes ver que el nombre de la base de datos se a\u00f1ade al prompt y ahora el programa est\u00e1 esperando comandos para la base de datos. Tienes que implementar estos comandos:</p> <ul> <li><code>sh tables</code> \u2192 muestra todas las tablas de la base de datos seleccionada.</li> <li><code>describe nombre_de_la_tabla</code> \u2192 muestra la descripci\u00f3n de esta tabla: campos, tipos de datos y claves primarias como m\u00ednimo.</li> <li><code>insert Nombre_de_la_Tabla</code> \u2192 de forma interactiva, pide al usuario el valor de cada campo e inserta una nueva fila.</li> <li><code>sql</code> \u2192 ejecuta cualquier consulta en la base de datos seleccionada.</li> <li><code>quit</code> \u2192 vuelve al modo SGBD.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#2-estructura-del-proyecto-y-consejo","title":"2. Estructura del proyecto y consejo","text":"<p>El proyecto contiene las siguientes clases:</p> <p></p> <p>Vamos a revisar las funciones de clase</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#21-servermanager","title":"2.1. ServerManager","text":"<p>Contiene main, y cuando se inicia, pide al usuario la informaci\u00f3n del servidor. A continuaci\u00f3n, inicia la clase <code>ConnectionManager</code> con los valores proporcionados.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#22-connectionmanager","title":"2.2. ConnectionManager","text":"<p>Gestiona la consola principal del programa y tiene como atributos:</p> <pre><code>String server;\nString port;\nString user;\nString pass;\n</code></pre> <p>y como m\u00e9todos:</p> <ul> <li><code>ConnectionManager()</code> \u2192 constructor por defecto.</li> <li><code>ConnectionManager(String server, String port, String user, String pass)</code> \u2192 constructor general.</li> <li><code>public Connection connectDBMS()</code> \u2192 inicia y devuelve una conexi\u00f3n.</li> <li><code>public void showInfo()</code> \u2192 muestra la informaci\u00f3n del servidor.</li> <li><code>public void showDatabases()</code> \u2192 mostra les taules del servidor.</li> <li><code>public void importScript(String script)</code> \u2192 carga y ejecuta un script.</li> <li><code>public void startShell()</code> \u2192 inicia la consola del servidor. Esta consola est\u00e1 ya implementada.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#23-gestor-de-base-de-datos","title":"2.3. Gestor de Base de Datos","text":"<p>Gestiona la consola del modo base de datos y necesita un atributo adicional respecto al Gestor de Conexi\u00f3n:</p> <pre><code>String server;\nString port;\nString user;\nString pass;\nString dbname;\n</code></pre> <p>y como m\u00e9todos:</p> <ul> <li><code>DatabaseManager()</code> \u2192 constructor por defecto.</li> <li><code>DatabaseManager(String server, String port, String user, String pass,String dbname)</code> \u2192 constructor general.</li> <li><code>public Connection connectDatabase()</code> \u2192 inicia y devuelve una conexi\u00f3n a la base de datos actual.</li> <li><code>public void insertIntoTable(String table)</code> \u2192 inicia el asistente de inserci\u00f3n para la tabla dada.</li> <li><code>public void showDescTable(String table)</code> \u2192 muestra los metadatos de la tabla.</li> <li><code>public void executeSelect(String query)</code> \u2192 ejecuta una consulta dada (de cualquier tipo) y muestra los resultados en la pantalla, si los hubiere.</li> <li><code>public void startShell()</code> \u2192 inicia la consola del modo base de datos. Tienes que realizar una implementaci\u00f3n completa.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#3-inserciones-a-las-tablas","title":"3. Inserciones a las tablas.","text":"<p>El m\u00e9todo <code>insertIntoTable</code> es probablemente el m\u00e1s dif\u00edcil de la tarea, ya que es necesario pedir primero los metadatos de la tabla para conocer los campos y los tipos de datos de la tabla, y despu\u00e9s pedir al usuario los valores y los formatos.</p> <p>El consejo que se dar\u00e1 es crear tres listas con:</p> <ol> <li>Lista de campos a insertar.</li> <li>Lista de valores que se asignar\u00e1n.</li> <li>Lista de tipos de cada campo.</li> </ol> <p>Adem\u00e1s, es necesario generar una lista o cadena de marcadores de posici\u00f3n con tantos <code>?</code> como sea necesario.</p> <p>Consejo</p> <p>Recuerda que, al pedir los metadatos de la tabla, las columnas que necesitas son: </p> <ul> <li>Columna 4: nombre de la columna </li> <li>Columna 6: tipos de datos de la columna </li> <li>Columna 18: nullable o no. Este campo es obligatorio si no es nullable. </li> <li>Columna 23: incremental o no. No necesitas ese campo si es incremental. </li> </ul> <p>Por \u00faltimo, verifica el ajuste de los placeholders, ya que dependen del tipo de datos. Tener en cuenta que: </p> <ul> <li>Los datos <code>int</code> utilizar\u00e1n <code>setInt()</code> </li> <li>Los datos <code>datetime</code> utilizar\u00e1n <code>setDate()</code>, con un casting en <code>java.sql.Date</code> en lugar de <code>java.Date</code> </li> <li>Por defecto el <code>setString</code> y confiar en que el casting autom\u00e1tico haga su trabajo.</li> </ul> <p>Disponemos del paquete <code>ClienteSQL_alu</code> el siguiente enlace.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/","title":"1 Mapping","text":""},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#1-introduccion-tecnicas-de-mapeo","title":"1. Introducci\u00f3n. T\u00e9cnicas de mapeo.","text":"<p>En unidades anteriores hemos estudiado el acceso de nuestros programas a los ficheros y bases de datos relacionales. Como hemos visto, el gran problema es que nuestros programas manipulan objetos, mientras que las bases de datos manipulan tablas, lo que provoca el uso de modelos diferentes y termina en el ya citado vac\u00edo objeto-relacional.</p> <p>El mapeo objeto-relacional viene a llenar el vac\u00edo entre estos dos modelos, evitando que gastemos tiempo en nuestro c\u00f3digo convirtiendo entre los resultados de las operaciones y nuestros objetos. Con el uso de un ORM (Object Relational Mapping), una vez establecida la correspondencia entre los modelos, en nuestros programas s\u00f3lo trabajaremos con un modelo, el modelo orientado a objetos. De esta forma conseguimos evitar que nuestros programas caigan en ese vac\u00edo, centr\u00e1ndonos en la l\u00f3gica de negocio.</p> <p>Las t\u00e9cnicas ORM (Object-Relational Mapping Tools) son las encargadas, mediante un conjunto de descripciones y metadatos (datos que describen los datos), de hacer una correspondencia entre los datos primitivos de ambos modelos y sus estructuras: entre tablas y objetos, campos y atributos, sus identificadores y sus claves primarias. Esta correspondencia no siempre ser\u00e1 sencilla y tendr\u00e1n que estar disponibles metadatos que puedan expresar una mayor complejidad.</p> <p>Por ejemplo:</p> <ul> <li>Quiz\u00e1s encontraremos que a veces puede ser interesante almacenar una propiedad en m\u00e1s de una columna, o varias propiedades en una sola columna.</li> <li>En otras ocasiones, puede haber propiedades que no se almacenen, o campos de la base de datos que no aparezcan en los objetos.</li> <li>Utilice atributos con tipos de datos no primitivos que necesitan ser convertidos en otras tablas, y decida qu\u00e9 campos ser\u00e1n claves externas que apunten a las nuevas tablas.</li> </ul> <p>Al igual que la definici\u00f3n de los datos, necesitaremos un mecanismo de persistencia de objetos, de modo que los objetos puedan ser \"rastreados\" en la memoria y cuando se reflejen cambios en ellos, se reflejen directamente en la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#12-mapeo","title":"1.2. Mapeo","text":"ORM <p>Con estas herramientas de mapeo conseguiremos:</p> <ul> <li>Reducir el tiempo de desarrollo</li> <li>Olvidarnos de nuestro SGBD subyacente</li> <li>Trabajar con objetos, atributos y m\u00e9todos. No necesita saber nada sobre tablas y relaciones.</li> </ul> <p>Todas las herramientas de mapeo se basan en estas tres bases s\u00f3lidas.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#121-tecnicas-de-mapeo","title":"1.2.1. T\u00e9cnicas de mapeo","text":"<p>Destacamos dos t\u00e9cnicas de mapeo objeto-relacional:</p> <ul> <li>Aquellas que incrustan las definiciones dentro del c\u00f3digo de las clases y est\u00e1n vinculadas al lenguaje, como macros de C++ o anotaciones de PHP y Java.</li> <li>Aquellas que guardan las definiciones en archivos independientes del c\u00f3digo, generalmente en XML o JSON.</li> </ul> <p>Estas t\u00e9cnicas no son exclusivas, puesto que ambas est\u00e1n disponibles en la mayor\u00eda de entornos e incluso pueden coexistir en la misma aplicaci\u00f3n.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#122-lenguaje-de-consulta","title":"1.2.2. Lenguaje de consulta","text":"<p>Dado que los SGBD incluyen SQL como lenguaje de consulta, la mayor\u00eda de los ORM incluyen su propio lenguaje, basado en OQL (Object Query Language). Como en SQL, podemos pedir informaci\u00f3n, pero basada en objetos en lugar de tablas.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#123-sincronizacion","title":"1.2.3. Sincronizaci\u00f3n","text":"<p>Los ORM incluyen varios procesos centrados en:</p> <ul> <li>Seguir y descubrir los cambios que experimentan los objetos durante su ciclo de vida para almacenarlos.</li> <li>Crear e iniciar nuevas instancias de objetos a partir de los datos almacenados en la base de datos.</li> <li>A partir de los objetos, extraer su informaci\u00f3n para reflejarla en las tablas de la base de datos.</li> </ul> <p>Note</p> <p>Estudiaremos el ciclo de vida de los objetos cuando se cargan y guardan de la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/","title":"2. Hibernate","text":"Hibernate <p>Hibernate es un framework ORM para Java, que facilita la correspondencia de atributos entre una base de datos relacional y el modelo de objetos de nuestra aplicaci\u00f3n mediante archivos XML o anotaciones en los beans de entidad. Es un software libre distribuido bajo la licencia GPL 2.0, por lo que puede utilizarse en aplicaciones comerciales.</p> <p>Hibernate es la implementaci\u00f3n m\u00e1s popular de la especificaci\u00f3n JPA (Java Persistence API), un est\u00e1ndar de Java para la persistencia de objetos. JPA proporciona una API uniforme mientras que Hibernate ofrece la implementaci\u00f3n robusta que maneja la correspondencia ORM.</p> <p>La funci\u00f3n principal de Hibernate con JPA ser\u00e1 ofrecer al programador las herramientas para detallar su modelo de datos mediante anotaciones est\u00e1ndar, de modo que sea el propio ORM el que interact\u00fae con la base de datos, mientras que el desarrollador se dedica a manipular objetos.</p> Hibernate Arquitecture <p>JPA introduce el EntityManager como interfaz principal para las operaciones de persistencia, reemplazando en muchos casos el uso directo de Session de Hibernate. Los objetos creados son rastreados en el contexto de persistencia, y las operaciones se sincronizan con la base de datos al confirmar las transacciones.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#21-configuracion","title":"2.1 Configuraci\u00f3n","text":"<p>Hibernate, como implementaci\u00f3n de JPA, no necesita una instalaci\u00f3n espec\u00edfica, puesto que est\u00e1 integrado en nuestro proyecto como librer\u00edas. Utilizaremos Maven como gestor de paquetes para automatizar las dependencias.</p> <p>Utilizaremos Maven como gestor de paquetes.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#22-dependencias","title":"2.2 Dependencias.","text":"<p>En nuestros proyectos se utilizar\u00e1n dos herramientas b\u00e1sicas: Hibernate y un controlador para conectarse a la base de datos seleccionada. Obviamente, es necesario a\u00f1adir las dependencias al gestor de paquetes. En Maven, las dependencias se incluyen en el archivo <code>Pom.xml</code>, en la carpeta ra\u00edz de nuestro proyecto. Dentro de la etiqueta <code>&lt;dependencias&gt;</code> hay que a\u00f1adir:</p> MavenGradle <pre><code>&lt;dependencies&gt;\n    &lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n        &lt;version&gt;9.4.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.hibernate.orm/hibernate-core --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n        &lt;version&gt;7.1.2.Final&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Jakarta Persistence API --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n        &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n        &lt;version&gt;3.2.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Logging --&gt;\n    &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n        &lt;version&gt;1.5.19&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;version&gt;1.18.42&lt;/version&gt;\n        &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>// Hibernate como implementaci\u00f3n JPA\nimplementation(\"org.hibernate.orm:hibernate-core:7.1.2.Final\")\n\n// MySQL Connector\n// https://mvnrepository.com/artifact/com.mysql/mysql-connector-j\nimplementation(\"com.mysql:mysql-connector-j:9.4.0\")\n\n// API JPA (Jakarta Persistence)\n// https://mvnrepository.com/artifact/jakarta.persistence/jakarta.persistence-api\nimplementation(\"jakarta.persistence:jakarta.persistence-api:3.2.0\")\n\n// https://mvnrepository.com/artifact/org.projectlombok/lombok\nimplementation(\"org.projectlombok:lombok:1.18.42\")\n\n// https://mvnrepository.com/artifact/ch.qos.logback/logback-classic\nimplementation(\"ch.qos.logback:logback-classic:1.5.19\")\n</code></pre> <p>Recuerda...</p> <p>Recuerda que puedes encontrar los paquetes en https://mvnrepository.com/repos/central</p> <p>Adem\u00e1s vamos a hacer uso del paquete logback-classic el cual nos proporcionar\u00e1 informaci\u00f3n de los log de nuestra aplicaci\u00f3n. La dependecia se puede ver en los gestores anteriores.</p> <p>Para ello necesitaremos configurar el fichero logback.xml:</p> <pre><code>src/\n\u251c\u2500\u2500 main/\n\u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u2514\u2500\u2500 (tu c\u00f3digo de la librer\u00eda)\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 META-INF/\n\u2502       \u2502   \u2514\u2500\u2500 persistence.xml\n\u2502       \u2514\u2500\u2500 logback.xml\n</code></pre> <p>Antes de abordar la configuraci\u00f3n, vamos a ver los niveles que queremos de log, fichero logback.xml</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#221-opcion-recomendada-para-las-librerias","title":"2.2.1. Opci\u00f3n recomendada para las librerias","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;!-- Configuraci\u00f3n para Hibernate --&gt;\n    &lt;logger name=\"org.hibernate.engine\" level=\"INFO\"/&gt;\n    &lt;logger name=\"org.hibernate.mapping.Table\" level=\"INFO\"/&gt;\n    &lt;logger name=\"org.hibernate.service.internal.SessionFactoryServiceRegistryImpl\" level=\"INFO\"/&gt;\n\n     &lt;!-- Tu librer\u00eda - nivel INFO para mensajes importantes --&gt;\n    &lt;logger name=\"tu.paquete.libreria\" level=\"INFO\"/&gt;\n\n    &lt;!-- Configuraci\u00f3n general --&gt;\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n    &lt;/root&gt;\n\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Esta es la informaci\u00f3n que nos va a dar cuando estemos probando nuestro desarrollo.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#222-opcion-de-produccion","title":"2.2.2. Opci\u00f3n de producci\u00f3n","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;!-- Nivel WARN para evitar la mayor\u00eda de los logs --&gt;\n    &lt;logger name=\"org.hibernate\" level=\"WARN\"/&gt;\n    &lt;logger name=\"org.demo\" level=\"WARN\"/&gt;\n\n    &lt;root level=\"WARN\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n    &lt;/root&gt;\n\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#223-desactivar-completamente-los-log","title":"2.2.3. Desactivar completamente los log","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;root level=\"OFF\"/&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#23-estructura-del-proyecto","title":"2.3. Estructura del proyecto","text":"<p>Una vez que hemos a\u00f1adido las dependencias, debemos crear una estructura de proyecto para organizar nuestras clases, con el objetivo de separar la l\u00f3gica del programa. A continuaci\u00f3n, mostraremos una breve descripci\u00f3n, profundizando en cada punto m\u00e1s adelante.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#231-entidades-jpa","title":"2.3.1. Entidades JPA","text":"<p>Las entidades JPA son la evoluci\u00f3n de los Beans tradicionales:</p> <p>Como extensi\u00f3n de los POJOs, aparecen los Beans, sin restricciones en los atributos, constructores y herencia. Tienen algunas restricciones:</p> <ul> <li>Sus atributos deben ser <code>private</code> (encapsulaci\u00f3n).</li> <li>Deben implementar la interfaz <code>Serializable</code>.</li> <li>Deben tener getters y setters p\u00fablicos.</li> <li>Deben tener un constructor gen\u00e9rico (sin argumentos).</li> </ul> <p>Recuerda</p> <p>La serializaci\u00f3n en tiempo de ejecuci\u00f3n asocia a cada clase serializable un n\u00famero de versi\u00f3n, llamado <code>serialVersionUID</code>, que se utiliza durante la deserializaci\u00f3n para verificar que el emisor y el receptor de un objeto serializado han cargado clases para ese objeto que son compatibles en relaci\u00f3n a la serializaci\u00f3n. </p> <p>Si el receptor ha cargado una clase para el objeto que tiene un <code>serialVersionUID</code> distinto al de la clase del emisor correspondiente, entonces la deserializaci\u00f3n dar\u00e1 lugar a una <code>InvalidClassException</code>. Una clase serializable puede declarar su propio <code>serialVersionUID</code> expl\u00edcitament mediante la declaraci\u00f3n de un campo llamado <code>serialVersionUID</code> que debe ser est\u00e1tico, final y de tipo long: </p> <p>As\u00ed, los Beans son componentes de acceso a datos y representan a entidades en nuestra aplicaci\u00f3n. Es una buena idea crear nuestros Beans en la misma carpeta, normalmente llamada <code>Modelo</code>.</p> <p>Nosotros vamos a trabajar con JPA que es lo que la industria hace uso actualmente.</p> <pre><code>import jakarta.persistence.*;\nimport lombok.Data;\n\nimport java.io.Serializable;\n\n@Data\n@Entity\n@Table(name = \"Peli\")\npublic class Peli implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idPeli;\n\n    @Column(name = \"titulo\", nullable = false)\n    private String titulo;\n\n    @Column(name = \"anyo\")\n    private int anyo;\n\n    @Column(name = \"director\")\n    private String elDirector;\n\n    // Constructor por defecto (OBLIGATORIO en JPA)\n    public Peli() {\n    }\n\n    // Constructor con par\u00e1metros\n    public Peli(String titulo, int anyo, String elDirector) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.elDirector = elDirector;\n    }\n\n\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#232-archivos-de-mapeo","title":"2.3.2. Archivos de mapeo","text":"<p>\u00a1IMPORTANTE! Con JPA, los archivos <code>*.hbm.xml</code> NO SON NECESARIOS. Todo el mapeo se define mediante anotaciones en las clases entidad.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#24-configuracion-del-proyecto","title":"2.4. Configuraci\u00f3n del proyecto","text":"<p>Vamos a examinar m\u00e1s detenidamente el archivo de configuraci\u00f3n de Hibernate. En el archivo de configuraci\u00f3n de Hibernate podemos establecer las opciones de forma desordenada, pero se recomienda agrupar los bloques de opciones para aclarar y mantener el c\u00f3digo, as\u00ed como indicar mediante comentarios qu\u00e9 estamos haciendo en cada momento. Lo veremos con un ejemplo completo, que detallaremos paso a paso en las siguientes secciones.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#241-hibernatecfgxml","title":"2.4.1. Hibernate.cfg.xml","text":"XML <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE hibernate-configuration PUBLIC\n\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n\n&lt;hibernate-configuration&gt;\n    &lt;session-factory&gt;\n        &lt;!-- Configuraci\u00f3n de conexi\u00f3n --&gt;\n        &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3308/DBName&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt;\n\n        &lt;!-- Pool de conexiones --&gt;\n        &lt;property name=\"hibernate.connection.pool_size\"&gt;5&lt;/property&gt;\n\n        &lt;!-- Dialecto --&gt;\n        &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n\n        &lt;!-- Contexto de sesi\u00f3n --&gt;\n        &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;\n\n        &lt;!-- Mostrar SQL (solo desarrollo) --&gt;\n        &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;\n        &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;\n\n        &lt;!-- Estrategia DDL --&gt;\n        &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;\n\n        &lt;!-- Mapeo de clases entidad JPA --&gt;\n        &lt;mapping class=\"paquete.entidad.Peli\" /&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#242-alternativa-persistencexml","title":"2.4.2 Alternativa: persistence.xml","text":"XML <p>```xml</p> <p> org.hibernate.jpa.HibernatePersistenceProvider <pre><code>    &lt;class&gt;Peli&lt;/class&gt;\n\n    &lt;properties&gt;\n        &lt;property name=\"jakarta.persistence.jdbc.driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n        &lt;property name=\"jakarta.persistence.jdbc.url\" value=\"jdbc:mysql://localhost:3308/Cine1_V1\"/&gt;\n        &lt;property name=\"jakarta.persistence.jdbc.user\" value=\"root\"/&gt;\n        &lt;property name=\"jakarta.persistence.jdbc.password\" value=\"root\"/&gt;\n\n        &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQLDialect\"/&gt;\n        &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n        &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt;\n        &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt;\n    &lt;/properties&gt;\n&lt;/persistence-unit&gt;\n</code></pre> <p>     ```</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#243-opciones-hbm2ddlauto","title":"2.4.3 Opciones hbm2ddl.auto","text":"Opci\u00f3n Descripci\u00f3n <code>create</code> Crea siempre la BD cuando se carga la session factory. Se pierden los datos. <code>update</code> Los datos se mantienen, pero la estructura se actualiza. \u00datil en producci\u00f3n. <code>create-drop</code> Como create pero elimina la base de datos al final. <code>validate</code> Comprueba el mapeo entre la base de datos y los beans. <code>none</code> No realiza acciones DDL."},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#244-carga-de-scripts","title":"2.4.4 Carga de scripts","text":"<p>Para insertar datos de prueba, crea un archivo <code>import.sql</code> en <code>src/main/resources</code>. Se ejecutar\u00e1 autom\u00e1ticamente despu\u00e9s de la creaci\u00f3n de tablas.</p> <p>Para m\u00faltiples scripts:</p> XML <pre><code>&lt;property name=\"hibernate.hbm2ddl.import_files\"&gt; \n/import1.sql, /import2.sql\n&lt;/property&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#25-configuracion-de-sesiones","title":"2.5 Configuraci\u00f3n de sesiones","text":""},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#251-hibernateutil-con-jpa","title":"2.5.1 HibernateUtil con JPA","text":"Java <pre><code>import org.hibernate.SessionFactory;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\n\npublic class HibernateUtil { \n\n    private static final SessionFactory sessionFactory; \n\n    static { \n        try { \n            StandardServiceRegistry registry = new StandardServiceRegistryBuilder()\n                    .configure(\"hibernate.cfg.xml\")\n                    .build();\n\n            MetadataSources sources = new MetadataSources(registry);\n            sources.addAnnotatedClass(Peli.class);\n\n            Metadata metadata = sources.getMetadataBuilder().build();\n            sessionFactory = metadata.getSessionFactoryBuilder().build();\n\n        } catch (Throwable ex) { \n            System.err.println(\"Error en la inicializaci\u00f3n. \" + ex); \n            throw new ExceptionInInitializerError(ex); \n        } \n    } \n\n    public static SessionFactory getSessionFactory() { \n        return sessionFactory; \n    }\n\n    public static void shutdown() {\n        if (sessionFactory != null) {\n            sessionFactory.close();\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#252-jpautil-alternativa-estandar","title":"2.5.2 JPAUtil (Alternativa est\u00e1ndar)","text":"Java <pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.Persistence;\n\npublic class JPAUtil {\n    private static final EntityManagerFactory emf = \n        Persistence.createEntityManagerFactory(\"miUnidadPersistencia\");\n\n    public static EntityManager getEntityManager() {\n        return emf.createEntityManager();\n    }\n\n    public static void close() {\n        if (emf != null &amp;&amp; emf.isOpen()) {\n            emf.close();\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#26-operaciones-basicas","title":"2.6 Operaciones b\u00e1sicas","text":""},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#261-persistir-entidades","title":"2.6.1 Persistir entidades","text":"Con SessionCon EntityManager <pre><code>Session session = HibernateUtil.getSessionFactory().openSession();\nTransaction tx = session.beginTransaction();\n\nPeli nuevaPeli = new Peli(\"Inception\", 2010, \"Christopher Nolan\");\nsession.persist(nuevaPeli);\n\ntx.commit();\nsession.close();\n</code></pre> <pre><code>EntityManager em = JPAUtil.getEntityManager();\nEntityTransaction tx = em.getTransaction();\ntx.begin();\n\nem.persist(nuevaPeli);\n\ntx.commit();\nem.close();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#262-buscar-por-id","title":"2.6.2 Buscar por ID","text":"Con SessionCon EntityManager <pre><code>Peli peli = session.find(Peli.class, 1L);\n</code></pre> <pre><code>Peli peli = em.find(Peli.class, 1L);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#263-actualizar-entidades","title":"2.6.3 Actualizar entidades","text":"Java <pre><code>Peli peli = em.find(Peli.class, 1L);\npeli.setTitulo(\"Nuevo t\u00edtulo\");\n// La actualizaci\u00f3n es autom\u00e1tica al hacer commit\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#264-eliminar-entidades","title":"2.6.4 Eliminar entidades","text":"Java <pre><code>Peli peli = em.find(Peli.class, 1L);\nem.remove(peli);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#27-consultas-con-jpql","title":"2.7 Consultas con JPQL","text":""},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#271-consulta-basica","title":"2.7.1 Consulta b\u00e1sica","text":"Java <pre><code>TypedQuery&lt;Peli&gt; query = em.createQuery(\n    \"SELECT p FROM Peli p WHERE p.anyo &gt; :anio\", Peli.class);\nquery.setParameter(\"anio\", 2000);\nList&lt;Peli&gt; pelis = query.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#272-consulta-con-multiples-resultados","title":"2.7.2 Consulta con m\u00faltiples resultados","text":"Java <pre><code>TypedQuery&lt;Object[]&gt; query = em.createQuery(\n    \"SELECT p.titulo, p.director FROM Peli p\", Object[].class);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#273-consultas-nativas-sql","title":"2.7.3 Consultas nativas SQL","text":"Java <pre><code>Query query = em.createNativeQuery(\"SELECT * FROM Peli WHERE anyo &gt; ?\", Peli.class);\nquery.setParameter(1, 2000);\nList&lt;Peli&gt; pelis = query.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#28-ejemplo-completo","title":"2.8 Ejemplo completo","text":"Java <p>```java</p> <p>import jakarta.persistence.*;</p> <p>import java.util.List;</p> <p>public class Main {     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"PelisUP\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();</p> <pre><code>    try {\n        tx = em.getTransaction();\n        tx.begin();\n\n        // Crear y guardar nueva entidad\n        Peli peli = new Peli(\"The Matrix\", 1999, \"Lana Wachowski\");\n        em.persist(peli);\n\n        // Buscar entidad\n        Peli encontrada = em.find(Peli.class, peli.getIdPeli());\n        System.out.println(\"Encontrada: \" + encontrada);\n\n        // Consulta JPQL\n        TypedQuery&lt;Peli&gt; query = em.createQuery(\n                \"SELECT p FROM Peli p WHERE p.anyo &gt;= :anio\", Peli.class);\n        query.setParameter(\"anio\", 2000);\n        List&lt;Peli&gt; pelisRecientes = query.getResultList();\n        pelisRecientes.forEach(System.out::println);\n        tx.commit();\n\n    } catch (Exception e) {\n        if (tx != null &amp;&amp; tx.isActive()) {\n            tx.rollback();\n        }\n        e.printStackTrace();\n    } finally {\n        em.close();\n    }\n}\n</code></pre> <p>}     ```</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#29-ventajas-de-jpa","title":"2.9 Ventajas de JPA","text":"Ventaja Descripci\u00f3n Portabilidad Puedes cambiar entre diferentes implementaciones JPA Est\u00e1ndar Las anotaciones JPA son reconocidas universalmente Integraci\u00f3n Mejor compatibilidad con Spring y otros frameworks Mantenimiento C\u00f3digo m\u00e1s limpio y f\u00e1cil de mantener Futuro JPA es el est\u00e1ndar actual de la industria <p>Mejores pr\u00e1cticas</p> <p>- Siempre usa anotaciones JPA en lugar de archivos XML</p> <p>- Maneja las transacciones correctamente</p> <p>- Usa <code>@Entity</code> y <code>@Table</code> para el mapeo de entidades</p> <p>- Define <code>@Id</code> y estrategia de generaci\u00f3n apropiada</p> <p>- Cierra recursos en bloques finally o usa try-with-resources</p> <p>Atenci\u00f3n</p> <p>Esta implementaci\u00f3n mantiene la compatibilidad con el patr\u00f3n Singleton para SessionFactory/EntityManagerFactory, asegurando una \u00fanica instancia en la aplicaci\u00f3n.</p> <p>El proyecto completo lo puedes descargar aqui demo1</p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/","title":"3. Mapeo de Entidades con JPA y Hibernate","text":"<p>Una vez estudiada la configuraci\u00f3n inicial, es momento de mapear nuestras entidades y relaciones usando JPA. Partiendo del modelo relacional, usaremos la entidad <code>Peli</code>:</p> <pre><code>CREATE TABLE `Peli` (\n  `idPeli` int(11) NOT NULL AUTO_INCREMENT,\n  `titulo` varchar(45) NOT NULL,\n  `anyo` varchar(45) NOT NULL,\n  `director` varchar(45) NOT NULL,\n  PRIMARY KEY (`idPeli`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n</code></pre> <p>Aqu\u00ed hay un script DBCine.sql con el que trabajar. </p> <p>Estructura del Proyecto <pre><code>JPAhibernate/\n\u251c\u2500\u2500 src/main/java/\n\u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2514\u2500\u2500 Peli.java                 # Entidad principal\n\u2502   \u251c\u2500\u2500 util/\n\u2502   \u2502   \u2514\u2500\u2500 JpaUtil.java              # Utilidad para JPA\n\u2502   \u2514\u2500\u2500 Main.java                     # Aplicaci\u00f3n principal\n\u251c\u2500\u2500 src/main/resources/\n\u2502   \u251c\u2500\u2500 META-INF/\n\u2502   \u2502   \u2514\u2500\u2500 persistence.xml           # Configuraci\u00f3n JPA\n\u2502   \u2514\u2500\u2500 logback.xml                   # Configuraci\u00f3n de logs\n\u2514\u2500\u2500 pom.xml                          # Dependencias Maven\n</code></pre></p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#31-configuracion-de-dependencias","title":"3.1. Configuraci\u00f3n de dependencias","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#pomxml","title":"pom.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.cipfpcheste.dam2&lt;/groupId&gt;\n    &lt;artifactId&gt;JPAhibernate&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;JPAhibernate&lt;/name&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;\n        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;\n        &lt;junit.version&gt;5.11.0&lt;/junit.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Conector MySQL --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n            &lt;version&gt;9.4.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Hibernate ORM --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n            &lt;version&gt;7.1.2.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Jakarta Persistence API --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n            &lt;version&gt;3.2.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Logging con Logback --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n            &lt;version&gt;1.5.19&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#explicacion-de-dependencias","title":"Explicaci\u00f3n de Dependencias","text":"Dependencia Versi\u00f3n Prop\u00f3sito <code>mysql-connector-j</code> 9.4.0 Conector oficial para MySQL <code>hibernate-core</code> 7.1.2.Final Implementaci\u00f3n ORM de Hibernate <code>jakarta.persistence-api</code> 3.2.0 API est\u00e1ndar de JPA (Jakarta) <code>logback-classic</code> 1.5.19 Sistema de logging avanzado"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#32-archivos-de-configuracion","title":"3.2.  Archivos de Configuraci\u00f3n","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#persistencexml","title":"persistence.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence version=\"3.2\"\n             xmlns=\"https://jakarta.ee/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence\n             https://jakarta.ee/xml/ns/persistence/persistence_3_2.xsd\"&gt;\n\n    &lt;persistence-unit name=\"cinePU\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n        &lt;description&gt;Unidad de persistencia para aplicaci\u00f3n Cine - Hibernate 7.1.2&lt;/description&gt;\n\n        &lt;!-- Proveedor Hibernate 7 --&gt;\n        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;\n\n        &lt;!-- Entidades --&gt;\n        &lt;class&gt;model.Peli&lt;/class&gt;\n\n        &lt;properties&gt;\n            &lt;!-- Conexi\u00f3n a Base de Datos - FORMATO NUEVO --&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.driver\"\n                      value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.url\"\n                      value=\"jdbc:mysql://localhost:3308/Cine1_V1?createDatabaseIfNotExist=true\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.user\" value=\"root\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.password\" value=\"root\"/&gt;\n\n            &lt;!-- Configuraci\u00f3n espec\u00edfica de Hibernate 7 --&gt;\n            &lt;property name=\"hibernate.dialect\"\n                      value=\"org.hibernate.dialect.MySQLDialect\"/&gt;\n            &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt;\n            &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt;\n\n            &lt;!-- NUEVAS PROPIEDADES HIBERNATE 7 --&gt;\n            &lt;property name=\"hibernate.connection.provider_disables_autocommit\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.session.events.log\" value=\"false\"/&gt;\n\n            &lt;!-- Pool de conexiones --&gt;\n            &lt;property name=\"hibernate.connection.pool_size\" value=\"5\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#propiedades-de-configuracion-clave","title":"Propiedades de Configuraci\u00f3n Clave","text":"Propiedad Valor Descripci\u00f3n <code>hibernate.dialect</code> <code>MySQLDialect</code> Dialecto SQL para MySQL <code>hibernate.hbm2ddl.auto</code> <code>update</code> Actualiza esquema autom\u00e1ticamente <code>hibernate.show_sql</code> <code>true</code> Muestra SQL en consola <code>hibernate.format_sql</code> <code>true</code> Formatea SQL para mejor legibilidad <code>hibernate.connection.pool_size</code> <code>5</code> Tama\u00f1o del pool de conexiones"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#logbackxml","title":"logback.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- Logs espec\u00edficos para Hibernate 7 --&gt;\n    &lt;logger name=\"org.hibernate\" level=\"INFO\"/&gt;\n    &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/&gt;\n    &lt;logger name=\"org.hibernate.orm.jdbc.bind\" level=\"TRACE\"/&gt;\n    &lt;logger name=\"org.hibernate.stat\" level=\"DEBUG\"/&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#33-modelo-de-datos","title":"3.3.  Modelo de Datos","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#pelijava","title":"Peli.java","text":"<pre><code>package model;\n\nimport jakarta.persistence.*;\nimport java.io.Serializable;\n\n@Entity\n@Table(name = \"Peli\")\npublic class Peli implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idPeli;\n\n    @Column(name = \"titulo\", nullable = false, length = 100)\n    private String titulo;\n\n    @Column(name = \"anyo\", nullable = false)\n    private int anyo;\n\n    @Column(name = \"director\", nullable = false, length = 100)\n    private String elDirector;\n\n    // Constructores\n    public Peli() {}\n\n    public Peli(String titulo, int anyo, String elDirector) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.elDirector = elDirector;\n    }\n\n    // Getters y setters\n    public Long getIdPeli() {\n        return idPeli;\n    }\n\n    public void setIdPeli(Long idPeli) {\n        this.idPeli = idPeli;\n    }\n\n    public String getTitulo() {\n        return titulo;\n    }\n\n    public void setTitulo(String titulo) {\n        this.titulo = titulo;\n    }\n\n    public int getAnyo() {\n        return anyo;\n    }\n\n    public void setAnyo(int anyo) {\n        this.anyo = anyo;\n    }\n\n    public String getElDirector() {\n        return elDirector;\n    }\n\n    public void setElDirector(String elDirector) {\n        this.elDirector = elDirector;\n    }\n\n    @Override\n    public String toString() {\n        return \"Peli{\" +\n                \"idPeli=\" + idPeli +\n                \", titulo='\" + titulo + '\\'' +\n                \", anyo=\" + anyo +\n                \", director='\" + elDirector + '\\'' +\n                '}';\n    }\n}\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#anotaciones-jpa-explicadas","title":"Anotaciones JPA Explicadas","text":"Anotaci\u00f3n Uso Descripci\u00f3n <code>@Entity</code> Clase Marca la clase como entidad persistente <code>@Table</code> Clase Especifica el nombre de la tabla en BD <code>@Id</code> Campo Indica la clave primaria <code>@GeneratedValue</code> Campo Estrategia de generaci\u00f3n de IDs <code>@Column</code> Campo Mapea el campo a columna de BD <p>Informaci\u00f3n</p> <p>M\u00e1s informaci\u00f3n, aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#estrategia-de-generacion-de-ids","title":"Estrategia de Generaci\u00f3n de IDs","text":"<pre><code>@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long idPeli;\n</code></pre> <p>La estrategia <code>IDENTITY</code> usa la auto-incrementaci\u00f3n de MySQL para generar los IDs autom\u00e1ticamente.</p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#34-utilidades-jpa","title":"3.4.  Utilidades JPA","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#jpautiljava","title":"JpaUtil.java","text":"<pre><code>package util;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.Persistence;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class JpaUtil {\n    private static final String PERSISTENCE_UNIT_NAME = \"cinePU\";\n    private static EntityManagerFactory entityManagerFactory;\n\n    static {\n        initialize();\n    }\n\n    private static void initialize() {\n        try {\n            System.out.println(\"Inicializando Hibernate 7.1.2...\");\n\n            // Configuraci\u00f3n program\u00e1tica adicional si es necesaria\n            Map&lt;String, Object&gt; configOverrides = new HashMap&lt;&gt;();\n            configOverrides.put(\"hibernate.connection.autocommit\", \"false\");\n\n            entityManagerFactory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME, configOverrides);\n\n            System.out.println(\"EntityManagerFactory creado exitosamente con Hibernate 7\");\n            System.out.println(\"Metadata: \" + entityManagerFactory.getMetamodel().getEntities().size() + \" entidades cargadas\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error inicializando Hibernate 7: \" + e.getMessage());\n            e.printStackTrace();\n            throw new ExceptionInInitializerError(\"Fallo en inicializaci\u00f3n de Hibernate 7: \" + e.getMessage());\n        }\n    }\n\n    public static EntityManager getEntityManager() {\n        if (entityManagerFactory == null) {\n            initialize();\n        }\n        return entityManagerFactory.createEntityManager();\n    }\n\n    public static EntityManagerFactory getEntityManagerFactory() {\n        return entityManagerFactory;\n    }\n\n    public static void close() {\n        if (entityManagerFactory != null &amp;&amp; entityManagerFactory.isOpen()) {\n            entityManagerFactory.close();\n            System.out.println(\"EntityManagerFactory cerrado\");\n            entityManagerFactory = null;\n        }\n    }\n\n    public static boolean isInitialized() {\n        return entityManagerFactory != null &amp;&amp; entityManagerFactory.isOpen();\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#patron-singleton-para-entitymanagerfactory","title":"Patr\u00f3n Singleton para EntityManagerFactory","text":"<p>El <code>EntityManagerFactory</code> es un objeto pesado que debe crearse una sola vez en toda la aplicaci\u00f3n. Por eso usamos:</p> <ul> <li>Bloque est\u00e1tico: Se ejecuta al cargar la clase</li> <li>Singleton: Una \u00fanica instancia compartida</li> <li>Lazy initialization: Se crea solo cuando se necesita</li> </ul>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#ciclo-de-vida-de-entitymanager","title":"Ciclo de Vida de EntityManager","text":"<pre><code>// 1. Obtener EntityManager\nEntityManager em = JpaUtil.getEntityManager();\n\ntry {\n    // 2. Iniciar transacci\u00f3n\n    EntityTransaction tx = em.getTransaction();\n    tx.begin();\n\n    // 3. Operaciones JPA\n    em.persist(entidad);\n\n    // 4. Confirmar transacci\u00f3n\n    tx.commit();\n\n} finally {\n    // 5. CERRAR SIEMPRE el EntityManager\n    em.close();\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#35-aplicacion-principal","title":"3.5. Aplicaci\u00f3n Principal","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#mainjava","title":"Main.java","text":"<pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityTransaction;\nimport model.Peli;\nimport util.JpaUtil;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"=== HIBERNATE 7.1.2 - JPA PURO ===\");\n\n        EntityManager em = null;\n        EntityTransaction tx = null;\n\n        try {\n            // 1. Obtener EntityManager\n            em = JpaUtil.getEntityManager();\n            System.out.println(\" EntityManager obtenido - Hibernate 7.1.2\");\n\n            // 2. Verificar conexi\u00f3n\n            boolean connected = em.isOpen();\n            System.out.println(\" EntityManager abierto: \" + connected);\n\n            // 3. Iniciar transacci\u00f3n\n            tx = em.getTransaction();\n            tx.begin();\n            System.out.println(\"Transacci\u00f3n iniciada\");\n\n            // 4. Crear y persistir entidad\n            Peli pelicula = new Peli(\"Avatar: El sentido del agua\", 2022, \"James Cameron\");\n            System.out.println(\" Creando: \" + pelicula);\n\n            em.persist(pelicula);\n            em.flush(); // Forzar INSERT inmediato\n            System.out.println(\"Persistido con ID: \" + pelicula.getIdPeli());\n\n            // 5. Buscar para verificar\n            Peli recuperada = em.find(Peli.class, pelicula.getIdPeli());\n            System.out.println(\" Recuperado: \" + recuperada);\n\n            // 6. Consulta JPQL\n            Long count = em.createQuery(\"SELECT COUNT(p) FROM Peli p\", Long.class).getSingleResult();\n            System.out.println(\" Total de pel\u00edculas en BD: \" + count);\n\n            // 7. Confirmar transacci\u00f3n\n            tx.commit();\n            System.out.println(\" Transacci\u00f3n confirmada\");\n\n            System.out.println(\" HIBERNATE 7.1.2 FUNCIONANDO CORRECTAMENTE!\");\n\n        } catch (Exception e) {\n            System.err.println(\" ERROR: \" + e.getMessage());\n            if (tx != null &amp;&amp; tx.isActive()) {\n                tx.rollback();\n                System.out.println(\" Transacci\u00f3n revertida\");\n            }\n            e.printStackTrace();\n        } finally {\n            if (em != null &amp;&amp; em.isOpen()) {\n                em.close();\n                System.out.println(\" EntityManager cerrado\");\n            }\n            JpaUtil.close();\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#operaciones-jpa-demostradas","title":"Operaciones JPA Demostradas","text":"Operaci\u00f3n M\u00e9todo Descripci\u00f3n Create <code>em.persist()</code> Inserta nueva entidad Read <code>em.find()</code> Busca por ID JPQL <code>createQuery()</code> Consulta con lenguaje JPA Flush <code>em.flush()</code> Sincroniza con BD inmediatamente <p>Proyecto de ejemplo aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/","title":"4. Mapeando Relaciones","text":"<p>Como mencionamos en la introducci\u00f3n, analizaremos c\u00f3mo mapear los diferentes tipos de relaciones. Antes de empezar a discutir la cardinalidad de las relaciones, debemos considerar el significado de estas relaciones, y revisaremos el concepto de direccionalidad de las relaciones.</p> <ul> <li>Unidireccional \u2192 Diremos que una relaci\u00f3n es unidireccional cuando accedamos al objeto relacionado (componente) desde otro objeto (propietario). Por ejemplo, si montamos un motor en un coche, lo l\u00f3gico es que el propietario sea el coche, y desde \u00e9ste obtendremos el motor. En este caso, dentro del objeto Coche aparecer\u00e1 un objeto Motor, y Motor no tendr\u00e1 una existencia propia.</li> <li>Bidireccional \u2192 Son relaciones en las que los elementos relacionados suelen tener el mismo peso o entidad. Por ejemplo, un Grupo de un instituto y un Tutor. Desde un grupo tiene sentido conocer al tutor, y tambi\u00e9n podemos desde un profesor (el tutor) acceder al grupo que tutoriza. En este caso, dentro del objeto Grupo tenemos una referencia al objeto Tutor y viceversa.</li> </ul> <p>Aviso</p> <p>En este tipo de referencias, como puede deducirse, existe una recursi\u00f3n intr\u00ednseca. Por tanto, cuando gestionamos este tipo de relaciones bidireccionales, tenga mucho cuidado de no causar bucles, ya que incluso algo tan sencillo como imprimir puede hacer que nuestro programa se bloquee y aparezca la conocida <code>StackOverflowException</code>.</p> <p>A partir de ahora podr\u00edamos estudiar todas las representaciones con JPA.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#41-relaciones-uno-a-uno","title":"4.1. Relaciones Uno a Uno","text":"<p>Para la explicaci\u00f3n de los ejemplos, veremos el dise\u00f1o y la implementaci\u00f3n en la base de datos de cada caso y c\u00f3mo se ve en Hibernate. Para este ejemplo representaremos una relaci\u00f3n 1:1 entre Grupo y Profesor, donde puede verse que un Grupo tiene un Tutor, y un Tutor s\u00f3lo puede tutorizar un Grupo.</p> one to one <p>En primer lugar, la clase que es apuntada por la clave for\u00e1nea. Muy f\u00e1cil porque no necesitamos hacer nada.</p> <pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n@Entity\n@Table(name=\"Profesor\")\npublic class Profesor implements Serializable {\n\n    static final long serialVersionUID = 1L;\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private int idProfesor;\n\n    @Column\n    private String nombre;\n\n    public Profesor(String nombre) {\n        this.nombre = nombre;\n    }\n}\n</code></pre> <p>Y ahora, la clase que contiene la clave ajena. Aqu\u00ed debemos marcar que un <code>Grupo</code> necesita un <code>Profesor</code> como tutor. Ve\u00e1moslo:</p> <p><pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Grupo\")\npublic class Grupo implements Serializable {\n\n    static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long idGrupo;\n\n    @Column\n    private String nivel;\n\n    @Column\n    private String curso;\n\n    @Column\n    private int anyo;\n\n    @OneToOne(cascade = CascadeType.ALL)\n    @JoinColumn(\n            name=\"id_tutor\",\n            referencedColumnName = \"idProfesor\",\n            unique=true,\n            foreignKey = @ForeignKey(name = \"FK_GRP_TEACH\"))\n    private Profesor tutor;\n\n    public Grupo(String nivel, String curso, int anyo) {\n        this.nivel = nivel;\n        this.curso = curso;\n        this.anyo = anyo;\n    }\n\n}\n</code></pre> Tenga en cuenta que la clase <code>Grupo</code> contiene un campo llamado <code>tutor</code> de la clase <code>Profesor</code>, y:</p> <ul> <li><code>@OneToOne(cascade = CascadeType.ALL)</code> marcamos esta relaci\u00f3n como 1:1. Adem\u00e1s, especificamos el atributo cascada, que es el m\u00e1s importante. El cascading es la forma de decir que cuando realizamos alguna acci\u00f3n sobre la entidad objetivo (<code>Grupo</code>), la misma acci\u00f3n se aplicar\u00e1 a la entidad asociada (<code>Profesor</code>). Revisamos las opciones m\u00e1s relevantes: </li> <li><code>CascadeType.ALL</code> propaga todas las operaciones. La misma operaci\u00f3n que realizamos en el objetivo se realizar\u00e1 en el asociado. </li> <li><code>CascadeType.PERSIST</code> propaga s\u00f3lo la operaci\u00f3n de persistencia en la base de datos (guardar). </li> <li><code>CascadeType.SAVE_UPDATE</code> es de Hibernate, no de JPA, y propaga el m\u00e9todo <code>saveOrUpdate()</code>. Es muy similar a persisto. </li> <li><code>CascadeType.REMOVE</code> o <code>CascadeType.DELETE</code> propaga la eliminaci\u00f3n de entidades. Tenga mucho cuidado con esta opci\u00f3n para evitar perder datos.</li> <li>En el <code>@JoinColumn</code> establecemos: </li> <li>el nombre de la columna en nuestra base de datos </li> <li>el nombre de la columna referenciada en la entidad objetivo <code>Profesor</code> </li> <li><code>unique=true</code> para asegurar que la relaci\u00f3n es 1:1 (un profesor no puede estar relacionado con ning\u00fan otro grupo) </li> <li>[opcional] para establecer el nombre de la restricci\u00f3n de clave for\u00e1nea, en caso de que desee cambiarlo o eliminarlo en operaciones futuras.</li> </ul> <p>M\u00e1s informaci\u00f3n en la siguiente webbaeldung</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#411-uno-a-uno-bidireccional","title":"4.1.1. Uno a Uno bidireccional","text":"<p>Si queremos almacenar en Profesor los grupos que est\u00e1 tutorizando, necesitamos a\u00f1adir una referencia al Grupo. Como hemos hecho la clave for\u00e1nea en Grupo, ser\u00e1 muy f\u00e1cil:</p> <pre><code>@OneToOne(mappedBy= \"tutor\")\nprivate Grupo elGrupo;\n</code></pre> <p>Con <code>mappedBy=\"tutor\"</code> estamos diciendo que en la clase <code>Grupo</code> existe un campo llamado <code>tutor</code> con toda la informaci\u00f3n sobre la relaci\u00f3n. Tenga en cuenta que no se a\u00f1adir\u00e1n campos aadicionales a <code>Profesor</code>, porque la informaci\u00f3n sobre la relaci\u00f3n se encuentra en la tabla <code>Grupo</code>.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#42-uno-a-muchos","title":"4.2. Uno a Muchos","text":"<p>Para esta explicaci\u00f3n empezaremos con el siguiente modelo, en el que un Libro tiene un Autor que lo ha escrito, y un Autor puede haber escrito varios Libros. En el esquema relacional, la relaci\u00f3n es desde <code>idAutor</code> en Libros, que es clave for\u00e1nea en la tabla Autor (ID).</p> one to many <p>Primero, podemos decidir qui\u00e9n es el propietario de la relaci\u00f3n. Realmente no importa, pero en varios dise\u00f1os es muy claro, por ejemplo entre <code>Estudiante</code> y <code>Email</code>, donde obviamente el propietario es <code>Estudiante</code>. Normalmente deber\u00eda ser la clase con cardinalidad muchos el propietario. Veamos el ejemplo.</p> <p><pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n\n@Entity\n@Table(name=\"libro\")\npublic class Libro implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idlibro;\n\n    @Column\n    private String titulo;\n\n    @Column\n    private String tipo;\n\n    @ManyToOne(cascade = CascadeType.PERSIST)\n    @JoinColumn(name = \"idautor\",\n            foreignKey = @ForeignKey(name = \"FK_LIB_AUT\"))\n    private Autor elAutor;\n\n    public Libro(String titulo, String tipo, Autor elAutor) {\n        this.titulo = titulo;\n        this.tipo = tipo;\n        this.elAutor = elAutor;\n    }\n}\n</code></pre> En este ejemplo, un <code>Libro</code> tiene un autor (\u00fanico). Lo implementamos almacenando una referencia a un objeto Autor, llamado <code>elAutor</code> dentro de nuestro Libro. Debemos escribir la informaci\u00f3n de la relaci\u00f3n en este campo:</p> <ul> <li>Debemos marcar este campo como <code>@ManyToOne</code>, porque Libro est\u00e1 al lado de los muchos de la relaci\u00f3n (recuerde que un Autor puede escribir varios Libros)</li> <li>La clave for\u00e1nea ser\u00e1 anotada con la etiqueta <code>@JoinColumn</code>, con varios atributos: </li> <li>Puesto que <code>elAutor</code> es el punto inicial de la clave for\u00e1nea, que apunta a la tabla <code>Autor</code>, necesitamos decir el nombre de la clave primaria en esta clase. Este atributo es opcional pero es una buena opci\u00f3n para mejorar nuestro c\u00f3digo. </li> <li>Opcionalmente, podemos llamar la restricci\u00f3n de la clave for\u00e1nea, con un nombre bien estructurado, con el atributo <code>foreignKey</code></li> </ul> <pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.util.Set;\n@Data\n@NoArgsConstructor\n@Entity\n@Table(name=\"autor\")\npublic class Autor implements Serializable{\n\n    @Serial\n    private static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private Long idautor;\n\n    @Column\n    private String nombre;\n\n    @Column\n    private String nacionalidad;\n\n    @OneToMany(mappedBy=\"elAutor\",\n            cascade=CascadeType.PERSIST,\n            fetch = FetchType.LAZY)\n    private Set&lt;Libro&gt; losLibros;\n\n    public Autor(String nombre, String nacionalidad, Set&lt;Libro&gt; losLibros) {\n        this.nombre = nombre;\n        this.nacionalidad = nacionalidad;\n        this.losLibros = losLibros;\n    }\n}\n</code></pre> <p>La clase <code>Autor</code> est\u00e1 en el lado un, y esto significa que puede escribir muchos <code>Libros</code>. Por esta raz\u00f3n, almacenamos todos los libros que ha escrito en un 'Set' de libros. Las anotaciones ser\u00e1n:</p> <ul> <li>Puesto que un Autor puede escribir muchos libros, marcamos el Set de libros como <code>@OneToMany</code>. Como hemos escrito la especificaci\u00f3n de la relaci\u00f3n en Libro, podr\u00edamos decir que la relaci\u00f3n est\u00e1 mapeada en el campo <code>elAutor</code> dentro de la clase <code>Libro</code>, con <code>mappedBy=\"elAutor\"</code> f\u00e1cilmente.</li> </ul> <p>Decisi\u00f3n</p> <p>En lugar de almacenar libros en un Set, se pueden almacenar en una Lista. La principal diferencia es responder a esta pregunta: \u00bfes importante el orden?. Si respondes s\u00ed, debes utilizar una Lista. Si la respuesta es no, debes utilizar un Set.</p> <p>Espacio</p> <p>La relaci\u00f3n <code>1:N</code> que hemos explicado es bidireccional. Esto significa que desde un Autor podemos obtener todos los Libros que ha escrito, y desde un Libro podemos obtener el Autor. </p> one to many bidirectional <p>Puede encontrar varias p\u00e1ginas y libros que explican las relaciones unidireccionales <code>1:N</code>. Esto significa que con este tipo de implementaci\u00f3n s\u00f3lo podemos viajar en una direcci\u00f3n. En este caso, debemos almacenar s\u00f3lo dentro de un Libro quien es el autor, porque el Libro es el propietario. Debemos eliminar el conjunto de libros en el autor para obtener una relaci\u00f3n unidireccional.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#421-tipo-de-carga-fetch","title":"4.2.1. Tipo de Carga Fetch","text":"<p>Este atributo suele aparecer cuando tenemos una relaci\u00f3n <code>1:N</code> o <code>N:M</code> en una clase que tiene una colecci\u00f3n de clases relacionadas (tambi\u00e9n puede especificarse con un <code>1:1</code> pero es menos com\u00fan). Cuando Hibernate carga un objeto, cargar\u00e1 sus atributos generales (nombre, nacionalidad, etc...), pero \u00bfqu\u00e9 ocurre con los Libros que ha escrito, los carga o no?</p> <ul> <li><code>DateType.EAGER</code> \u2192 Literalmente traducido como ansioso. No podemos esperar, y cuando se carga al Autor, Hibernate resolver\u00e1 la relaci\u00f3n y cargar\u00e1 todos los libros con todos los datos internos de cada libro. Tenemos todos los datos en el momento.</li> <li><code>DateType.LAZY</code> \u2192 Literalmente como perezoso (vago), pero m\u00e1s representativo como carga perezosa. Si cargamos al Autor, Hibernate s\u00f3lo carga los atributos propios del Autor, sin cargar sus Libros. Cuando intentamos acceder a sus libros desde nuestro programa, Hibernate se activa y los carga. Es decir, en modo LAZY, los datos se cargan cuando se necesitan.</li> </ul> <p>\u00bfQu\u00e9 haremos?</p> <p>\u00bfQu\u00e9 es mejor o peor? La respuesta no es sencilla, ya queAmbos tienen ventajas y desventajas:</p> <ul> <li> <p>En <code>EAGER</code> solo se realiza un acceso, mientras que en <code>LAZY</code> se realizan dos o m\u00e1s.</p> </li> <li> <p>En <code>EAGER</code> se cargan todos los datos, incluso los innecesarios; en <code>LAZY</code> solo se carga lo necesario.</p> </li> </ul> <p>El programador debe evaluar y equilibrar la cantidad de informaci\u00f3n requerida en un momento dado y el coste de acceso a la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#43-muchos-a-muchos","title":"4.3. Muchos a Muchos","text":"<p>En esta secci\u00f3n, finalizaremos con el \u00faltimo tipo de relaci\u00f3n que podemos encontrar en el modelo E/R: las relaciones muchos a muchos. Pueden aparecer otras relaciones con cardinalidades m\u00e1s altas, como las relaciones ternarias, pero, como se estudi\u00f3 en el primer a\u00f1o, todas ellas pueden modelarse con transformaciones binarias.</p> <p>Dentro de las relaciones binarias, podemos encontrar dos posibilidades:</p> <ul> <li> <p>Relaciones que simplemente indican la relaci\u00f3n (por ejemplo, que un personaje puede o no portar cierto tipo de arma en un juego de rol) o</p> </li> <li> <p>Relaciones que, adem\u00e1s de indicarla, a\u00f1aden nuevos atributos. Por ejemplo, un actor participa en una pel\u00edcula interpretando un tipo de papel: principal, secundario, etc.</p> </li> </ul> <p>En el modelo relacional, ambos casos se modelan como una nueva tabla (con o sin el atributo). Si nos encontramos en el segundo caso, se debe modelar una nueva tabla con los atributos que posee mediante una clase, por lo que la relaci\u00f3n \u00abN:M\u00bb entre dos tablas se convertir\u00e1 en \u00abdos relaciones uno a muchos 1:N y N:1\u00bb (actor-actuaci\u00f3n y actuaci\u00f3n-pel\u00edcula). Nos centraremos en el primer caso, ya que estamos listos para resolver el segundo.</p> <p>Mejora</p> <p>En la segunda parte, este tutorial explica c\u00f3mo crear N_M con atributos. Se recomienda implementar un ejemplo.</p> <p>Modelemos el caso t\u00edpico de un profesor que imparte varios m\u00f3dulos, que pueden ser impartidos por varios profesores. El esquema es el siguiente:</p> one to many bidirectional"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#431-muchos-a-muchos-con-4-clases","title":"4.3.1 Muchos a Muchos con 4 clases","text":"<p>Como podemos ver, se mantiene la tabla central t\u00edpica de la relaci\u00f3n <code>N:M</code>. Para implementar este caso vamos a necesitar 4 clase que se podr\u00e1n ver ahora:</p> <p>Las clases M\u00f3dulo y Profesor son las siguientes:</p> <p><pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Profesor\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Profesor {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idProfesor\")\n    private Long idProfesor;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @OneToMany(mappedBy = \"profesor\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;Docencia&gt; docencias = new ArrayList&lt;&gt;();\n}\n</code></pre> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Modulo\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Modulo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idModulo\")\n    private Long idModulo;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @OneToMany(mappedBy = \"modulo\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;Docencia&gt; docencias = new ArrayList&lt;&gt;();\n\n}\n</code></pre></p> <p>Esta es la especificaci\u00f3n m\u00e1s compleja, vamos:</p> <ul> <li>En ambas clases, la asignaci\u00f3n es <code>@OneToMany</code></li> <li>En ambos casos, indicamos c\u00f3mo gestionamos las operaciones en cascada (<code>cascade</code>) y la carga de objetos relacionados desde la otra clase (<code>fetch</code>).</li> <li>En la clase propietaria (<code>Profesor</code>), se asignar\u00e1 un <code>List&lt;Docencia&gt;</code> con la relaci\u00f3n que comenzar\u00e1 desde mi clase actual <code>Profesor</code> \u2192 <code>Docencia</code> \u2192 <code>Modulo</code> (el tipo base del Set).</li> </ul> <p>En este apartado como podemos ver s\u00f3lo hemos mapeado 2 entidades, Profesor y M\u00f3dulo. Estas se encuetran relacionadas por la tabla docencia. Puesto que esta tabla docencia no tiene m\u00e1s atributos, podr\u00edamos prescindir de crear una clase llamada <code>Docencia</code> de tal manera que mapearamos directamente. En este apartado vamos a ver con 4 clases y entender el motivo de realizar esta implementaci\u00f3n.</p> <p>Clase <code>DocenciaId</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Embeddable;\nimport java.io.Serializable;\nimport java.util.Objects;\n\n@Embeddable\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class DocenciaId implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @Column(name = \"idProfesor\")\n    private Long idProfesor;\n\n    @Column(name = \"idModulo\")\n    private Long idModulo;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DocenciaId that = (DocenciaId) o;\n        return Objects.equals(idProfesor, that.idProfesor) &amp;&amp;\n                Objects.equals(idModulo, that.idModulo);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(idProfesor, idModulo);\n    }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 necesitamos la clase DocenciaId?</p> <ul> <li>Porque la tabla Docencia tiene dos atributos como clave que son claves ajenas a su vez.</li> <li>JPA requiere que las claves primarias compuestas se representen como una clase separada que implemente Serializable.</li> <li><code>@Embeddable</code>marca una clase cuyas instancias se almacenan como parte de una entidad due\u00f1a, en lugar de tener su propia identidad en la base de datos.</li> </ul> <p>Una vez se dispone de la clase <code>DocenciaId</code>implementaremos la clase <code>Docencia</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.*;\n\n@Entity\n@Table(name = \"Docencia\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Docencia {\n\n    @EmbeddedId\n    private DocenciaId id;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @MapsId(\"idProfesor\")\n    @JoinColumn(name = \"idProfesor\")\n    private Profesor profesor;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @MapsId(\"idModulo\")\n    @JoinColumn(name = \"idModulo\")\n    private Modulo modulo;\n}\n</code></pre> <p>Info</p> <ul> <li><code>@EmbeddedId</code> A trav\u00e9s de este decorador indicamos la uniciddad de la clave primaria. Es m\u00e1s apto para consultas con JPL.</li> <li><code>@MapsId</code> se usa para indicar que una relaci\u00f3n JPA comparte la clave primaria con la entidad due\u00f1a. Espec\u00edficamente, mapea una relaci\u00f3n <code>@ManyToOne</code> o <code>@OneToOne</code> para que use la misma columna que forma parte de la clave primaria embebida.</li> </ul> <p>Este ser\u00eda un ejemplo de programa principal</p> <pre><code>import modelo.*;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.EntityTransaction;\nimport jakarta.persistence.Persistence;\nimport java.time.LocalDateTime;\n\npublic class Main{\n\n    public static void main(String[] args) {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"DocenciaConsultasPU\");\n        EntityManager em = emf.createEntityManager();\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n            tx.begin();\n\n            // Crear un nuevo profesor y asignarle m\u00faltiples m\u00f3dulos\n            Profesor nuevoProfesor = new Profesor();\n            nuevoProfesor.setNombre(\"Jose Manuel Romero\");\n            em.persist(nuevoProfesor);\n\n            // Asignar m\u00f3dulos al nuevo profesor\n            Modulo modulo1 = em.find(Modulo.class, 3L); // EIE\n            Modulo modulo2 = em.find(Modulo.class, 6L); // ACD\n\n\n\n            // Primera asignaci\u00f3n\n            Docencia docencia1 = new Docencia();\n            docencia1.setId(new DocenciaId(nuevoProfesor.getIdProfesor(), modulo1.getIdModulo()));\n            docencia1.setProfesor(nuevoProfesor);\n            docencia1.setModulo(modulo1);\n            em.persist(docencia1);\n\n            // Segunda asignaci\u00f3n\n            Docencia docencia2 = new Docencia();\n            docencia2.setId(new DocenciaId(nuevoProfesor.getIdProfesor(), modulo2.getIdModulo()));\n            docencia2.setProfesor(nuevoProfesor);\n            docencia2.setModulo(modulo2);\n            em.persist(docencia2);\n\n//            // Crear un nuevo alumno y agregarle ex\u00e1menes\n//            Alumno nuevoAlumno = new Alumno();\n//            nuevoAlumno.setNombre(\"Marta\");\n//            nuevoAlumno.setApellidos(\"Rodriguez Santos\");\n//            nuevoAlumno.setEdad(23);\n//            nuevoAlumno.setRepetidor(true);\n//            em.persist(nuevoAlumno);\n//\n//            // Agregar ex\u00e1menes al alumno\n//            Examen examen1 = new Examen();\n//            examen1.setFecha(LocalDateTime.of(2024, 1, 15, 10, 0));\n//            examen1.setNota(7.0);\n//            examen1.setAlumno(nuevoAlumno);\n//            examen1.setModulo(modulo1);\n//            em.persist(examen1);\n//\n//            Examen examen2 = new Examen();\n//            examen2.setFecha(LocalDateTime.of(2024, 1, 20, 9, 0));\n//            examen2.setNota(5.5);\n//            examen2.setAlumno(nuevoAlumno);\n//            examen2.setModulo(modulo2);\n//            em.persist(examen2);\n\n            tx.commit();\n            System.out.println(\"Inserci\u00f3n compleja completada:\");\n            System.out.println(\"- Profesor: \" + nuevoProfesor.getNombre() + \" (ID: \" + nuevoProfesor.getIdProfesor() + \")\");\n//            System.out.println(\"- Alumno: \" + nuevoAlumno.getNombre() + \" \" + nuevoAlumno.getApellidos());\n//            System.out.println(\"- M\u00f3dulos asignados: \" + modulo1.getNombre() + \", \" + modulo2.getNombre());\n//            System.out.println(\"- Ex\u00e1menes creados: 2\");\n\n        } catch (Exception e) {\n            if (tx.isActive()) {\n                tx.rollback();\n            }\n            e.printStackTrace();\n        } finally {\n            em.close();\n            emf.close();\n        }\n    }\n}\n</code></pre> <p>Puedes acceder a este proyecto desde aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#432-muchos-a-muchos-con-2-clases","title":"4.3.2 Muchos a Muchos con 2 clases","text":"<p>La diferencia con respecto al m\u00e9todo anterior es a nivel del clases y fichero <code>persistence.xml</code> en el cual se omitir\u00e1n las clases de las que no se hace uso, <code>Docencia</code> y <code>DocenciaId</code></p> <p>Clase <code>Modulo</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Modulo\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Modulo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idModulo\")\n    private Long idModulo;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @ManyToMany(mappedBy = \"modulos\")\n    private List&lt;Profesor&gt; profesores = new ArrayList&lt;&gt;();\n\n    @OneToMany(mappedBy = \"modulo\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;Examen&gt; examenes = new ArrayList&lt;&gt;();\n    @Override\n    public String toString() {\n        return \"Modulo{\" +\n                \"idModulo=\" + idModulo +\n                \", nombre='\" + nombre + '\\'' +\n                \", profesoresCount=\" + (profesores != null ? profesores.size() : 0) +\n                '}';\n    }\n}\n</code></pre> <p>Detalle de la clase Modulo</p> <ul> <li><code>@ManyToMany(mappedBy = \"modulos\")</code> <ul> <li><code>@ManyToMany</code>: Indica una relaci\u00f3n muchos-a-muchos entre <code>Modulo</code> y <code>Profesor</code></li> <li><code>mappedBy = \"modulos\"</code>: Esta entidad es el lado inverso de la relaci\u00f3n<ul> <li>El due\u00f1o de la relaci\u00f3n est\u00e1 en la clase <code>Profesor</code>, campo <code>modulos</code></li> <li>Esta clase es el lado esclavo/pasivo</li> </ul> </li> </ul> </li> <li>Responsabilidades:<ul> <li>NO crea la tabla intermedia (ya la crea el lado due\u00f1o)</li> <li>NO define <code>@JoinTable</code> (eso lo hace el lado due\u00f1o)</li> <li>Solo refleja la relaci\u00f3n que ya existe del otro lado</li> </ul> </li> </ul> <p>Clase <code>Profesor</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Profesor\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Profesor {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idProfesor\")\n    private Long idProfesor;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @ManyToMany\n    @JoinTable(\n            name = \"Docencia\",\n            joinColumns = @JoinColumn(name = \"idProfesor\"),\n            inverseJoinColumns = @JoinColumn(name = \"idModulo\")\n    )\n    private List&lt;Modulo&gt; modulos = new ArrayList&lt;&gt;();\n\n    @Override\n    public String toString() {\n        return \"Profesor{\" +\n                \"idProfesor=\" + idProfesor +\n                \", nombre='\" + nombre + '\\'' +\n                \", modulosCount=\" + (modulos != null ? modulos.size() : 0) +\n                '}';\n    }\n}\n</code></pre> <p>!! info \"Detalle de la clase Profesor\"</p> <pre><code>- `@JoinTable` en el lado due\u00f1o \n    - `name = \"Docencia\"`: Nombre de la tabla intermedia en la BD\n    - `joinColumns = @JoinColumn(name = \"idProfesor\")`:\n        - Columna que referencia al **due\u00f1o** de la relaci\u00f3n (Profesor)\n    - `inverseJoinColumns = @JoinColumn(name = \"idModulo\")`:\n        - Columna que referencia al otro lado de la relaci\u00f3n (Modulo)\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#relaciones-manytomany-lado-dueno-vs-lado-inverso","title":"Relaciones ManyToMany: Lado Due\u00f1o vs Lado Inverso","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#diferencias-entre-lado-dueno-y-lado-inverso","title":"Diferencias entre lado due\u00f1o y lado inverso","text":"Aspecto Lado Due\u00f1o (Profesor) Lado Inverso (Modulo) Anotaci\u00f3n <code>@ManyToMany</code> + <code>@JoinTable</code> <code>@ManyToMany(mappedBy)</code> Responsable Crea/define la tabla intermedia Solo refleja la relaci\u00f3n Persistencia Los cambios se persisten desde aqu\u00ed Los cambios NO se persisten directamente Consultas Puede hacer operaciones de join Opera a trav\u00e9s del lado due\u00f1o"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#estructura-de-la-tabla-docencia","title":"Estructura de la tabla <code>Docencia</code>","text":"<p>La configuraci\u00f3n con <code>@JoinTable</code> crea exactamente esta estructura en la base de datos:</p> <pre><code>CREATE TABLE Docencia (\n    idProfesor BIGINT,  -- FK a Profesor (joinColumns)\n    idModulo   BIGINT,  -- FK a Modulo (inverseJoinColumns)\n    PRIMARY KEY (idProfesor, idModulo)\n);\n</code></pre> <p>\u200b   </p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#ejemplo-practico-de-uso","title":"Ejemplo pr\u00e1ctico de uso","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#persistencia-siempre-desde-el-lado-dueno","title":"Persistencia (siempre desde el lado due\u00f1o)","text":"<pre><code>// CORRECTO - Desde el lado due\u00f1o\nProfesor profesor = new Profesor();\nModulo modulo = new Modulo();\nprofesor.getModulos().add(modulo);  // \u2190 Cambio en el lado due\u00f1o\nem.persist(profesor);\n\n// INCORRECTO - Desde el lado inverso  \nModulo modulo = new Modulo();\nProfesor profesor = new Profesor();\nmodulo.getProfesores().add(profesor);  // \u2190 NO se persistir\u00e1\nem.persist(modulo);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#consultas-funcionan-en-ambos-lados","title":"Consultas (funcionan en ambos lados)","text":"<pre><code>// Desde Profesor (lado due\u00f1o)\nProfesor p = em.find(Profesor.class, 1L);\nList&lt;Modulo&gt; modulos = p.getModulos();  // \u2190 Funciona\n\n// Desde Modulo (lado inverso)  \nModulo m = em.find(Modulo.class, 1L);\nList&lt;Profesor&gt; profesores = m.getProfesores();  // \u2190 Tambi\u00e9n funciona\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#reglas-importantes","title":"Reglas importantes","text":"<ol> <li>Solo un lado puede ser el due\u00f1o en relaciones bidireccionales</li> <li><code>mappedBy</code> siempre va en el lado inverso</li> <li>La persistencia debe hacerse desde el lado due\u00f1o</li> <li>Las consultas funcionan en ambos lados una vez persistido</li> <li>La tabla intermedia se maneja autom\u00e1ticamente por JPA</li> </ol> <p>M\u00e9todo <code>Main</code></p> <p><pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.EntityTransaction;\nimport jakarta.persistence.Persistence;\nimport modelo.Modulo;\nimport modelo.Profesor;\n\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"DocenciaConsultasPU\");\n        EntityManager em = emf.createEntityManager();\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n\n            tx.begin();\n\n            // Crear entidades\n            Profesor profesor = new Profesor();\n            profesor.setNombre(\"Mariano Faus Perez\");\n\n            Modulo modulo = new Modulo();\n            modulo.setNombre(\"BBDD\");\n\n            // Establecer relaci\u00f3n desde el LADO DUE\u00d1O\n            profesor.getModulos().add(modulo);\n\n            // Persistir\n            em.persist(profesor);\n            em.persist(modulo);\n\n            tx.commit();\n\n            // Consultar desde cualquier lado\n            List&lt;Modulo&gt; modulosDelProfesor = profesor.getModulos();  // \u2713 Funciona\n            List&lt;Profesor&gt; profesoresDelModulo = modulo.getProfesores();  // x No funciona porque no se sincroniza\n            System.out.println(\"Los modulos son:\");\n            modulosDelProfesor.forEach(System.out::println);\n            // No mostrara los profesores\n            System.out.println(\"Los profesores son:\");\n            profesoresDelModulo.forEach(System.out::println);\n        } catch (Exception e) {\n            if (tx.isActive()) {\n                tx.rollback();\n            }\n            e.printStackTrace();\n        } finally {\n            em.close();\n            emf.close();\n        }\n    }\n}\n</code></pre> Si lo ejecutamos vamos a ver que no muestra los profesores. El problema es que cuando persistes desde el lado due\u00f1o (Profesor), JPA no actualiza autom\u00e1ticamente el lado inverso (Modulo). Necesitas mantener sincronizadas ambas partes manualmente.</p> <p>Para ello vamos a definir un par de m\u00e9todos en cada una de las clases que nos permitir\u00e1n persistir los datos, de los cuales haremos uso:</p> <p>Clase <code>Modulo</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Modulo\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Modulo {\n\n....\n\n    public void anyadirProfesor(Profesor profesor) {\n        if (profesor != null) {\n            this.profesores.add(profesor);\n            profesor.getModulos().add(this); // Sincroniza el lado due\u00f1o\n        }\n    }\n\n    public void eliminarProfesor(Profesor profesor) {\n        if (profesor != null) {\n            this.profesores.remove(profesor);\n            profesor.getModulos().remove(this); // Sincroniza el lado due\u00f1o\n        }\n    }\n}\n</code></pre> <p>Clase <code>Profesor</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Profesor\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Profesor {\n\n...\n\n    public void anyadirModulo(Modulo modulo) {\n        if (modulo != null) {\n            this.modulos.add(modulo);\n            modulo.getProfesores().add(this); // Sincroniza el lado inverso\n        }\n    }\n\n    public void eliminarModulo(Modulo modulo) {\n        if (modulo != null) {\n            this.modulos.remove(modulo);\n            modulo.getProfesores().remove(this); // Sincroniza el lado inverso\n        }\n    }\n}\n</code></pre> <p>Ahora vamos a ver cuando usar <code>persist</code>o cuando usar <code>merge</code></p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#ejemplo-completo-de-persist-y-merge-en-main","title":"Ejemplo completo de <code>persist()</code> y <code>merge()</code> en Main","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#codigo-completo-para-tu-proyecto","title":"C\u00f3digo completo para tu proyecto","text":"<pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.EntityTransaction;\nimport jakarta.persistence.Persistence;\nimport modelo.Profesor;\nimport modelo.Modulo;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"DocenciaConsultasPU\");\n        EntityManager em = emf.createEntityManager();\n\n        try {\n            System.out.println(\"=== INICIO DEMOSTRACI\u00d3N PERSIST vs MERGE ===\\n\");\n\n            // Primero: mostrar estado actual\n            mostrarEstadoActual(em);\n\n            // Ejemplo 1: Crear nuevas entidades con PERSIST\n            Persist(em);\n\n            // Ejemplo 2: Modificar entidades existentes (evitando duplicados)\n            ModificacionManaged(em);\n\n            // Ejemplo 3: Usar MERGE con entidades detached\n            MergeDetached(em);\n\n            // Ejemplo 4: Consultas finales\n            mostrarEstadoFinal(em);\n\n            System.out.println(\"\\n=== FIN DEMOSTRACI\u00d3N ===\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error durante la demostraci\u00f3n: \" + e.getMessage());\n            e.printStackTrace();\n        } finally {\n            em.close();\n            emf.close();\n        }\n    }\n\n    /**\n     * Mostrar estado actual de las relaciones\n     */\n    private static void mostrarEstadoActual(EntityManager em) {\n        System.out.println(\" ESTADO ACTUAL DE LA BASE DE DATOS\");\n\n        EntityTransaction tx = em.getTransaction();\n        try {\n            tx.begin();\n\n            // Consultar todos los profesores y sus m\u00f3dulos\n            List&lt;Profesor&gt; profesores = em.createQuery(\"SELECT p FROM Profesor p\", Profesor.class).getResultList();\n\n            for (Profesor profesor : profesores) {\n                System.out.println(profesor.getNombre() + \" (ID: \" + profesor.getIdProfesor() + \")\");\n                System.out.println(\"M\u00f3dulos asignados:\");\n                if (profesor.getModulos().isEmpty()) {\n                    System.out.println(\"- Ninguno\");\n                } else {\n                    profesor.getModulos().forEach(modulo -&gt;\n                            System.out.println(\"      - \" + modulo.getNombre() + \" (ID: \" + modulo.getIdModulo() + \")\")\n                    );\n                }\n                System.out.println();\n            }\n\n            tx.commit();\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * EJEMPLO 1: PERSIST - Para entidades NUEVAS que no existen en la BD\n     */\n    private static void Persist(EntityManager em) {\n        System.out.println(\"1. USO DE PERSIST() - CREAR NUEVAS ENTIDADES\");\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n            tx.begin();\n\n            // Crear un nuevo profesor (entidad NUEVA)\n            Profesor nuevoProfesor = new Profesor();\n            nuevoProfesor.setNombre(\"Carlos Mart\u00ednez\");\n\n            // Crear un nuevo m\u00f3dulo (entidad NUEVA)\n            Modulo nuevoModulo = new Modulo();\n            nuevoModulo.setNombre(\"Blockchain\");\n\n            // USO CORRECTO DE PERSIST: para entidades NUEVAS\n            em.persist(nuevoProfesor);\n            em.persist(nuevoModulo);\n\n            // Crear relaci\u00f3n entre ellos\n            nuevoProfesor.anyadirModulo(nuevoModulo);\n\n            tx.commit();\n\n            System.out.println(\"   PERSIST exitoso:\");\n            System.out.println(\"      - Nuevo Profesor: \" + nuevoProfesor.getNombre() + \" (ID: \" + nuevoProfesor.getIdProfesor() + \")\");\n            System.out.println(\"      - Nuevo M\u00f3dulo: \" + nuevoModulo.getNombre() + \" (ID: \" + nuevoModulo.getIdModulo() + \")\");\n            System.out.println(\"      - Relaci\u00f3n establecida correctamente\\n\");\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * EJEMPLO 2: Modificaci\u00f3n de entidades MANAGED (EVITANDO DUPLICADOS)\n     */\n    private static void ModificacionManaged(EntityManager em) {\n        System.out.println(\"2. MODIFICACI\u00d3N DE ENTIDADES MANAGED (SIN DUPLICADOS)\");\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n            tx.begin();\n\n            // Obtener entidades EXISTENTES\n            Profesor profesor = em.find(Profesor.class, 1L); // Mariano Faus\n            // Buscar un m\u00f3dulo que NO est\u00e9 asignado a este profesor\n            Modulo moduloNoAsignado = encontrarModuloNoAsignado(em, profesor);\n\n            if (profesor != null &amp;&amp; moduloNoAsignado != null) {\n                // Modificar propiedades\n                String nombreOriginal = profesor.getNombre();\n                if (!nombreOriginal.contains(\"[Actualizado]\")) {\n                    profesor.setNombre(nombreOriginal + \" [Actualizado]\");\n                }\n\n                // Establecer relaci\u00f3n SOLO si no existe\n                if (!existeRelacion(profesor, moduloNoAsignado)) {\n                    profesor.anyadirModulo(moduloNoAsignado);\n\n                    tx.commit();\n\n                    System.out.println(\"   Modificaci\u00f3n exitosa:\");\n                    System.out.println(\"      - Profesor: \" + profesor.getNombre());\n                    System.out.println(\"      - Nuevo m\u00f3dulo agregado: \" + moduloNoAsignado.getNombre());\n                    System.out.println(\"      - No se necesit\u00f3 merge()\\n\");\n                } else {\n                    tx.rollback();\n                    System.out.println(\"     Relaci\u00f3n ya existe, no se realizaron cambios\\n\");\n                }\n            } else {\n                tx.rollback();\n                System.out.println(\"     No se encontraron entidades para modificar\\n\");\n            }\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * EJEMPLO 3: MERGE - Para entidades DETACHED (evitando duplicados)\n     */\n    private static void MergeDetached(EntityManager em) {\n        System.out.println(\"3.  USO DE MERGE() - ENTIDADES DETACHED\");\n\n        Profesor profesorDetached = null;\n\n        // Paso 1: Obtener entidad y cerrar transacci\u00f3n (se vuelve DETACHED)\n        EntityTransaction tx1 = em.getTransaction();\n        try {\n            tx1.begin();\n            profesorDetached = em.find(Profesor.class, 2L); // Anna Marto\n            tx1.commit();\n        } catch (Exception e) {\n            if (tx1.isActive()) tx1.rollback();\n            throw e;\n        }\n\n        // Ahora profesorDetached est\u00e1 DETACHED\n\n        EntityTransaction tx2 = em.getTransaction();\n        try {\n            tx2.begin();\n\n            // Buscar un m\u00f3dulo que NO est\u00e9 asignado a este profesor\n            Modulo moduloNoAsignado = encontrarModuloNoAsignado(em, profesorDetached);\n\n            if (moduloNoAsignado != null) {\n                // Modificar la entidad DETACHED\n                String nombreOriginal = profesorDetached.getNombre();\n                if (!nombreOriginal.contains(\"[Modificado]\")) {\n                    profesorDetached.setNombre(nombreOriginal + \" [Modificado]\");\n                }\n\n                // Agregar relaci\u00f3n SOLO si no existe\n                if (!existeRelacion(profesorDetached, moduloNoAsignado)) {\n                    profesorDetached.anyadirModulo(moduloNoAsignado);\n                }\n\n                // \u2705 USO CORRECTO DE MERGE: para entidades DETACHED\n                Profesor profesorReattached = em.merge(profesorDetached);\n\n                tx2.commit();\n\n                System.out.println(\"   MERGE exitoso:\");\n                System.out.println(\"      - Entidad DETACHED modificada y reattached\");\n                System.out.println(\"      - Nuevo nombre: \" + profesorReattached.getNombre());\n                if (moduloNoAsignado != null) {\n                    System.out.println(\"      - Nuevo m\u00f3dulo: \" + moduloNoAsignado.getNombre() + \"\\n\");\n                }\n            } else {\n                tx2.rollback();\n                System.out.println(\"   No hay m\u00f3dulos disponibles para asignar\\n\");\n            }\n\n        } catch (Exception e) {\n            if (tx2.isActive()) tx2.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * Mostrar estado final\n     */\n    private static void mostrarEstadoFinal(EntityManager em) {\n        System.out.println(\"4. ESTADO FINAL DE LA BASE DE DATOS\");\n\n        EntityTransaction tx = em.getTransaction();\n        try {\n            tx.begin();\n\n            // Consultar todos los profesores y sus m\u00f3dulos\n            List&lt;Profesor&gt; profesores = em.createQuery(\"SELECT p FROM Profesor p\", Profesor.class).getResultList();\n\n            for (Profesor profesor : profesores) {\n                System.out.println( profesor.getNombre() + \" (ID: \" + profesor.getIdProfesor() + \")\");\n                System.out.println(\"   M\u00f3dulos asignados (\" + profesor.getModulos().size() + \"):\");\n                profesor.getModulos().forEach(modulo -&gt;\n                        System.out.println(\"      - \" + modulo.getNombre() + \" (ID: \" + modulo.getIdModulo() + \")\")\n                );\n                System.out.println();\n            }\n\n            tx.commit();\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * M\u00e9todo auxiliar: Encontrar un m\u00f3dulo NO asignado a un profesor\n     */\n    private static Modulo encontrarModuloNoAsignado(EntityManager em, Profesor profesor) {\n        try {\n            // Obtener todos los m\u00f3dulos\n            List&lt;Modulo&gt; todosModulos = em.createQuery(\"SELECT m FROM Modulo m\", Modulo.class).getResultList();\n\n            // Buscar un m\u00f3dulo que NO est\u00e9 en la lista del profesor\n            for (Modulo modulo : todosModulos) {\n                if (!existeRelacion(profesor, modulo)) {\n                    return modulo;\n                }\n            }\n\n            // Si todos est\u00e1n asignados, devolver null\n            return null;\n\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * M\u00e9todo auxiliar: Verificar si existe relaci\u00f3n entre profesor y m\u00f3dulo\n     */\n    private static boolean existeRelacion(Profesor profesor, Modulo modulo) {\n        return profesor.getModulos().stream()\n                .anyMatch(m -&gt; m.getIdModulo().equals(modulo.getIdModulo()));\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#dependencias-necesarias-en-tus-entidades","title":"Dependencias necesarias en tus entidades","text":"<p>Aseg\u00farate de que tus entidades tengan los m\u00e9todos helper:</p> <p>En Profesor.java:</p> <pre><code>public void anyadirModulo(Modulo modulo) {\n    if (modulo != null &amp;&amp; !this.modulos.contains(modulo)) {\n        this.modulos.add(modulo);\n        modulo.getProfesores().add(this); // Sincronizar lado inverso\n    }\n}\n\n    // M\u00e9todo para verificar si tiene un m\u00f3dulo\n    public boolean tieneModulo(Long idModulo) {\n        return this.modulos.stream()\n                .anyMatch(modulo -&gt; modulo.getIdModulo().equals(idModulo));\n    }\n</code></pre> <p>En Modulo.java:</p> <pre><code>public void anyadirProfesor(Profesor profesor) {\n    if (profesor != null &amp;&amp; !this.profesores.contains(profesor)) {\n        this.profesores.add(profesor);\n        profesor.getModulos().add(this); // Sincronizar lado due\u00f1o\n    }\n}\n</code></pre> <p>Este c\u00f3digo puedes agregarlo directamente a tu proyecto y ejecutarlo. Te mostrar\u00e1 ejemplos pr\u00e1cticos de cu\u00e1ndo usar <code>persist()</code> vs <code>merge()</code> con casos reales de tu base de datos.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#explicacion-persist-vs-merge-en-jpa","title":"Explicaci\u00f3n: <code>persist()</code> vs <code>merge()</code> en JPA","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#conceptos-fundamentales","title":"Conceptos Fundamentales","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#estado-de-las-entidades-jpa","title":"Estado de las Entidades JPA","text":"Estado Descripci\u00f3n Contexto TRANSIENT Entidad nueva, no asociada a la BD Sin ID MANAGED Entidad gestionada por JPA En Persistence Context DETACHED Entidad desconectada Fuera del Persistence Context REMOVED Entidad marcada para eliminar En proceso de borrado"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#persist-para-entidades-nuevas","title":"PERSIST() - Para entidades NUEVAS","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#cuando-usar-persist","title":"\u00bfCu\u00e1ndo usar <code>persist()</code>?","text":"<pre><code>// \u2705 CASOS CORRECTOS para PERSIST:\n\n// 1. Entidad completamente nueva\nProfesor nuevo = new Profesor();\nnuevo.setNombre(\"Nuevo Profesor\");\nem.persist(nuevo); // \u2705\n\n// 2. Primera vez que se guarda en BD\nModulo modulo = new Modulo();\nmodulo.setNombre(\"Nuevo M\u00f3dulo\");\nem.persist(modulo); // \u2705\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#comportamiento-de-persist","title":"Comportamiento de <code>persist()</code>","text":"<ul> <li>Asigna ID autom\u00e1ticamente (si es <code>@GeneratedValue</code>)</li> <li>Convierte entidad TRANSIENT \u2192 MANAGED</li> <li>NO inmediato en BD (hasta commit/flush)</li> <li>Lanza excepci\u00f3n si la entidad ya existe</li> </ul>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#merge-para-entidades-existentes-o-detached","title":"MERGE() - Para entidades EXISTENTES o DETACHED","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#cuando-usar-merge","title":"\u00bfCu\u00e1ndo usar <code>merge()</code>?","text":"<p>java</p> <pre><code>// \u2705 CASOS CORRECTOS para MERGE:\n\n// 1. Entidades DETACHED (fuera del contexto)\nProfesor detached = obtenerProfesorDeServicioExterno();\ndetached.setNombre(\"Modificado\");\nem.merge(detached); // \u2705\n\n// 2. Entidades de otras capas/servicios\nProfesor profesor = servicioExterno.obtenerProfesor(1L);\nem.merge(profesor); // \u2705\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#comportamiento-de-merge","title":"Comportamiento de <code>merge()</code>","text":"<ul> <li>Devuelve copia MANAGED de la entidad</li> <li>Sincroniza cambios con la BD</li> <li>No modifica la entidad original (si es DETACHED)</li> <li>\u00datil en aplicaciones web/multicapa</li> </ul>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#casos-comunes-de-error","title":"CASOS COMUNES DE ERROR","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#error-1-usar-persist-en-entidades-existentes","title":"Error 1: Usar <code>persist()</code> en entidades existentes","text":"<p>java</p> <pre><code>Profesor existente = em.find(Profesor.class, 1L);\nem.persist(existente); // \u274c Lanza excepci\u00f3n!\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#error-2-usar-merge-innecesariamente","title":"Error 2: Usar <code>merge()</code> innecesariamente","text":"<p>java</p> <pre><code>Profesor managed = em.find(Profesor.class, 1L);\nmanaged.setNombre(\"Nuevo nombre\");\nem.merge(managed); // \u274c INNECESARIO - ya est\u00e1 MANAGED\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#error-3-no-usar-merge-cuando-es-necesario","title":"Error 3: No usar <code>merge()</code> cuando es necesario","text":"<p>java</p> <pre><code>Profesor detached = obtenerProfesorDetached();\ndetached.setNombre(\"Cambio\");\n// em.merge(detached); // \u274c FALT\u00d3 - cambios no se guardan\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#regla-practica-decisoria","title":"REGLA PR\u00c1CTICA DECISORIA","text":"<pre><code>graph TD\n    A[\u00bfTengo una entidad?] --&gt; B{\u00bfExiste en BD?};\n    B --&gt;|NO| C[Usar PERSIST];\n    B --&gt;|S\u00cd| D{\u00bfEst\u00e1 MANAGED?};\n    D --&gt;|S\u00cd| E[Modificar directamente];\n    D --&gt;|NO| F[Usar MERGE];</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#flujo-de-trabajo-recomendado","title":"Flujo de trabajo recomendado","text":"<pre><code>public void guardarProfesor(Profesor profesor) {\n    EntityTransaction tx = em.getTransaction();\n    tx.begin();\n\n    if (profesor.getIdProfesor() == null) {\n        // Entidad NUEVA - usar PERSIST\n        em.persist(profesor);\n    } else {\n        // Entidad EXISTENTE - verificar estado\n        if (!em.contains(profesor)) {\n            // Entidad DETACHED - usar MERGE\n            profesor = em.merge(profesor);\n        }\n        // Si est\u00e1 MANAGED, modificar directamente\n    }\n\n    tx.commit();\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#diferencias-clave-resumen","title":"DIFERENCIAS CLAVE RESUMEN","text":"Aspecto <code>persist()</code> <code>merge()</code> Prop\u00f3sito Insertar nuevo Actualizar existente Entrada Entidad TRANSIENT Entidad DETACHED/MANAGED Salida Entidad MANAGED Copia MANAGED ID Lo genera Ya debe tenerlo BD INSERT UPDATE Rendimiento M\u00e1s r\u00e1pido M\u00e1s overhead"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#mejores-practicas","title":"MEJORES PR\u00c1CTICAS","text":"<ol> <li>Usa <code>persist()</code> solo para entidades nuevas</li> <li>Modifica directamente entidades MANAGED</li> <li>Usa <code>merge()</code> solo para entidades DETACHED</li> <li>Verifica el estado con <code>em.contains()</code></li> <li>Maneja el retorno de <code>merge()</code> (es una copia)</li> </ol>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#patron-recomendado","title":"PATR\u00d3N RECOMENDADO","text":"<pre><code>@Entity\npublic class ProfesorService {\n\n    @PersistenceContext\n    private EntityManager em;\n\n    public Profesor guardarOActualizar(Profesor profesor) {\n        if (profesor.getIdProfesor() == null) {\n            em.persist(profesor);\n            return profesor;\n        } else {\n            return em.merge(profesor);\n        }\n    }\n}\n</code></pre> <p>El proyecto de este segundo ejemplo lo tienes aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/","title":"5. Hibernate Query Language","text":"<p>La documentaci\u00f3n completa se puede encontrar aqu\u00ed:</p> <ul> <li>In spanish</li> <li>In english</li> </ul> <p>El lenguaje HQL (Hibernate Query Language) naci\u00f3 con el objetivo de preservar el modelo relacional, ya que es un superset de SQL (extensi\u00f3n de SQL que incluye SQL). La primera consideraci\u00f3n es que, por defecto, su funcionalidad es recuperar objetos de la base de datos, no tablas como hac\u00edamos en el lenguaje SQL a trav\u00e9s de <code>ResultSet</code>. Las consultas con HQL se realizar\u00e1n desde una interfaz Query, que ser\u00e1 el lugar donde especificaremos qu\u00e9 queremos obtener. Opcionalmente, podemos a\u00f1adir a la consulta los par\u00e1metros necesarios para su ejecuci\u00f3n, para evitar consultas con c\u00f3digo duro.</p> <p>En primer lugar, la consulta ser\u00e1 preparada. Al crearla, debemos tener en cuenta dos opciones, con cuatro combinaciones posibles:</p> <ul> <li>Devolver\u00e1 un resultado o m\u00e1s de uno y,</li> <li>Devolver\u00e1 el resultado encapsulado en objetos o de forma compuesta.</li> </ul> <p>Dependiendo de la respuesta obtenida, en el segundo paso escogeremos una de las cuatro opciones vistas a continuaci\u00f3n.</p> <pre><code>1 Query q=session.createQuery(\"HQL statement\");\n\n2.1 List&lt;Object&gt; resultsObjects=q.list();\n\n2.2 List&lt;Object []&gt;mixedresults=q.list();\n\n2.3 Object result=q.uniqueResult();\n\n2.4 Object[] result=q.uniqueResult();\n\n1. // process information obtained\n</code></pre> <ol> <li>In first option the query returns a collection of objects (several rows, on object in a row).</li> <li>Esta opci\u00f3n regresa a la colecci\u00f3n s composite of objects and another types: for example a Student en number of topics and number of teachers.</li> <li>Las opciones m\u00e1s recientes son, instead de la colecci\u00f3n, las respuestas a un object/composite.</li> </ol> <p>Apunte...</p> <ul> <li><code>session.createQuery</code> \u2192 permite escribir una consulta HQL, con o sin par\u00e1metros. </li> <li> <p><code>Query.list()</code> \u2192 obtiene todos los objetos (como una Lista) de la base de datos que satisfacen la consulta. </p> </li> <li> <p><code>Query.uniqueResult()</code> \u2192 obtiene un \u00fanico objeto de la base de datos.</p> </li> </ul> <p>Antes de los detalles, aqu\u00ed encontrar\u00e1s algunas ideas generales:</p> <ul> <li>Podemos eliminar el <code>Select*</code>, para indicar que queremos todos los atributos.</li> <li>Hay una sensibilidad media a las may\u00fasculas y min\u00fasculas: las palabras reservadas de HQL no distinguen entre may\u00fasculas y min\u00fasculas, pero las referencias a los objetos (sus nombres) s\u00ed lo hacen: no importa poner <code>From</code> o <code>fROm</code>, pero un <code>Student</code> no es lo mismo que un <code>student</code>. Se recomienda escribir las sentencias en min\u00fasculas para distinguirlas de las clases.</li> <li>Despu\u00e9s de <code>from</code>, aparece el nombre de una clase (o clases), no de tablas.</li> <li>Asignar sobrenombre es altamente recomendable. Podemos utilizar joins de forma similar a SQL.</li> <li>Luego puede aparecer el <code>where</code>, con sus condiciones similares a SQL.</li> <li>Las constantes de texto se cierran entre comillas simples.</li> <li>Podemos consultar colecciones que aparecen dentro de los objetos (por ejemplo, el conjunto de estudiantes de un profesor).</li> <li>No hay operador <code>limite</code>.</li> <li><code>order by</code> se utiliza de forma similar a SQL.</li> <li><code>group by</code> est\u00e1 permitido, y las funciones agregadas son: COUNT, AVG, SUM, MIN y MAX.</li> </ul>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#51-recuperando-objetos","title":"5.1. Recuperando objetos","text":"<p>A partir de ahora, los ejemplos se basan en este esquema Docencia</p> Docencia HQL <p>Consejo</p> <p>Ahora es un buen momento para intentar realizar un enfoque de ingenier\u00eda inversa para construir tu proyecto a partir de la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#52-consultas","title":"5.2. Consultas","text":""},{"location":"Unidad%203%20Hibernate/5_HQL.es/#521-obteniendo-objetos-simples","title":"5.2.1. Obteniendo objetos simples","text":"<p>Estas consultas son las que queremos recuperar un objeto o una colecci\u00f3n de \u00e9stos de la base de datos (una o m\u00e1s filas, en comparaci\u00f3n con ResultSet). Cada resultado es un \u00fanico objeto de una tabla de la base de datos. Se caracterizar\u00e1n porque la palabra Select puede no aparecer o simplemente indicar el sobrenombre de la clase que tenemos. Veamos los ejemplos.</p> <p>El siguiente ejemplo muestra a todos los estudiantes:</p> <pre><code>// complete and polite\nQuery&lt;Alumno&gt; q=laSesion.createQuery(\"Select a from Alumno a\");\n\n// ORO\n\n// in a quick way\nQuery&lt;Alumno&gt; q=laSesion.createQuery(\"from Alumno\");\n\n// quickest (without type)\nQuery q=laSesion.createQuery(\"from Alumno\");\n\nList&lt;Student&gt; losAlumnos=q.list();\n\nfor (Alumno alumno : losAlumnos) { \nSystem.out.println(alumno); \n}\n</code></pre> <p>Si queremos filtrar o buscar a cualquier estudiante, necesitamos utilizar la cl\u00e1usula <code>where</code>, como en una consulta SQL normal. Las expresiones pueden ser:</p> Where <p>Cuando el filtro <code>where</code> s\u00f3lo devuelve un objeto, podr\u00edamos almacenarlo en una lista y despu\u00e9s acceder a \u00e9l, pero es mejor obtener el objeto directamente, como sigue:</p> <p><pre><code>Query&lt;Alumno&gt; q = laSesion.createQuery(\"Select from Alumno a where a.idAlumno=1\");\nAlumno alumno = q.uniqueResult();\nSystem.out.println(alumno);\n</code></pre> ten en cuenta que creamos nuestra consulta con el operador diamante, indicando que devolver\u00e1 un estudiante. Entonces, la consulta devuelve obviamente al estudiante. La alternativa es realizar un casting del objeto devuelto de <code>uniqueResult</code>:</p> <pre><code>Query q = laSesion.createQuery(\"Select from Alumno a where a.idAlumno=1\");\nAlumno alumno = (Alumno)q.uniqueResult();\nSystem.out.println(alumno);\n</code></pre> <p>Atenci\u00f3n</p> <p>Tenga cuidado cuando recupere un objeto \u00fanico y la consulta devuelve varios. </p> <pre><code>Query q=laSesion.createQuery(\"Select from Student a where a.age=24\"); \nAlumno a=(Studente) q.uniqueResult(); \n// org.hibernate.NonUniqueResultException: query did not return a unique result: 2 \n</code></pre> <p>Cuando tenemos muchos resultados, no es conveniente recuperarlos todos a la vez, sino acceder a ellos de 10 en 10 o similar, al igual que las p\u00e1ginas de b\u00fasqueda de Google o Amazon. Podemos conseguirlo lanzando consultas m\u00e1s peque\u00f1as repetidamente, aplicando a la consulta:</p> <ul> <li><code>Q.setFirstResult(int start)</code> \u2192 indica el primer objeto (fila) a devolver.</li> <li><code>Q.setMaxResult(int howMany)</code> \u2192 indica cu\u00e1ntas filas devolver\u00e1.</li> </ul> <p>Con un algoritmo dise\u00f1ado adecuadamente, podemos realizar un bucle, desplazando el inicio en cada iteraci\u00f3n, increment\u00e1ndolo por el n\u00famero de filas recuperadas en la iteraci\u00f3n anterior. Esto implicar\u00eda muchas consultas peque\u00f1as en lugar de una grande.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#522-obteniendo-objetos-compuestos","title":"5.2.2. Obteniendo objetos compuestos","text":"<p>Si necesitamos obtener m\u00e1s (o menos) datos que un objeto entero, debemos hacerlo en la parte <code>select</code> de la cl\u00e1usula, pero cuando obtenemos los datos no los podemos almacenar en un Object. Por esta raz\u00f3n, y utilizando la propiedad de polimorfismo de Java, obtenemos los resultados en un array gen\u00e9rico de objetos. Por tanto, debemos ser muy cuidadosos con el tipo de cada celda, as\u00ed como el tama\u00f1o de este array, ya que estar\u00e1 fuertemente ligado a la consulta en s\u00ed. Veamos la siguiente consulta: Muestra el nombre y la edad de los estudiantes:</p> <pre><code>Query q = laSesion.createQuery(\"Select a.n\u00famero,a.edad from Alumno a\");\n\nList&lt;Object[]&gt; result = q.list();\n\nfor (Object[] objects : result) { \nSystem.out.print(\"Alumno: \"); \nfor (int i = 0; y &lt; objects.length; i++) { \nSystem.out.print(objects[i] + \" \"); \n} \nSystem.out.println();\n}\n</code></pre> <p>Ten en cuenta que si s\u00f3lo quieres imprimir la informaci\u00f3n, no es necesario realizar ning\u00fan trabajo extra, ya que (casi) todos los objetos se pueden convertir a String. Si quieres utilizarlos de otra manera, tenga mucho cuidado al convertirlos al tipo de dato adecuado.</p> <p>Colecciones</p> <p>Vamos a comprobar el nombre de los estudiantes y cu\u00e1ntos ex\u00e1menes han realizado. Esta informaci\u00f3n se encuentra en el conjunto de Ex\u00e1menes, as\u00ed que necesitaremos manipular esta colecci\u00f3n:</p> <pre><code>Query q = laSesion.createQuery(\"Select a.n\u00famero,size(a.ex\u00e1menes) from Alumno a\");\nList&lt;Object[]&gt; result = q.list();\n\nfor (Object[] alu : result) { \nSystem.out.println(\"Alumno: \" + alu[0] + \" has done \" + alu[1] + \" exams.\");\n}\n</code></pre> <p>Como puede ver, hemos aplicado la funci\u00f3n <code>size()</code> a la colecci\u00f3n para ver su tama\u00f1o. Por tanto, podemos aplicar:</p> <ul> <li><code>size(collection)</code> \u2192 recuperar el tama\u00f1o de la colecci\u00f3n.</li> <li><code>collection is empty</code> | <code>collection is not empty</code> \u2192 para determinar si est\u00e1 vac\u00eda. Es equivalente a comparar el tama\u00f1o con 0.</li> <li>Los operadores <code>in</code>, <code>all</code> se pueden combinar utilizando el operador <code>elements(collection)</code>.</li> </ul> <p>Como consulta avanzada, puede utilizar <code>exists</code> y <code>not exists</code> en sus consultas.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#53-parametros-y-consultas-nominales-con-nombre","title":"5.3. Par\u00e1metros y Consultas Nominales (con nombre)","text":"<p>Normalmente, la mayor\u00eda de las consultas necesitar\u00e1n algunos par\u00e1metros, generalmente para el filtrado de objetos en la cl\u00e1usula where. Los beneficios de parametrizar las consultas para evitar la inyecci\u00f3n de SQL o problemas similares se discutieron ya en la unidad anterior.</p> <p>La gesti\u00f3n de los par\u00e1metros se realiza de la misma forma que con las sentencias preparadas (<code>preparedStatements</code>), y se puede realizar mediante par\u00e1metros posicionales o nominales. Veamos algunos ejemplos:</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#531-parametros-posicionales","title":"5.3.1. Par\u00e1metros posicionales","text":"<p>Debemos a\u00f1adir espacios reservados dentro de nuestra consulta, pero en lugar de <code>?</code> a\u00f1adimos un n\u00famero despu\u00e9s del signo de interrogaci\u00f3n. Despu\u00e9s debemos configurar el par\u00e1metro seg\u00fan el n\u00famero de espacio reservado que hemos establecido antes, de la siguiente forma:</p> <pre><code>Query&lt;Alumno&gt; q = laSesion.createQuery(\"Select from Alumno a where a.edad=?1\");\nq.setParameter(1, 24);\nList&lt;Alumno&gt; losAlumnos = q.list();\n\nfor (Alumno alumno : losAlumnos) { \nSystem.out.println(alumno);\n}\n</code></pre> <p>Consejo</p> <p>Ten en cuenta que el m\u00e9todo <code>setParameter</code> est\u00e1 sobrecargado para establecer todo tipo de datos.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#532-parametros-nominales","title":"5.3.2. Par\u00e1metros nominales","text":"<p>Las posiciones est\u00e1n bien, pero si podemos indicar los par\u00e1metros de forma nominal, el programa ser\u00e1 mucho m\u00e1s legible. Los par\u00e1metros se indican con <code>:nombreDelParametro</code> y se asignar\u00e1n con el m\u00e9todo <code>setParameter(nombreDelParametro, valor)</code>, indicando el nombre del par\u00e1metro (sin los dos puntos):</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#533-consultas-con-nombre","title":"5.3.3. Consultas con nombre","text":"<p>Podemos escribir consultas en nuestros m\u00e9todos seg\u00fan las necesitemos. Sin embargo, es una buena pr\u00e1ctica crear las consultas m\u00e1s importantes o que prevemos que ser\u00e1n las m\u00e1s utilizadas junto con la misma clase,a trav\u00e9s del mecanismo que se presenta a continuaci\u00f3n. En esta secci\u00f3n creamos y etiquetamos nuestras consultas, dentro de una colecci\u00f3n de consultas, y despu\u00e9s las podemos llamar. Es como si cre\u00e1ramos una biblioteca de consultas.</p> <p>Fuera de la definici\u00f3n de la clase, se crear\u00e1 una colecci\u00f3n <code>@NamedQueries</code>, que contendr\u00e1 un array (indicado por claves) de elementos <code>@NamedQuery</code>, cada uno de ellos con un nombre y una definici\u00f3n de consulta.</p> <p>Para invocarlas, en lugar de crear un objeto <code>Query</code>, lo crearemos a trav\u00e9s de una <code>NamedQuery</code>, indicando su nombre y asignando par\u00e1metros, si los hubiere.</p> <p>En la clase Alumno:</p> <pre><code>@Entity\n@Table(name = \"Alumno\", catalogo = \"DocenciaConsultas\")\n@NamedQueries({ \n@NamedQuery(name=\"Repetidores\", \nquery=\"select from Student en where a.repeater=true \"), \n@NamedQuery(name=\"AlumnosEntre\", \nquery=\"select en Student en where a.age between :min and :max\"), \n@NamedQuery(name=\"AlumnosDescAge\", \nquery=\"select a from Student a order by a.age desc\")\n})\npublic class Alumno implements java.io.Serializable { \nstatic final long serialVersionUID=13L; \n...\n</code></pre> <p>Cuando queremos utilizarlo, en lugar de crear una <code>Query</code> debemos crear una <code>NamedQuery</code>, de la siguiente manera:</p> <pre><code>Query&lt;Alumno&gt; q = laSesion.createNamedQuery(\"Repetidores\", Alumno.class);\nSystem.out.println(\"Alumnos repetidores: \");\nList&lt;Alumno&gt; losAlumnos = q.list();\n\nq = laSesion.createNamedQuery(\"AlumnosEntre\", Alumno.class);\nq.setParameter(\"min\", 23);\nq.setParameter(\"max\", 28);\n\nq = laSesion.createNamedQuery(\"AlumnosDescAge\", Alumno.class);\nSystem.out.println(\"Alumnos de mayor a menor: \");\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#54-crud","title":"5.4. CRUD","text":"<p>Por \u00faltimo, analizaremos el resto de las operaciones CRUD. Cabe destacar que estas operaciones se pueden realizar directamente sobre los objetos, por lo que se explican como complementarias m\u00e1s que principales.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#541-crear-create-insert","title":"5.4.1. Crear (Create - Insert)","text":"<p>Si queremos insertar un nuevo objeto en la base de datos, es muy f\u00e1cil, como podemos recordar en las primeras secciones de esta unidad.</p> <pre><code>Alumno a=new Alumno();\na.setApellidos(\"Hamilton\");\na.setN\u00famero(\"Lewis\");\na.setEdad(42);\na.setRepetidor(false);\n\nlaSesion.persist(a);\n</code></pre> <p>Simplemente creamos un nuevo objeto, establecemos sus valores, mediante setters o constructor con todos los argumentos, y finalmente lo almacenamos en la base de datos con el m\u00e9todo <code>persist</code>. Puede utilizar <code>save</code> o <code>saveOrUpdate</code> indistintamente. Puede ver algunas diferencias entre ellos aqu\u00ed. Ambos ejecutan una instrucci\u00f3n <code>insert sql</code>.</p> <p>Al igual que SQL, podr\u00edamos insertar en una tabla con el resultado de una consulta, como sigue:</p> <pre><code>insert into class(properties) select_hql;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#542-actualizacion-update","title":"5.4.2. Actualizaci\u00f3n (Update)","text":"<p>Para cambiar el valor de una o m\u00e1s propiedades de un objeto, podemos cargar el objeto de la base de datos, cambiar los valores mediante los m\u00e9todos getters y despu\u00e9s guardar los cambios.</p> <pre><code>Alumno en = laSesion.get(Alumno.class, 7L);\na.setEdad(44);\na.setRepetidor(true);\n\nlaSesion.update(a);\nSystem.out.println(a);\n</code></pre> <p>Si queremos establecer una actualizaci\u00f3n masiva, que afecte a varios registros en la base de datos, podr\u00edamos utilizarlo de la misma manera que en SQL:</p> <pre><code>Query q=laSesion.createQuery(\"Update from Alumno a siete a.edad=a.edad+1 where a.repetidor=true\");\nint howMany=q.executeUpdate();\n\nSystem.out.println(howMany + \"alumnos actualizados\");\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#543-eliminacion-delete","title":"5.4.3. Eliminaci\u00f3n (Delete)","text":"<p>Como en las secciones anteriores, podr\u00edamos eliminar un \u00fanico objeto o conjunto de registros que cumplan una condici\u00f3n. En el caso de un \u00fanico objeto, necesitamos cargarlo y despu\u00e9s eliminarlo:</p> <pre><code>Alumno en = laSesion.get(Alumno.class, 7L);\nlaSesion.delete(a);\n\nSystem.out.println(a);\n</code></pre> <p>Ten en cuenta que el objeto permanece en memoria o hasta el final del m\u00e9todo, pero cuando la sesi\u00f3n se confirma, el objeto pasar\u00e1 a estar <code>detached</code>. El estado <code>detached</code> significa que este objeto est\u00e1 fuera de cualquier tipo de seguimiento. No tenemos la posibilidad de guardar o actualizar ese objeto de nuevo.</p> <p>Para realizar una eliminaci\u00f3n masiva, al igual que SQL:</p> <pre><code>Query q=laSesion.createQuery(\"delete from Alumno a where a.repetidor=true\");\nint howMany=q.executeUpdate();\n\nSystem.out.println(howMany + \"alumnos borrados\");\n</code></pre> <p>Consejo</p> <p>Recuerda estos consejo generales: </p> <ul> <li>Estas sentencias pueden contener par\u00e1metros (en sentencias que contienen la cl\u00e1usula <code>where</code>). </li> <li>El <code>where</code> es opcional, pero eliminar\u00e1 o actualizar\u00e1 todo si falta. </li> <li>Estas consultas se ejecutan todas utilizando <code>executeUpdate()</code>, para que cambien el estado de la base de datos, y devolver\u00e1 un entero con el n\u00famero de filas afectadas.</li> </ul> <p>Tienes que prestar atenci\u00f3n a las eliminaciones, ya que dependiendo de c\u00f3mo hemos definido las relaciones (eliminaciones en cascada, dejando filas hu\u00e9rfanas, etc.) pueden o no ocurrir, y arrojar <code>java.sql.SQLIntegrityConstraintViolationException</code>.</p> <p>Como comentario final en esta secci\u00f3n, recuerda lo que se ha dicho anteriormente: en la manipulaci\u00f3n de objetos (eliminaciones, modificaciones, etc.) tenemos herramientas suficientes para hacerlo sin consultas HQL. Estas consultas son m\u00e1s adecuadas para procesar grandes vol\u00famenes de informaci\u00f3n sin cargar esta informaci\u00f3n en nuestro programa para procesarla.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#55-apendice-estado-de-los-objetos","title":"5.5. Ap\u00e9ndice, Estado de los objetos","text":"<p>Como hemos dicho a lo largo de esta unidad, los objetos se cargan y controlan por el gestor de sesiones. Cada objeto podr\u00eda tener un estado dentro de la sesi\u00f3n, siendo interesante conocer todas las posibilidades. En esta imagen, puede ver todos los diferentes estados y el m\u00e9todo para cambiar el estado del objeto.</p> Object Status <ul> <li>transient \u2192 El objeto tiene identidad (existe en memoria), pero no tiene una identidad persistente, o clave primaria.</li> <li>persistente \u2192 El objeto ha estado marcado para ser guardado (persistido), y la identidad en memoria est\u00e1 relacionada con la identidad de la base de datos. Cuando cargamos un objeto de la base de datos, \u00e9ste es el estado inicial.</li> <li>detached \u2192 El objeto ha sido persistido recientemente, pero este contexto est\u00e1 cerrado, con el m\u00e9todo <code>detach()</code>. Las operaciones cuando est\u00e1 desconectado no se reflejar\u00e1n en la base de datos.</li> <li>removed \u2192 El objeto ha sido marcado para ser eliminado (pero todav\u00eda no se ha efectuado). Cuando la sesi\u00f3n se cierre, ser\u00e1 eliminado efectivamente, pero podemos volver a cargarlo y ponerlo en un contexto persistente.</li> </ul> <p>Puede obtener m\u00e1s informaci\u00f3n aqu\u00ed.</p>"}]}