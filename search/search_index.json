{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#desarrollo-de-aplicaciones-multiplataforma-acceso-a-datos","title":"Desarrollo de Aplicaciones Multiplataforma -- Acceso a Datos","text":""},{"location":"#2025-2026","title":"2025 - 2026","text":"<p>Imagen de Jensen Art Co en Pixabay</p> <p>Professor:</p> <ul> <li>Jos\u00e9 Manuel Romero Mart\u00ednez   -- jm.romeromartinez@edu.gva.es</li> </ul>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/","title":"\ud83d\udcda Simulacro de examen: Acceso a Datos","text":""},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#ejercicio-1-fichero-json-cvalencianajson","title":"\u2705 Ejercicio 1: Fichero JSON <code>cvalenciana.json</code>","text":"<p>Este fichero contiene una estructura de comunidades aut\u00f3nomas, provincias y ciudades.</p> <p>Objetivo</p> <p>En este ejercicio deber\u00e1s realizar lo siguiente:</p>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#clases-a-implementar","title":"\ud83d\udd39 Clases a implementar","text":"<ul> <li>Comunidad</li> <li>Atributos: <code>id</code>, <code>nombre</code></li> <li>Contendr\u00e1 un ArrayList de Provincias</li> <li>Provincia</li> <li>Atributos: <code>idProvincia</code>, <code>nombre</code></li> <li>Contendr\u00e1 un ArrayList de Ciudades</li> <li>Ciudad</li> <li>Atributos: <code>c\u00f3digo</code>, <code>nombre</code></li> </ul>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#operaciones-requeridas","title":"\ud83d\udd39 Operaciones requeridas","text":"<ol> <li>Obtener todos los municipios de la provincia de Valencia que comienzan por la letra A.</li> <li>Contar todos los municipios de la provincia de Castell\u00f3n que comienzan por la letra B.</li> <li> <p>Generar un fichero CSV (separador <code>;</code>) as\u00ed con la cabecera de la siguiente informaci\u00f3n:</p> <ul> <li>Nombre de provincia</li> <li>Cantidad de municipios en la provincia</li> <li>Nombre de municipio</li> </ul> </li> </ol>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#ejercicio-2-base-de-datos-cvalencianasql","title":"\u2705 Ejercicio 2: Base de datos <code>cvalenciana.sql</code>","text":"<p>Configuraci\u00f3n del proyecto</p> <ul> <li>Crear un proyecto Java con Maven llamado <code>comunidades</code>.</li> <li>Configurar dependencias: Lombok, MySQL, etc.</li> </ul>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#tareas","title":"\ud83d\udd39 Tareas","text":"<ol> <li>Crear una clase para conectar con el SGBD (no directamente con la BD). No debes conectar con una BD por defecto, sino s\u00f3lo al gestor.</li> <li>Listar las bases de datos del SGBD.</li> <li> <p>Conectar a la BD <code>comunidades_db</code> y:</p> <ul> <li>Obtener las tablas.</li> <li>Obtener la definici\u00f3n de las tablas.</li> <li>Generar una operaci\u00f3n INSERT (teniendo en cuenta los metadatos).</li> <li>Generar una operaci\u00f3n SELECT sobre cualquier tabla.</li> </ul> </li> </ol>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#ejercicio-3-hibernate-y-jpa","title":"\u2705 Ejercicio 3: Hibernate y JPA","text":"<p>Objetivo</p> <p>Implementa un proyecto Jakarta con las dependencias necesarias y las clases que representen las relaciones entre las 3 tablas de la BD.</p>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#operaciones-crud-sobre-la-tabla-poblaciones","title":"\ud83d\udd39 Operaciones CRUD sobre la tabla <code>poblaciones</code>","text":"<ul> <li>Crear nuevas poblaciones</li> <li>Modificar poblaciones</li> <li>Consultar poblaciones</li> <li>Eliminar poblaciones</li> </ul>"},{"location":"Simulacro%20examen%201%C2%AA%20Evaluaci%C3%B3n/Simulacro%20examen/#programa-principal","title":"\ud83d\udd39 Programa principal","text":"<ol> <li>Obtener todas las poblaciones de la provincia de Val\u00e8ncia.</li> <li>Modificar G\u00e1tova \u2192 G\u00c1TOVA.</li> <li>Eliminar Casinos.</li> <li>Mostrar nuevamente las poblaciones de Val\u00e8ncia.</li> </ol> <ul> <li>Fichero con los datos en json cavalenciana.json</li> <li>Fichero con los datos en de la base de datos cavalenciana.sql</li> <li>Soluci\u00f3n ejercicio1 json</li> <li>Soluci\u00f3n ejercicio2 BDA_Metadatos</li> <li>Soluci\u00f3n ejercicio3 BDA con JPA</li> </ul>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/","title":"1. Sistema de archivos","text":""},{"location":"Unidad%201%20Ficheros/1_File_System.es/#11-introduccion","title":"1.1. Introducci\u00f3n","text":"<p>En los inicios de la inform\u00e1tica, los archivos eran el \u00fanico mecanismo para almacenar informaci\u00f3n. Hoy en d\u00eda, los sistemas operativos gestionan los dispositivos de almacenamiento de modo casi transparente para el usuario. Sin entrar en detalles de las tecnolog\u00edas de almacenamiento subyacentes, nos ofrecen una abstracci\u00f3n mediante la cual s\u00f3lo debemos preocuparnos por dos conceptos: archivos y directorios.</p> <ul> <li>Archivo \u2192 contenedores de informaci\u00f3n (de todo tipo y formato).</li> <li>Directorios \u2192 organizadoras de archivos, y pueden contener archivos y otros directorios.</li> </ul> <p>Sobre la informaci\u00f3n (el contenido del archivo), encontramos una clasificaci\u00f3n cl\u00e1sica:</p> <ul> <li>Archivo de texto \u2192 la informaci\u00f3n se almacena de forma que puede verse o abrirse con cualquier editor de texto plano, como vino, nano o notepad.</li> <li>Archivo binario \u2192 la informaci\u00f3n se almacena codificada en formato binario. Como ya sabe el estudiante, cualquier tipo de informaci\u00f3n (texto, n\u00fameros, fotos, etc.) puede traducirse a 0 y 1. En nuestro caso (programadoras), podemos transformar objetos y variables de diferentes formas.</li> </ul> <p>Importante tener en cuenta que...</p> <ul> <li>Aunque almacenemos informaci\u00f3n en archivos de texto, aparece un nuevo concepto: estructura. Si organizamos la informaci\u00f3n de diferentes formas, podemos hablar de archivos csv, archivos xml, archivos json. Los archivos csv, xml y json son estructuras, porque al fin y al cabo, todos ellos son archivos de texto. </li> <li>La gente piensa que los archivos de texto son d\u00e9biles para almacenar informaci\u00f3n, pero no es cierto. Las t\u00e9cnicas criptogr\u00e1ficas nos ofrecen m\u00e9todos para almacenar informaci\u00f3n de forma segura dentro de archivos de texto. Por ejemplo, <code>htpasswd</code> en apache o <code>/etc/shadow</code> en sistemas Linux. Abajo pueden verse un ejemplo de clave p\u00fablica PGP, almacenada en un archivo de texto.</li> </ul> <pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Alice's OpenPGP certificate\nComment: https://www.ietf.org/id/draft-bre-openpgp-samples-01.html\n\nmDMEXEcE6RYJKwYBBAHaRw8BAQdArjWwk3FAqyiFbFBKT4TzXcVBqPTB3gmzlC/U\nb7O1u120JkFsaWNlIExvdmVsYWNlIDxhbGljZUBvcGVucGdwLmV4YW1wbGU+iJAE\n...\nDAAKCRDyMVUMT0fjjlnQAQDFHUs6TIcxrNTtEZFjUFm1M0PJ1Dng/cDW4xN80fsn\n0QEA22Kr7VkCjeAEC08VSTeV+QFsmz55/lntWkwYWhmvOgE=\n=iIGO\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#12-accediendo-al-sistema-de-archivos-en-java","title":"1.2. Accediendo al sistema de archivos en Java","text":"<p><code>Java</code> nos ofrece varias formas de acceder al sistema de archivos. Esta forma es independiente del dispositivo subyacente que almacena la informaci\u00f3n. El dispositivo puede ser un disco duro, un disco ssd, unidad \u00f3ptica, etc. La clase que nos ofrece esta posibilidad es la clase File. Repasaremos los principales aspectos de esta clase y despu\u00e9s revisaremos algunos ejemplos.</p> <ul> <li> <p>El constructor de la clase est\u00e1 sobrecargado, como la mayor\u00eda de las clases de Java. Podemos utilizar: </p> </li> <li> <p><code>File(File pariente, String child)</code> \u2192 Crea una nueva instancia de File a partir de un directorio padre abstracto y una cadena de directorio hijo. </p> </li> <li><code>File(String pathname)</code> \u2192 Crea una nueva instancia de File convirtiendo la cadena de directorio dato en un directorio abstracto. </li> <li><code>File(String parent, String child)</code> \u2192 Crea una nueva instancia de File a partir de una cadena de directorio padre y una cadena de directorio hijo. </li> <li> <p><code>File(URI uri)</code> \u2192 Crea una nueva instancia de File convirtiendo el file: URI dado en un directorio abstracto.</p> </li> <li> <p>Para acceder al archivo debemos usar un n\u00famero de ruta. \u00c9sta es la ruta, y tenemos dos posibilidades: </p> </li> <li> <p>Ruta absoluta \u2192 la ruta desde el directorio ra\u00edz del sistema hasta el archivo que queremos, comenzando con <code>/</code> en sistemas Linux o <code>letra:</code> en sistemas Windows. Recuerda utilizar <code>/</code> para separar carpetas en Linux y <code>\\\\</code> en Windows. No es un error, ya que la barra invertida es un s\u00edmbolo con un significado propio, debemos escaparla, duplic\u00e1ndola para obtener el significado que queremos. </p> </li> <li>Ruta relativa \u2192 suponemos que el archivo que queremos se encuentra en la misma carpeta que el proyecto/programa que estamos ejecutando. En este caso, s\u00f3lo proporcionamos el nombre del archivo, sin ninguna carpeta al principio de la ruta.</li> </ul> <pre><code>// absolute paths\nFile f=new File(\"/home/manu/texto.md\") // Linux\nFile f=new File(\"C:\\\\Usuarios\\\\manu\\\\Dektop\\\\texto.md\") // Windows\n...\n// relative paths\nFile f=new File(\"texto.md\") // Linux\nFile f=new File(\"docs\\texto.md\") // Windows\n</code></pre> <ul> <li>La misma clase <code>File</code> se utiliza para acceder tanto a un archivo regular como a un directorio. Es tarea del programador diferenciarlos mediante los m\u00e9todos de archivo, as\u00ed como comprobar si un archivo existe. Para ello podemos utilizar varios m\u00e9todos como: </li> <li><code>boolean exists()</code> \u2192 devuelve true si el objeto de archivo existe y false de lo contrario. </li> <li><code>boolean isFile()</code> y <code>isDirectory()</code> \u2192 devuelve true si el objeto es un archivo regular o un directorio. Obviamente, aquestos m\u00e9todos son exclusivos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#13-creando-archivos","title":"1.3. Creando archivos","text":"<p>Si queremos crear una carpeta o un archivo regular, podemos utilizar estos m\u00e9todos:</p> <ul> <li><code>boolean createNewFile()</code> \u2192 Crea de forma at\u00f3mica un nuevo archivo vac\u00edo con el nombre especificado si y s\u00f3lo si un archivo con ese nombre todav\u00eda no existe.</li> <li><code>static FilecreateTempFile(String prefijo, String suffix)</code> \u2192 Crea un archivo vac\u00edo en el directorio temporal por defecto, utilizando el prefijo y el sufijo especificados para generar su nombre.</li> <li><code>boolean mkdir()</code> \u2192 Crea el directorio con el nombre especificado.</li> <li><code>boolean mkdirs()</code> \u2192 Crea el directorio con el nombre especificado, incluyendo cualquier directorio padre necesario pero que no exista.</li> <li><code>boolean renameTo(File dest)</code> \u2192 Cambia el nombre del archivo especificado.</li> <li><code>boolean delete()</code> \u2192 Elimina el archivo o directorio especificado.</li> </ul> <p>Atenci\u00f3n</p> <ul> <li>En las secciones siguientes estudiaremos c\u00f3mo crear archivos cuando guardamos contenido. En otras palabras, no es necesario crear el archivo ad hoc y luego rellenarlo. Hay mecanismos para crear el archivo de forma automatizada. </li> <li>La diferencia entre mkdir y mkdirs es que la segunda opci\u00f3n crear\u00e1 todos los directorios entre el sistema de archivos ra\u00edz y el directorio actual, mientras que la primera requiere que la ruta ya exista.</li> </ul>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#14-pidiendo-propiedades-del-archivo","title":"1.4. Pidiendo propiedades del archivo","text":"<p>Normalmente abrimos archivos para escribir o leer su contenido, pero a veces necesitamos pedir las propiedades del archivo, como el tama\u00f1o, los permisos, etc. La clase File nos ayudar\u00e1 de nuevo.</p> <p>Informaci\u00f3n general:</p> <ul> <li><code>boolean exists()</code> \u2192 Comprueba si el archivo o directorio indicado para esta ruta abstracta existe.</li> <li><code>long lastModified()</code> \u2192 Devuelve el tiempo en que se modific\u00f3 por \u00faltima vez el archivo indicado por esta ruta abstracta.</li> <li><code>long length()</code> \u2192 Devuelve el tama\u00f1o del archivo indicado para esta ruta abstracta.</li> </ul> <p>Informaci\u00f3n sobre permisos. Esta informaci\u00f3n es la misma que el usuario puede obtener con <code>ls -la</code> en el formato de <code>chmod</code>:</p> <ul> <li><code>boolean canExecute()</code> \u2192 Comprueba si la aplicaci\u00f3n puede ejecutar el archivo indicado por esta ruta abstracta.</li> <li><code>boolean canRead()</code> \u2192 Comprueba si la aplicaci\u00f3n puede leer el archivo indicado para esta ruta abstracta.</li> <li><code>boolean canWrite()</code> \u2192 Comprueba si la aplicaci\u00f3n puede modificar el archivo indicado por esta ruta abstracta.</li> </ul> <p>Contenido de un directorio:</p> <ul> <li><code>String[] list()</code> \u2192 Devuelve un array de cadenas con los nombres de los archivos y directorios del directorio indicado por esta ruta abstracta.</li> <li><code>File[] listFiles()</code> \u2192 Devuelve un array de rutas abstractas que indican los archivos del directorio indicado por esta ruta abstracta.</li> <li><code>String[] list(FilenameFilter filter)</code> \u2192 Devuelve un array de cadenas con los nombres de los archivos y directorios del directorio indicado por esta ruta abstracta que cumplen el filtro especificado.</li> <li><code>File[] listFiles(FilenameFilter filter)</code> \u2192 Devuelve un array de rutas abstractas que indican los archivos y directorios del directorio indicado por esta ruta abstracta que cumplen el filtro especificado.</li> </ul> <p>Consejo</p> <p>Le sugerimos al estudiante que busque informaci\u00f3n sobre la clase FilenameFilter.</p>"},{"location":"Unidad%201%20Ficheros/1_File_System.es/#141-ejercicio-resuelto","title":"1.4.1. Ejercicio resuelto","text":"<p>Analiza y explica el siguiente blog de c\u00f3digo <pre><code>public static void main(String[] args) { \nString ruta = args[0]; \nFile f = new File(ruta); \n\nif (f.exists()) { \nif (f.isFile()) { \nSystem.out.println(\"El tama\u00f1o es de \" + f.length()); \nSystem.out.println(\"Puede ejecturase: \" + f.canExecute()); \nSystem.out.println(\"Puede leerse: \" + f.canRead()); \nSystem.out.println(\"Puede escribirse: \" + f.canWrite()); \n} else { \nString[] losArchivos = f.list(); \nSystem.out.println(\"El directorio \" + ruta + \" contiene:\"); \nfor (String archivo : losArchivos) { \nSystem.out.println(\"\\t\" + archivo); \n} \n} \n\n} else { \nSystem.out.println(\"El archivo o ruta no existe\"); \n}\n}\n</code></pre></p> <p>Soluci\u00f3n</p> <ol> <li>Este programa lee desde la l\u00ednea de pedidos una ruta y crea un objeto File.</li> <li>A continuaci\u00f3n, comprueba si la ruta existe o no en el sistema de archivos. En caso de que no exista, el programa finaliza.</li> <li>Si la ruta existe, el siguiente paso es verificar si es un archivo: </li> <li>Leemos algunas propiedades triviales como el tama\u00f1o y los permisos.</li> <li>Si la ruta apuntada por el archivo es un directorio, obtenemos el contenido de este directorio y lo mostramos en la pantalla.</li> </ol>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/","title":"2. Lectura y escritura de archivos","text":"<p>Java ofrece una gran variedad de maneras de manipular el contenido de los archivos, aportando gran poder pero tambi\u00e9n complejidad al mismo tiempo.</p> <p>La lectura y escritura de archivos en Java se realiza a trav\u00e9s de flujos de datos o <code>streams</code>, que pueden ser orientados a bytes o considerados como un conjunto de caracteres. El concepto de archivo, que es est\u00e1tico, debe diferenciarse del concepto de flujo, que tiene un car\u00e1cter din\u00e1mico: un archivo se guarda en el disco, pero desde el punto de vista de la aplicaci\u00f3n, nos interesa la transferencia de esta informaci\u00f3n desde el archivo a nuestro programa. Una comparaci\u00f3n cl\u00e1sica: los flujos ser\u00edan como tuber\u00edas de agua, mientras que los archivos ser\u00edan dep\u00f3sitos. El concepto de flujo de datos, aparte del \u00e1mbito de los archivos, tambi\u00e9n ser\u00e1 aplicable a la transferencia de informaci\u00f3n, por ejemplo a trav\u00e9s de la red o entre procesos.</p> <p>Los flujos se pueden clasificar en:</p> <ul> <li><code>flujo de entrada</code>: Aquellos que van desde una fuente (por ejemplo, un archivo) al programa.</li> <li><code>flujo de salida</code>: Aquellos que salen del programa hacia un destino (por ejemplo, un archivo).</li> </ul> <p>Cuando leemos y almacenamos datos, debemos tener mucho cuidado con los tipos de datos con los que trabajamos, ya que la misma secuencia de bits en el disco representa informaci\u00f3n diferente seg\u00fan el tipo de datos utilizado. Incluido cuando se trata del mismo tipo de datos, como en el caso de los caracteres, es necesario tener especial cuidado, ya que diferentes sistemas pueden utilizar diferentes codificaciones. Java, por ejemplo, para el tipo char utiliza Unicode de 16 bits (UTF-16), pero podemos intentar acceder a archivos codificados, por ejemplo, con UTF-8 o ASCII.</p> <p>Las superclases padre para el manejo de corrientes orientadas a bytes son <code>InputStream</code> y <code>OutputStream</code>. De ellas derivan otras, pero para la gesti\u00f3n de archivos nos interesan dos: <code>FileInputStream</code> y <code>FileOutputStream</code>.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#21-fileinputstream","title":"2.1. FileInputStream","text":"<p>La clase <code>FileInputStream</code> se utiliza para acceder a archivos para la lectura y tiene dos constructores principales:</p> <ul> <li><code>FileInputStream (File f)</code> \u2192 Recibe un objeto de tipo <code>File</code>, que har\u00e1 referencia al objeto que leeremos.</li> <li><code>FileInputStream (String name)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a leer.</li> </ul> <p>Los principales m\u00e9todos que tenemos para esta clase son:</p> <ul> <li><code>int read()</code> \u2192 M\u00e9todo de lectura secuencial abstracto: Devuelve un entero correspondiente al siguiente byte de un flujo de entrada (fichero, vector de bytes...). Si llega al final de la secuencia, devuelve <code>-1</code>. En caso de error, lanzar\u00e1 una excepci\u00f3n de tipo IOException.</li> <li><code>int read(byte[] buffer)</code> \u2192 Lee un n\u00famero determinado de bytes de la entrada (tanto como el tama\u00f1o del buffer), los guarda en el buffer y devuelve el n\u00famero de bytes le\u00eddos efectivamente, que como m\u00e1ximo ser\u00e1 igual al tama\u00f1o del buffer. Si no hay bytes disponibles, devuelve <code>-1</code>.</li> <li><code>int available()</code> \u2192 Indica los bytes disponibles para la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tantos bytes como indica el par\u00e1metro. El valor de retorno es el n\u00famero de bytes que se han descartado efectivamente (puede ser menor que el indicado si llegamos al final, por ejemplo).</li> <li><code>int close()</code> \u2192 Cierra el flujo de datos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#22-fileoutputstream","title":"2.2. FileOutputStream","text":"<p>La clase <code>FileOutputStream</code> se utiliza para acceder a archivos para la escritura. Tiene los siguientes constructores:</p> <ul> <li><code>FileOutputStream (File f)</code> \u2192 Recibe un objeto de tipo <code>File</code> y lo abre en modo escritura. En caso de que no exista, se crear\u00e1, y si ya existe, se sobreescribir\u00e1.</li> <li><code>FileOutputStream (String name)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a escribir, y lo abre en modo escritura. En caso de que no exista, se crear\u00e1, y si ya existe, se sobreescribir\u00e1.</li> <li><code>FileOutputStream (File f, boolean append)</code> \u2192 Recibe un objeto de tipo <code>File</code> y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s (s\u00f3lo si append est\u00e1 establecido en <code>True</code>).</li> <li><code>FileOutputStream (String name, boolean append)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a escribir y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s (s\u00f3lo si append est\u00e1 establecido en <code>True</code>).</li> </ul> <p>Los principales m\u00e9todos de la clase son:</p> <ul> <li><code>write(int byte)</code> \u2192 Escribe el byte en el flujo de salida. Aunque este par\u00e1metro es un entero, s\u00f3lo se escribe un byte. Si hay un error, se lanzar\u00e1 una excepci\u00f3n de tipo IOException.</li> <li><code>void write(byte[] buffer)</code> \u2192 Escribe el contenido del buffer (vector de bytes) en el archivo. Si el buffer es nulo, lanzar\u00e1 una excepci\u00f3n.</li> <li><code>void write(byte[] buffer, int pos, int length)</code> \u2192 Escribe el contenido del <code>buffer</code> (vector de bytes) desde la posici\u00f3n <code>pos</code>, y tantos bytes como se indiquen en <code>length</code>.</li> <li><code>void flush()</code> \u2192 Fuerza la escritura de los bytes restantes en la memoria cach\u00e9 en el archivo de salida.</li> <li><code>void close()</code> \u2192 Cierra el flujo de salida y libera los recursos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#221-ejercicio-resuelto","title":"2.2.1. Ejercicio resuelto","text":"<p>Crea un programa sencillo en Java que copie un hitoxer a otro archivo byte en byte. El archivo origen y el archivo destino se indicar\u00e1n a trav\u00e9s de la l\u00ednea de pedidos.</p> <p>Soluci\u00f3n</p> <pre><code>class FileCopy { \n/* \nClass to test FileInputStream and FileOutputStream. \n\nCopy byte to byte of files \n\nSintaxis: \nFileCopy sourceFile destinationFile. \n\n*/ \npublic static void main(String[] args) throws Exception { \n// Byte readed from source \nint bytes; \n// Bytes (effectively) writen to dest \nlong bytesCopied=0; \n\n// Streams \n\nFileInputStream fis= null; \nFileOutputStream fundido=null; \n\n// To provide information about source \nFile f; \n\n\n// Are the arguments ok? \nif(args.length!=2){ \nSystem.out.println(\"N\u00famero de argumentos err\u00f3neo. Sintaxis:\\n FileCopy archivoOrigen archivoDesti\"); \nreturn; \n} \n\ntry{ \n\n// show source size \nf=new File(args[0]); \nSystem.out.println(\"Total: \"+f.length()+\" bytes\"); \n\n// Create streams \nfis=new FileInputStream(args[0]); \nfos=new FileOutputStream(args[1]); \n\ndo { \n// read one byte from source \nbytes=fis.read(); \n// write in destination \nif (bytes!=-1) \nfos.write(bytes); \n// Update number of bytes \nbytesCopied++; \n\n// Show progress (think alternativas as exercise) \nSystem.out.print(\"\\rCopiados \"+(bytesCopied-1)+\" bytes...\"); \n}while (bytes!=-1); \nSystem.out.println(\"Done it!\"); \n\n\n}catch (IOException exc){ \nSystem.out.println(\"Error de entrada y salida: \"+exc); \n}finally { \n// En el final, no hay que terminar las filas, sino en error existentes o no. \ntry { \nif (fis!=null) fis.close(); \n}catch (IOException exc){ \nSystem.out.println(\"Error al cerrar el archivo de origen.\"); \n} \ntry { \nif(fos!=null) fos.close(); \n}catch (IOException exc){ \nSystem.out.println(\"Error al cerrar el archivo destino.\"); \n} \n} \n} \n} \n</code></pre> <p>Piensa y comprueba</p> <p>Con el programa de ejemplo que hemos visto, podr\u00edamos copiar archivos de todo tipo: texto, audio, v\u00eddeo. </p> <p>Reto </p> <p>Trate de cambiar el \u00faltimo programa para leer los datos en bloques de 32 bytes, utilizando los m\u00e9todos adecuados de las clases. Comparte tu soluci\u00f3n en el foro.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#23-ficheros-de-texto","title":"2.3. Ficheros de Texto","text":"<p>Como se ha dicho, Java permite gestionar flujos con orientaci\u00f3n a bytes o con orientaci\u00f3n a caracteres. Las clases abstractas para la gesti\u00f3n de flujos orientados a caracteres son <code>Reader</code> y <code>Writer</code>.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#231-filereader","title":"2.3.1. <code>FileReader</code>","text":"<p>La clase <code>FileReader</code> sirve para acceder a archivos para la lectura y tiene dos constructores:</p> <ul> <li><code>FileReader (File f)</code> \u2192 Recibe un objeto de tipo <code>File</code>, que har\u00e1 referencia al objeto del que se obtendr\u00e1 la informaci\u00f3n.</li> <li><code>FileReader (String name)</code> \u2192 Recibe una cadena con el nombre o la ruta del archivo.</li> </ul> <p>Los m\u00e9todos que tenemos para esta clase son muy parecidos a los que tenemos para <code>FileInputStream</code>, con la diferencia de que ahora leemos caracteres en lugar de bytes.</p> <ul> <li><code>int read()</code> \u2192 Lee el siguiente car\u00e1cter del flujo de entrada y lo devuelve como entero.</li> <li>`int read(char[] buffer) \u2192 Rellena el buffer con tantos caracteres de la entrada como tenga (como m\u00e1ximo). Devuelve el n\u00famero de caracteres le\u00eddos efectivamente.</li> <li><code>int available()</code> \u2192 Devuelve el n\u00famero de caracteres disponibles para la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tantos caracteres como indica el par\u00e1metro.</li> <li><code>int close()</code> \u2192 Cierra el flujo de datos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#232-filewriter","title":"2.3.2. <code>FileWriter</code>","text":"<p>La clase FileWriter ser\u00eda el equivalente de <code>FileOutputStream</code> en la versi\u00f3n de flujos orientados a caracteres Los constructores de la clase son:</p> <ul> <li><code>FileWriter (File f)</code> \u2192 Abre elarchivo especificado por <code>File</code> para la escritura. Si el archivo no existe, se crear\u00e1, y si ya existe, se eliminar\u00e1n los contenidos.</li> <li><code>FileWriter (String name)</code> \u2192 Abre el archivo especificado por una cadena con el nombre y la ruta en modo escritura. Si no existe, se crear\u00e1, y si ya existe, se borrar\u00e1n los contenidos.</li> <li><code>FileWriter (File f, boolean append)</code> \u2192 Recibe un objeto de tipo <code>File</code> y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s.</li> <li><code>FileWriter (String name, boolean append)</code> \u2192 Recibe una cadena con el nombre o la ruta de la ubicaci\u00f3n del archivo a escribir y lo abre en modo a\u00f1adir, para escribir al final. Si no existe, se crear\u00e1, y si ya existe, se escribir\u00e1 detr\u00e1s.</li> </ul> <p>Los principales m\u00e9todos de la clase <code>FileWriter</code> son muy similares a los de <code>OutputStream</code>:</p> <ul> <li><code>write(int character)</code> \u2192 Escribe el car\u00e1cter en el flujo de salida, con la codificaci\u00f3n propia del sistema operativo. Si hay un error, se arroja una excepci\u00f3n de tipo <code>IOException</code>.</li> <li><code>void write(char[] buffer)</code> \u2192 Escribe el contenido del buffer (vector de caracteres) en el archivo. Si el buffer es nulo, lanzar\u00e1 una excepci\u00f3n.</li> <li><code>void write(char[] buffer, int pos, int length)</code> \u2192 Escribe el contenido del buffer (array de caracteres) desde la posici\u00f3n pos, y tantos bytes como se indiquen en length.</li> <li><code>void flush()</code> \u2192 Fuerza la escritura de los bytes restantes en la memoria cach\u00e9 en el archivo de salida.</li> <li><code>void close()</code> \u2192 Cierra el flujo de salida y libera los recursos.</li> <li><code>void write(String text)</code> \u2192 Escribe todo el contenido de texto en el archivo.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#233-ejercicio-resuelto","title":"2.3.3. Ejercicio resuelto","text":"<p>Crea un programa sencillo en Java que fusione todos los archivos dentro de una carpeta en un \u00fanico archivo. La carpeta de origen y el archivo de destino se indicar\u00e1n en la llamada del programa. Supongamos que todos los archivos dentro de esta carpeta son archivos de texto.</p> <p>Soluci\u00f3n</p> <pre><code>class FusionaTextos { \n// C\u00f3digo del programa \n} \n``` /* \n\n\nSintax: \nMergeTexts DirectorioOrigen ArchivoDestino \n\n*/ \npublic static void main(String[] args) throws Exception { \n\nFile decir; // Source dir \n// Collection of files from that dir \nFile[] filas; \n\n// readed characters \nint characters; \n\n// Input and Output Streams \nFileReader fin=null; \nFileWriter fout=null; \n\n// Check the args \nif(args.length!=2){ \nSystem.out.println(\"N\u00famero de argumentos err\u00f3neo. Sintaxis:\\n mergeTexts DirectorioOrigen archivoDesti\"); \nreturn; \n} \n\ntry{ \n\n// We get the list of Files \ndir=new File(args[0]); \nfilas=dir.listFiles(); \n\n\n// Open and close output stream (in ordenar a crear el archivo) \nfout=new FileWriter(args[1]); \nfout.close(); \n\n// Re-open it \nfout=new FileWriter(args[1], true); \n\n// Iterate among the list \nfor (int i=0; i&lt;files.length; i++){ \n// open input stream \nfin=new FileReader(argos[0]+\"/\"+files[y].getName()); \nSystem.out.println(\"Merging \"+args[0]+\"/\"+files[i].getName()); \n// and merge to the output one \ndo { \ncharacters=fin.read(); \nif (characters!=-1) \nfout.write(characters); \n}while (characters!=-1); \nfin.close(); //close the file merged \n\n} \nfout.close(); //close the output file \n\n}catch (Exception exc){ \n// Catch all the exception (we coud improve it) \nSystem.out.println(\"Input/Output error: \"+exc); \n} \n} \n} \n</code></pre> <p>Mejora tu c\u00f3digo</p> <p>Intenta mejorar el c\u00f3digo anterior creando una funci\u00f3n <code>merge()</code>. Deber\u00edamos llamarla dentro del bucle principal.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#24-decoradores","title":"2.4. Decoradores","text":"<p>Patr\u00f3n de dise\u00f1o decorador</p> <p>Las clases de decorador son aquellas que heredan de cierta clase y proporcionan funcionalidades a\u00f1adidas al original. En el caso de los flujos de entrada y salida, tenemos decoradores que nos permiten leer o escribir l\u00edneas completas en vez de byte a byte, o guardarlos en un cierto formato de datos. Simplifica nuestro trabajo, a\u00f1adiendo una forma m\u00e1s natural y amigable para utilizar las clases base.</p> <p>La clase <code>InputStream</code> tiene varios decoradores, pero nos centraremos en los siguientes:</p> <ul> <li><code>DataInputStream</code> \u2192 Permite leer datos de cualquier tipo (entero, l\u00f3gico, etc.)</li> <li><code>ObjectInputStream</code> \u2192 A\u00f1ade la opci\u00f3n de leer un objeto entero</li> </ul> <p>Por otro lado, la clase <code>OutputStream</code> tambi\u00e9n tiene diferentes decoradores, entre los que destacamos:</p> <ul> <li><code>DataOutputStream</code> \u2192 Permite escribir datos de cualquier tipo (entero, l\u00f3gico, etc.)</li> <li><code>PrintStream</code> \u2192Permite escribir datos de cualquier tipo y tambi\u00e9n acepta los m\u00e9todos <code>printf</code> y <code>println</code></li> <li><code>ObjectOutputStream</code> \u2192 Permite escribir (serializar) objetos</li> </ul> <p>En cuanto a las clases de decorador para flujos orientados a caracteres, tenemos, por un lado, los decoradores de <code>Reader</code> (m\u00e1s destacados):</p> <ul> <li><code>BufferedReader</code> \u2192 Crea un buffer de entrada, permitiendo, por ejemplo, leer una l\u00ednea completa</li> </ul> <p>Y para la escritura:</p> <ul> <li><code>BufferedWriter</code> \u2192 Crea un buffer de salida, permitiendo, por ejemplo, escribir una l\u00ednea completa</li> <li><code>PrintWriter</code> \u2192 Permite escribir datos de diferentes tipos y tiene m\u00e9todos como <code>printf</code> y <code>println</code></li> </ul> <p>La clase <code>BufferedReader</code>, entre otros, tiene el m\u00e9todo <code>readLine()</code>, que permite leer una l\u00ednea entera del archivo hasta el final de la l\u00ednea, muy \u00fatil en archivos de texto.</p> <p>Por su parte, la clase <code>BufferedWriter</code> proporciona el m\u00e9todo <code>newLine()</code> para introducir el car\u00e1cter de retorno de carro y el m\u00e9todo <code>write(String cadena, int inicio, int longitud)</code> para escribir una cadena o parte espec\u00edfica.</p> <p>El otro decorador para la escritura es el <code>PrintWriter</code>, que nos ofrece los m\u00e9todos <code>print(datos)</code>, <code>println(datos)</code> y <code>printf()</code> para el formato.</p> <p>Alternativas a...</p> <p>Obviamente, podr\u00eda: </p> <ul> <li>concatenar <code>\\n</code> al final de cada cadena en cada m\u00e9todo <code>print()</code> en vez de llamar <code>newLine()</code>. </li> <li>utilizar <code>println()</code> en lugar de llamar <code>newLine()</code>.</li> </ul>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#241-ejercicio-resuelto","title":"2.4.1. Ejercicio resuelto","text":"<p>Crea un programa para copiar un archivo de texto a\u00f1adiendo el n\u00famero de l\u00ednea al principio de cada l\u00ednea.</p> <p>Soluci\u00f3n</p> <pre><code>public class NumberLines { \npublic static void main(String[] args) throws Exception { \n\n// Input and Output \nBufferedReader fin; \nPrintWriter fout; \n\n// line counter \nint num_linia; \n// readed line \nString linea; \n\n// check args \nif (args.length != 2) { \nSystem.out.println(\"N\u00famero de argumentos err\u00f3neo. Sintaxis:\\n numberLines archivo salida\"); \nreturn; \n} \n\n// Creare decorators \nfin = new BufferedReader(new FileReader(args[0])); \nfout = new PrintWriter(new FileWriter(args[1])); \n\nnum_linia = 1; \ndo { \n// Read the line \nlinea = fin.readLine(); \nif (l\u00ednea != null) { \nfout.println(num_linia + \". \" + linea); \n} \nnum_linia++; \n} while (l\u00ednea != null); // until we can't read \n\n// close all \nfin.close(); \nfout.close(); \n\n} \n} \n</code></pre>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#25-ficheros-binarios","title":"2.5. Ficheros binarios","text":"<p>En esta secci\u00f3n y las siguientes veremos c\u00f3mo almacenar diferentes tipos de datos y objetos en archivos de diferentes formatos: archivos binarios, archivos XML o JSON.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#251-almacenar-datos-estructurados-en-archivos-binarios","title":"2.5.1. Almacenar datos estructurados en archivos binarios.","text":"<p>En la secci\u00f3n anterior vimos c\u00f3mo trabajar con archivos de caracteres y de bytes. En el caso de los archivos de bytes, hemos visto c\u00f3mo leerlos y escribirlos secuencialmente, byte a byte hasta el final del archivo.</p> <p>Imaginemos que queremos guardar la siguiente tabla, que combina datos de distintos tipos. Este ejemplo aparecer\u00e1 en las siguientes secciones.</p> <p>|Modulo |</p> <p>|---|-|---|</p> <p>|Acceso a Datos | 6 |8.45 |</p> <p>|Programaci\u00f3n de servicios y procesos |3 |9.0|</p> <p>|Desarrollo de interfaces |6 |8.0|</p> <p>|Programaci\u00f3n Multimedia y dispositivos m\u00f3viles |5 |7.34|</p> <p>|Sistemas de Gesti\u00f3n Empresarial |5 |8.2|</p> <p>|Empresa e iniciativa emprendedora |3 |7.4|</p> <p>Como podemos ver, tenemos datos de texto, datos num\u00e9ricos enteros y reales. Si queremos mantener los tipos, los flujos orientados a caracteres como <code>Reader</code> o <code>Writer</code> no ser\u00e1n \u00fatiles, as\u00ed que deber\u00edamos utilizar <code>InputStream</code> y <code>OutputStream</code>.</p> <p>Para guardar estas estructuras eficientemente, podemos utilizar las clases <code>DataInputStream</code> y <code>DataOutputStream</code>, que son decoradores de flujos y que nos ofrecen los siguientes m\u00e9todos para guardar o recuperar datos de diferentes tipos, sin tener que preocuparnos de cu\u00e1nto ocupan internamente como puede ver, hay m\u00e9todos rec\u00edprocos para leer.</p> <p>|<code>DataInputStream</code> |</p> <p>|---|---|---|</p> <p>|<code>byte readByte()</code>|<code>void writeByte(int)</code> |un byte |</p> <p>|<code>short readShort()</code> |<code>void writeShort(short)</code> |entero corto |</p> <p>|<code>int readInt()</code> |<code>void writeInt(int)</code> |</p> <p>|<code>long readLong()</code> |<code>void writeLong(long)</code> |</p> <p>|<code>float readFloat()</code> |<code>void writeFloat(float)</code> | real de precisi\u00f3n simple|</p> <p>|<code>double readDouble()</code> |<code>void writeDouble(double)</code> |real doble|</p> <p>|<code>char readChar()</code> |<code>void writeChar(int)</code> |n car\u00e1cter Unicode|</p> <p>|<code>String readUTF()</code> |<code>void writeUTF(String)</code>|un String UTF-8 |</p> <p>Tip</p> <p>Una cadena <code>UTF-8</code> es diferente a una String. Cuando se guarda una cadena, como es evidente, se guardan todos los caracteres. Al guardarla como cadena UTF-8, se a\u00f1ade informaci\u00f3n sobre la longitud de la cadena, siendo esta informaci\u00f3n esencial para cortar estas cadenas cuando se lean en el futuro. </p> <p>Imagina que guardas dos cadenas, \"euro\" y \"sport\". El resultado ser\u00e1, al final, \"eurosport\". Cuando alguien abra este archivo en el futuro, \u00bfc\u00f3mo sabr\u00e1 el n\u00famero de cadenas almacenadas (\"euro\", \"sport\" o simplemente \"eurosport\" (canal de televisi\u00f3n))? </p> <p>Al guardarlo como UTF-8, cuando guardas \"euro\" y \"sport\", el resultado es \"4euro5sport\". Cuando alguien intente leerlo, primero ver\u00e1 un '4' y leer\u00e1 \"euro\". Luego, ver\u00e1 un '5' y leer\u00e1 \"sport\". </p> <p>Cabe destacar que si se guarda \"eurosport\", el resultado ser\u00e1 \"9eurosport\". Prueba a escribir un programa de ejemplo con esta cadena, abriendo el archivo resultante con un editor hexadecimal.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#252-ejercicio-resuelto","title":"2.5.2. Ejercicio resuelto","text":"<p>Escribe un programa que tenga los datos almacenados en tres arrays paralelos, que almacenan los datos de los m\u00f3dulos de DAM. Escribe dos funciones, una para escribir estos datos en un archivo y otra para leerlos. Considera almacenar los datos agrupados por m\u00f3dulo, en vez de nombre, horas y calificaci\u00f3n.</p> <p>Soluci\u00f3n</p> <pre><code>public class Moduls{ \n\n// several arrays with modules data \nString[] modulos={\"Acceso a Datos\", \"Programaci\u00f3n de servicios y procesos\", \"Desarrollo de interfaces\", \"Programaci\u00f3n Multimedia y dispositivod m\u00f3viles\", \"Sistemas de Gesti\u00f3n Empresarial\", \"Empresa e iniciativa emprendedora\"}; \nint[] horas={6, 3, 6, 5, 5, 3}; \ndouble[] notas={8.45, 9.0, 8.0, 7.34, 8.2, 7.4}; \n\npublic void readFiLe(String name) throws IOException { \n// Para leer el archivo binario, creamos un DataInputStream \n// a partir del FileInputStream creado a partir del nombre \nDataInputStream f = new DataInputStream(new FileInputStream(name)); \n\n// Mientras el DataInputStream tenga datos disponibles \nwhile (f.available()&gt;0){ \n// Leeremos del archivo cada dato, con el orden correspondiente \n// en funci\u00f3n del tipo \n// (por lo tanto, debemos saber el orden en el que guardamos!) \nSystem.out.println(\"M\u00f3dulo: \" + f.readUTF()); \nSystem.out.println(\"Horas: \" + f.readInt()); \nSystem.out.println(\"Notas: \" + f.readDouble()); \nSystem.out.println(); \n} \nf.close(); \n} \n\npublic void writeFile(String name) throws IOException{ \n// Para escribir el archivo, hacemos uso de DataOutputStream \nDataOutputStream f = new DataOutputStream(new FileOutputStream(name)); \n\n// Recorreremos cualquiera de los vectores (todos deber\u00edan tener) \n// la misma longitud \nfor (int i=0;i&lt;this.moduls.length;i++){ \n// Y para cada posici\u00f3n, escribiremos en funci\u00f3n del tipo de dato \nf.writeUTF(this.moduls[i]); \nf.writeInt(this.horas[i]); \nf.writeDouble(this.notes[i]); \n\n} \nf.close(); \n} \n\npublic static void main(String[] args) throws IOException { \n\n// Comprobamos los argumentos \nif (args.length!=2){ \nSystem.out.println(\"N\u00famero de argumentos incorrecto.\\n\\nSintaxis: \\n\\t java Moduls [read | write] archivo.dat\"); \nSystem.exit(0); \n} \n\n// Defining the class \nModuls moduls=new Modulos(); \n\n// Depending the args, we will proceed \nif (args[0].equals(\"read\")) \nmoduls.readFiLe(args[1]); \nelse if (args[0].equals(\"write\")) \nmoduls.writeFile(args[1]); \nelse \nSystem.out.println(\"No entiendo el mandato \"+args[0]+\"\\n\"); \n} \n} \n</code></pre>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#26-serializando-objetos","title":"2.6. Serializando Objetos","text":"<p>Java proporciona un sistema gen\u00e9rico de serializaci\u00f3n de objetos: un sistema recursivo que itera sobre cada objeto contenido en una instancia, hasta llegar a los tipos primitivos, que se almacenan como un array de bytes. Aparte de esta informaci\u00f3n de los tipos primitivos, tambi\u00e9n se almacena informaci\u00f3n adicional o metadatos espec\u00edficos de cada clase, como el nombre o los atributos, entre otros. Gracias a estos metadatos, que describen los objetos que guardamos, podemos automatizar la serializaci\u00f3n de forma gen\u00e9rica, asegur\u00e1ndonos que posteriormente podremos leer los objetos.</p> <p>La desventaja de este m\u00e9todo es que al cambiar la definici\u00f3n de la clase (por ejemplo, a\u00f1adiendo un atributo m\u00e1s o cambiando su tipo), los metadatos se modifican y no podr\u00edamos leer los objetos serializados con versiones anteriores de la clase. Adem\u00e1s, tambi\u00e9n hay que tener en cuenta que \u00e9ste es un mecanismo espec\u00edfico de Java y que no podremos consultar estos objetoses desde otros lenguajes.</p> <p>Por todo ello, otras t\u00e9cnicas son preferibles para el almacenamiento permanente de objetos, que veremos m\u00e1s adelante, pero la serializaci\u00f3n puede resultar \u00fatil para el almacenamiento temporal, dentro de la propia ejecuci\u00f3n de la aplicaci\u00f3n.</p> <p>\u00bfQu\u00e9 es esto?</p> <p>Investigaci\u00f3n: intenta encontrar informaci\u00f3n sobre SerialVersionUID y para qu\u00e9 es importante.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#261-la-interfaz-serializable-y-los-decorators","title":"2.6.1. La interfaz <code>Serializable</code> y los <code>Decorators</code>","text":"<p>Si queremos que una clase sea serializable, debe implementar la interfaz <code>Serializable</code>, la cual tiene como \u00fanico prop\u00f3sito actuar como marcador para indicar al JVM que la clase puede ser serializada, por tanto, esta clase no tendr\u00e1 m\u00e9todos.</p> <p>Cabe decir que todas las clases correspondientes a los tipos b\u00e1sicos ya implementan la interfaz Serializable, as\u00ed como la clase String, contenedores y Arrays. En el caso de las colecciones, depende de sus contenidos, si sus elementos son serializables, la colecci\u00f3n tambi\u00e9n lo ser\u00e1. Si el objeto que queremos serializar o sus objetos no implementan la interfaz Serializable, se lanzar\u00e1 la excepci\u00f3n <code>NotSerializableException</code>.</p> <p>Los decoradores <code>ObjectInputStream</code> y <code>ObjectOutputStream</code> nos ofrecen la capacidad de serializar cualquier objeto deserializable. Para escribir un objeto, haremos uso del m\u00e9todo <code>writeObject</code> de <code>ObjectOutputStream</code>, y para leerlo haremos uso de <code>readObject</code> de <code>ObjectInputStream</code>.</p> <p>Ovejas con ovejas</p> <p>Hay que tener en cuenta que la lectura de objetos debe realizarse en instancias de la misma clase que se guard\u00f3. De lo contrario, se lanzar\u00e1 una excepci\u00f3n <code>ClassCastException</code>. Adem\u00e1s, es necesario tener el c\u00f3digo compilado de la clase para evitar la excepci\u00f3n <code>ClassNotFoundException</code>. </p> <p>Adem\u00e1s, <code>readObject</code> devuelve un Object, y necesitamos un objeto de una clase espec\u00edfica. Por este motivo, es necesario realizar una conversi\u00f3n de Object a la clase necesaria. Los conceptos de herencia son importantes para garantizar programas robustos.</p>"},{"location":"Unidad%201%20Ficheros/2_Reading_and_writing_files.es/#262-ejercicio-resuelto","title":"2.6.2. Ejercicio resuelto","text":"<p>Empezando con la misma base de la clase <code>Moduls</code> del ejercicio anterior, crearemos una clase <code>Modul</code> para almacenar un \u00fanico m\u00f3dulo. Este tipo de clases se conocen como POJO (Plain Old Java Objects) y est\u00e1n dise\u00f1adas s\u00f3lo para almacenar informaci\u00f3n. (Aparecer\u00e1 m\u00e1s adelante, junto con las clases BEAN).</p> <p>Una vez creada la clase <code>Modul</code>, escribe un programa para guardar objetos directamente en un archivo. Despu\u00e9s, escribe la funci\u00f3n complementaria para leer todos los objetos almacenados en ese archivo.</p> <p>Soluci\u00f3n</p> Modulo.java<pre><code>package org.example.pojo;\n\nimport java.io.Serializable;\n\npublic class Modulo implements Serializable {\n\n    String nombre;\n    int horas;\n    double nota;\n\n    public Modulo(){\n// Constructor vac\u00edo\n    }\n\n    public Modulo(String nombre, int horas, double nota){\n        this.nombre=nombre;\n        this.horas=horas;\n        this.nota=nota;\n    }\n\n    public String getModulo() {return this.nombre;}\n    public int getHoras() {return this.horas;}\n    public double getNota() {return this.nota;}\n\n\n    /*\n     Write and Read modules to/from file\n     */\n\n\n\n\n}\n</code></pre> Modulo2.java<pre><code>package org.example.pojo;\n\nimport java.io.*;\n\npublic class Modulo2 {\n\n    // Arrays with source data\n    String[] modulos = {\"Acceso a Datos\", \"Programaci\u00f3n de servicios y procesos\", \"Desarrollo de interfaces\", \"Programaci\u00f3n Multimedia y dispositivod m\u00f3viles\", \"Sistemas de Gesti\u00f3n Empresarial\", \"Empresa e iniciativa emprendedora\"};\n    int[] horas = {6, 3, 6, 5, 5, 3};\n    double[] notas = {8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void EscribeObjeto(String nombre) throws IOException {\n\n        //destination file\n        ObjectOutputStream f = new ObjectOutputStream(new FileOutputStream(nombre));\n\n        Modulo m; // Single object\n\n        // loop along the arrays\n        for (int i = 0; i &lt; this.modulos.length; i++) {\n            m = new Modulo(this.modulos[i], this.horas[i], this.notas[i]);\n            f.writeObject(m);\n        }\n\n        // close the file\n        f.close();\n\n    }\n\n    public void LeeObjeto(String nombre) throws IOException, ClassNotFoundException {\n\n        // input file\n        ObjectInputStream f = new ObjectInputStream(new FileInputStream(nombre));\n\n        Modulo m;\n        // No se puede saber que hay objetos existentes en el archivo.\n        try {\n            while (true) { // forever\n\n                m = (Modulo) f.readObject();\n\n                // show the module\n                System.out.println(\"Modul: \" + m.getModul());\n                System.out.println(\"Horas: \" + m.getHores());\n                System.out.println(\"Nota: \" + m.getNota());\n                System.out.println();\n\n            }\n        } catch (EOFException ex) {\n            f.close();\n        }\n\n    }\n}\n</code></pre> Main.java<pre><code>package org.example;\n\nimport org.example.pojo.Modulo2;\n\nimport java.io.IOException;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        // test the args\n        if (args.length != 2) {\n            System.out.println(\"N\u00famero de argumentos incorrecto.\\n\\nSintaxis: \\n\\t java Moduls2 [ read | write ] archivo.obj\");\n            System.exit(0);\n        }\n\n        Modulo2 modulos = new Modulo2();\n\n        // depending the args\n        if (args[0].equals(\"read\")) {\n            modulos.LeeObjeto(args[1]);\n        } else if (args[0].equals(\"write\")) {\n            modulos.EscribeObjeto(args[1]);\n        } else {\n            System.out.println(\"No entiendo el mandato \" + args[0] + \"\\n\");\n        }\n\n    }\n}\n</code></pre> <p>Menos trabajo, pero al final lo mismo.</p> <p>Probablemente lo pienses:</p> <ul> <li>Si todo en Java hereda de Object, un ArrayList es un Object... \u00bfPuedo guardar o cargar un ArrayList completo en una sola llamada?</li> <li>Pru\u00e9balo como una mejora del ejercicio anterior.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/","title":"3. Archivos XML","text":""},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#31-por-que-xml","title":"3.1. \u00bfPor qu\u00e9 XML?","text":"<p>Cuando queremos guardar datos que puedan ser le\u00eddos por distintas aplicaciones y plataformas, es mejor utilizar formatos de almacenamiento est\u00e1ndar que m\u00faltiples aplicaciones puedan entender (portabilidad). Un caso muy espec\u00edfico son los lenguajes de marcado, y el m\u00e1s conocido es el est\u00e1ndar XML (eXtensible Markup Language).</p> <p>Con los documentos XML, estructuramos la informaci\u00f3n insertando marcas o etiquetas entre la informaci\u00f3n. Estas etiquetas tienen un inicio y un final, y pueden anidarse dentro de otros, as\u00ed como contener informaci\u00f3n textual. el encabezamiento del documento la codificaci\u00f3n utilizada para guardar el documento.</p> <p>La forma de guardar informaci\u00f3n en XML, de forma jer\u00e1rquica, es muy similar a la forma en que lo hacen los objetos en una aplicaci\u00f3n, de manera que \u00e9stos se pueden traducir de manera relativamente conveniente en un documento XML.</p> <p>|M\u00f3dulo |</p> <p>|---|-|---|</p> <p>|Acceso a Datos | 6 |8.45 |</p> <p>|Programaci\u00f3n de servicios y procesos |3 |9.0|</p> <p>|Desarrollo de interfaces |6 |8.0|</p> <p>|Programaci\u00f3n Multimedia y dispositivos m\u00f3viles |5 |7.34|</p> <p>|Sistemas de Gesti\u00f3n Empresarial |5 |8.2|</p> <p>|Empresa e iniciativa emprendedora |3 |7.4|</p> <p>puede representarse en etiquetas <code>xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;curso&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Acceso a Datos&lt;/nombre&gt;\n        &lt;horas&gt;6&lt;/horas&gt;\n        &lt;calificacion&gt;8.45&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Programaci\u00f3n de servicios y procesos&lt;/nombre&gt;\n        &lt;horas&gt;3&lt;/horas&gt;\n        &lt;calificacion&gt;9.0&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Desarrollo de interfaces&lt;/nombre&gt;\n        &lt;horas&gt;6&lt;/horas&gt;\n        &lt;calificacion&gt;8.0&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Programaci\u00f3n Multimedia y dispositivos m\u00f3viles&lt;/nombre&gt;\n        &lt;horas&gt;5&lt;/horas&gt;\n        &lt;calificacion&gt;7.34&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Sistemas de Gesti\u00f3n Empresarial&lt;/nombre&gt;\n        &lt;horas&gt;5&lt;/horas&gt;\n        &lt;calificacion&gt;8.2&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n    &lt;modulo&gt;\n        &lt;nombre&gt;Empresa e iniciativa emprendedora&lt;/nombre&gt;\n        &lt;horas&gt;3&lt;/horas&gt;\n        &lt;calificacion&gt;7.4&lt;/calificacion&gt;\n    &lt;/modulo&gt;\n&lt;/curso&gt;\n</code></pre> <p>o puede ser representado con etiquetas y atributos:</p> <p><pre><code>&lt;curso&gt; \n&lt;modulo nombre=\"Acceso a Datos\" horas=\"6\" calificacion=\"8.45\" &gt; \n&lt;modulo nombre=\"Programaci\u00f3n de servicios y procesos\" \"horas\"=3 calificacion=\"9.0\" &gt; \n&lt;modulo nombre =\"Desarrollo de interfaces\" horas=\"6\" calificacion=\"8.0\" &gt; \n&lt;/modulo&gt; \n&lt;modulo nombre=\"Programaci\u00f3n Multimedia y dispositivod m\u00f3viles\" horas=\"5\" calificacion=\"7,34\"&gt; \n&lt;modulo nombre=\"Sistemas de Gesti\u00f3n Empresarial\" horas=\"5\" \"calificacion\"=8.2 /&gt; \n&lt;modulo nombre=\"Empresa e iniciativa emprendedora\" horas=\"3\" calificacion=\"7.4\" /&gt; \n&lt;/modulo&gt;\n&lt;/curso&gt;\n</code></pre> Un analizador XML es una clase que permite analizar un archivo XML y extraer informaci\u00f3n de \u00e9l, relacion\u00e1ndola seg\u00fan su posici\u00f3n en la jerarqu\u00eda. Los analizadores, seg\u00fan su forma de funcionar, pueden ser:</p> <ul> <li>Analizadores secuenciales o sint\u00e1cticos, que extraen el contenido a medida que se descubren las etiquetas de apertura y cierre. Son muy r\u00e1pidos, pero tienen el problema que hay que leer todo el documento para acceder a una parte espec\u00edfica.</li> <li>Analizadores jer\u00e1rquicos, que son los m\u00e1s utilizados y que guardan todos los datos del documento XML en la memoria, en forma de una estructura jer\u00e1rquica (DOM o Document Object Model), siendo los preferidos para aplicaciones que deben leer los datos de forma m\u00e1s continua.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#32-el-modelo-de-objetos-de-documento-dom","title":"3.2. El Modelo de Objetos de Documento (DOM)","text":"<p>El DOM (Document Object Model) es la estructura especificada por la W3C donde se almacena la informaci\u00f3n de los documentos XML. El DOM se ha relacionado principalmente con el mundo web, con HTML y Javascript como principales impulsores.</p> <p>La interfaz principal del DOM en Java es <code>Document</code>, y representa el documento XML completo Al ser una interfaz, se puede implementar en varias clases.</p> <p>Hay que tener en cuenta que...</p> <p>Una interfaz es una especie de plantilla para construir clases y generalmente est\u00e1 compuesta por un conjunto de declaraciones de cabecera de m\u00e9todos no implementados que especifican c\u00f3mo se comportan una o m\u00e1s clases. Adem\u00e1s, una clase puede implementar una o m\u00e1s interfaces. </p> <p>Hay que tener en cuenta que una interfaz no debe confundirse con una clase abstracta, ya que hay algunas diferencias. Por ejemplo, una interfaz tiene todos los m\u00e9todos abstractos, no puede declarar variables de instancia, una clase puede implementar varias interfaces pero no heredatar de varias superclases, y una interfaz no debe pertenecer a ninguna jerarqu\u00eda, por lo que las clases que no tienen ninguna relaci\u00f3n de herencia pueden implementar la misma interfaz.</p> <p>Aparte de <code>Document</code>, la W3C tambi\u00e9n define la clase abstracta <code>DocumentBuilder</code>, que permite crear el DOM a partir del XML. Adem\u00e1s, se especifica la clase <code>DocumentBuilderFactory</code>, que nos permite fabricar <code>DocumentBuilders</code>, puesto que, al ser abstracta, no se puede instanciar directamente.</p> <p>Cabe decir, como advertencia, que Java ofrece muchas librer\u00edas desde las que importar Document. Las librer\u00edas que utilizaremos para analizar XML ser\u00e1n:</p> <ul> <li>La librer\u00eda <code>java.xml.parsers.*</code>, que ofrecer\u00e1 las clases <code>DocumentBuilderFactory</code> y <code>DocumentBuilder</code>, y</li> <li>La librer\u00eda <code>org.w3c.dom.*</code> para la clase <code>Document</code>.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#321-documentbuilder-y-documentbuilderfactory","title":"3.2.1. <code>DocumentBuilder</code> y <code>DocumentBuilderFactory</code>","text":"<p>Como se ha dicho, <code>DocumentBuilder</code> define una API para obtener instancias DOM de un documento XML. Para obtener una instancia de la clase, se debe utilizar la clase <code>DocumentBuilderFactory</code>, y concretamente el m\u00e9todo <code>newDocumentBuilder()</code>:</p> <p>Por otra parte, para leer e interpretar el documento XML, la clase <code>DocumentBuilderFactory</code> proporciona el m\u00e9todo <code>parse()</code>, que analiza un XML indicado por un archivo y devuelve un objeto <code>Document</code>.</p> <p>Veremos todo esto con un ejemplo. Continuamos almacenando datos sobre los m\u00f3dulos del curso, pero ahora con XML. El siguiente m\u00e9todo nos servir\u00e1 para abrir un documento XML, analizarlo y devolver el DOM generado en un <code>Document</code>. Lo podemos utilizar en cualquier sitio de nuestros programas, ya que la tarea es siempre similar:</p> <pre><code>    public Document OpenXML(String name) throws IOException, SAXException, ParserConfigurationException, FileNotFoundException {\n\n        // Create an instance of DocumentBuilderFactory\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        // Using the DocumentBuilderFactory instance we create a DocumentBuilder\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n\n        return dBuilder.parse(new File(name));\n    }\n</code></pre> <p>Hay que decir que la funci\u00f3n anterior podr\u00eda simplificarse sin utilizar las declaraciones intermedias, pero est\u00e1 algo ofuscada.</p> <pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException { \nreturn DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(name);\n}\n</code></pre> <p>Por otra parte, la clase <code>DocumentBuilder</code> tambi\u00e9n nos permite crear un nuevo DOM con el m\u00e9todo <code>newDocument()</code>. Esto nos servir\u00e1 m\u00e1s adelante para almacenar nuevos documentos XML. El procedimiento es el siguiente:</p> <ul> <li>Ante todo, debemos crear un nuevo DOM con <code>newDocument()</code>.</li> <li>A\u00f1adir los elementos y,</li> <li>Luego almacenarlo en un archivo.</li> </ul> <p>En secciones posteriores, veremos c\u00f3mo hacer todo esto. Por ahora, nos centraremos en interpretar y leer el DOM.</p> <p>Para m\u00e1s informaci\u00f3n, puedes consultar las clases DocumentBuilder y DocumentBuilderFactory en el API de OpenJDK.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#33-clases-y-metodos-de-dom","title":"3.3. Clases y M\u00e9todos de DOM","text":"<p>Hasta ahora hemos visto c\u00f3mo abrir y analizar un documento XML con <code>DocumentBuilder</code> para crear un objeto de tipo <code>Document</code>. En esta secci\u00f3n veremos c\u00f3mo trabajar con este documento para acceder a los distintos elementos. Como sabemos, el DOM tiene una estructura jer\u00e1rquica, formada por nodos. Los distintos tipos de nodos que podemos encontrar son:</p> <ul> <li><code>Document</code> \u2192 que es el nodo principal y representa todo el XML.</li> <li><code>Element</code> \u2192 que representa las diferentes etiquetas (incluyendo la etiqueta ra\u00edz). En otras palabras, todas las etiquetas son Elementos, unas dentro de otras.</li> <li><code>TextElement</code> \u2192 que representa el contenido de una etiqueta de texto.</li> <li><code>Attribute</code> \u2192 que representa los atributos.</li> </ul> <p>Todas estas interfaces derivan de la interfaz <code>Node</code>, por tanto, heredar\u00e1n sus atributos y m\u00e9todos, y adem\u00e1s, proporcionar\u00e1n sus propios atributos y m\u00e9todos.</p> <p>A continuaci\u00f3n, veremos los m\u00e9todos m\u00e1s importantes de cada interfaz:</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#331-metodos-de-nodo","title":"3.3.1. M\u00e9todos de Nodo","text":"<p>M\u00e9todos relacionados con la obtenci\u00f3n de informaci\u00f3n</p> <ul> <li><code>String getNodeName()</code> \u2192 Obtiene el nombre del nodo actual</li> <li><code>short getNodeType()</code> \u2192 Obtiene el tipo de nodo (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE...)</li> <li><code>String getNodeValue()</code>\u2192 Obtiene el valor del nodo</li> <li><code>NodeList getChildNodes()</code> \u2192 Obtiene una lista con los nodos hijos</li> <li><code>Node getFirstChild()</code> \u2192 Devuelve el primer hijo</li> <li><code>Node getLastChild()</code> \u2192 Devuelve el \u00faltimo hijo</li> <li><code>NamedNodeMap getAttributes()</code> \u2192 Devuelve una lista con los atributos del nodo</li> <li><code>Node getParentNode()</code> \u2192 Devuelve el nodo padre</li> <li><code>String getTextContent()</code> \u2192 Devuelve el texto contenido en el elemento y sus descendientes</li> <li><code>boolean hasChildNodes()</code> \u2192 Devuelve <code>true</code> si el nodo tiene alg\u00fan hijo</li> <li><code>boolean hasAttributes()</code> \u2192Devuelve <code>true</code> si el nodo tiene alg\u00fan atributo</li> </ul> <p>M\u00e9todos relacionados con la escritura</p> <ul> <li><code>Node appendChild(Node node)</code> \u2192 A\u00f1ade un nuevo nodo como \u00faltimo hijo.</li> <li><code>void removeChild(Node node)</code> \u2192 Elimina el nodo especificado de los nodos hijos.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#332-metodos-de-la-interfaces-elemento","title":"3.3.2. M\u00e9todos de la interfaces Elemento:","text":"<p>M\u00e9todos relacionados con la obtenci\u00f3n de informaci\u00f3n</p> <ul> <li><code>String getAttribute(String name)</code> \u2192 Devuelve el valor del atributo dado por el nombre.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Devuelve una lista de nodos hijos que coinciden con el nombre dado.</li> <li><code>boolean hasAttribute(String name)</code> \u2192 Devuelve true si el elemento tiene el atributo dado.</li> </ul> <p>M\u00e9todos relacionados con la escritura</p> <ul> <li><code>void setAttribute(String name, String value)</code> \u2192 A\u00f1ade un atributo al elemento, con el nombre y valor dados.</li> <li><code>void removeAttribute(String name)</code> \u2192 Elimina el atributo indicado por el nombre.</li> </ul>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#333-metodos-de-la-interfaz-documento","title":"3.3.3. M\u00e9todos de la interfaz Documento:","text":"<p>M\u00e9todos relacionados con la obtenci\u00f3n de informaci\u00f3n</p> <ul> <li><code>Element getDocumentElement()</code> \u2192 Devuelve el elemento ra\u00edz del documento.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Devuelve una lista de nodos hijos que coinciden con el nombre dado.</li> </ul> <p>M\u00e9todos relacionados con la escritura</p> <ul> <li><code>Element createElement(String name)</code> \u2192 Crea un elemento nuevo con el nombre dado.</li> <li><code>Text createTextNode(String text)</code> \u2192 Crea un nuevo elemento de texto.</li> <li><code>Node appendChild(Node node)</code> \u2192 A\u00f1ade un nuevo nodo hijo.</li> </ul> <p>Los objetos de tipo <code>NodeList</code>, que representan una lista de nodos, ofrecen el m\u00e9todo <code>item(int index)</code> para acceder a los distintos nodos de la lista, indicando su orden.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#34-lectura-de-archivos-xml","title":"3.4. Lectura de archivos XML","text":"<p>Vamos a repasar todos los conceptos de esta secci\u00f3n con una pr\u00e1ctica. Crearemos una clase que incluya todos los m\u00e9todos necesarios para abrir, leer, mostrar y escribir archivos XML. Trabajaremos con el documento de la secci\u00f3n anterior.</p> <p>Para empezar a leer el documento, lo primero que deberemos hacer es obtener el elemento ra\u00edz del documento con <code>getDocumentElement()</code>, que devuelve un objeto de tipo <code>Element</code>. Recuerda que la variable doc contiene todo el DOM, le\u00eddo con el m\u00e9todo explicado anteriormente:</p> <pre><code>Element root = doc.getDocumentElement();\n</code></pre> <p>Con este elemento ra\u00edz, ya podemos mostrar todo su contenido con <code>getTextContent()</code>. Se mostrar\u00e1 en pantalla en formato de texto, s\u00f3lo se imprimir\u00e1:</p> <pre><code>System.out.println(root.getTextContent());\n</code></pre> <p>Pero lo que nos interesa es recorrer todo el DOM y acceder a sus elementos. Para ello, a partir de este elemento ra\u00edz, seguiremos los siguientes pasos:</p> <ol> <li>Buscamos todos los tags <code>&lt;modulo&gt;</code> con <code>getElementsByTagName</code>. Este m\u00e9todo nos devuelve una lista de nodos (objeto de tipo <code>NodeList</code>).</li> <li>Ser\u00e1 necesario recorrer la lista de nodos (<code>NodeList</code>) para acceder a cada elemento. Para ello, es necesario utilizar el m\u00e9todo <code>item(int index)</code>, que devolver\u00e1 un elemento de tipo <code>Node</code>, y que debe convertirse expl\u00edcitamente a <code>Element</code> con una operaci\u00f3n de cast.</li> <li>Para cada elemento, accederemos al nombre del nodo para mostrar el nombre y el orden, utilizando <code>getNodeName()</code>.</li> <li>Buscamos las diferentes etiquetas encontradas dentro de cada m\u00f3dulo ('nombre', 'horas' y 'calificaci\u00f3n') con <code>getElementsByTagName()</code>. Este m\u00e9todo nos devolver\u00e1 una NodeList para cada tipo de etiqueta. Como s\u00f3lo tendremos un elemento, basta con acceder al elemento \u00fanico, representado por <code>item(0)</code>.</li> <li>Cabe destacar que con lo que hemos visto hasta ahora tendremos la primera (y \u00fanica) etiqueta 'nombre', 'horas' o 'calificaci\u00f3n' del m\u00f3dulo, pero todav\u00eda no estamos en el contenido, ya que esto es un elemento de tipo <code>TEXT_NODE</code>. Para acceder, deberemos acceder al primer hijo de la etiqueta (<code>getFirstChild()</code>) y obtener su valor con <code>getNodeValue()</code>.</li> </ol> <pre><code>// We will get a list of nodes (Step 1) \nNodeList modules = root.getElementsByTagName(\"modulo\"); \n\n// For each node (Step 2) \nfor (int i = 0; i &lt; modules.getLength(); i++) { \nElemento el = (Element) modules.item(i); \n\n// Display the node name (Step 3) \nSystem.out.println(el.getNodeName() + \" \" + (y + 1)); \n\n// And we show the value of the different tags \nSystem.out.println(\"Nombre: \" + el.getElementsByTagName(\"nombre\").item(0).getFirstChild().getNodeValue()); \nSystem.out.println(\"Horas: \" + el.getElementsByTagName(\"horas\").item(0).getFirstChild().getNodeValue()); \nSystem.out.println(\"Calificaci\u00f3n: \" + el.getElementsByTagName(\"calificacion\").item(0).getFirstChild().getNodeValue()); \nSystem.out.println(); \n}\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#35-escribir-archivos-xml","title":"3.5. Escribir archivos XML","text":"<p>Ahora vamos a la parte de escritura de los documentos XML. Por eso, partiremos de un archivo que ya contiene la informaci\u00f3n en formato binario de los m\u00f3dulos (por ejemplo, de la secci\u00f3n anterior), lo leeremos e importaremos su informaci\u00f3n en formato XML.</p> <p>Lo primero que debemos hacer es leer el archivo de objetos utilizando un <code>ObjectInputStream</code>:</p> <pre><code>ObjectInputStream f = new ObjectInputStream(new FileInputStream(file));\n</code></pre> <p>Y crearemos un documento vac\u00edo con las clases <code>DocumentBuilder</code> y <code>DocumentBuilderFactory</code>:</p> <pre><code>Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n</code></pre> <p>Una vez tenemos el documento vac\u00edo, creamos el elemento ra\u00edz (curso) y lo a\u00f1adimos al documento:</p> <pre><code>Elemento root = doc.createElement(\"curso\");\ndoc.appendChild(root);\n</code></pre> <p>Recuerda que accederemos al archivo de objetos, as\u00ed que deberemos saber exactamente c\u00f3mo es la clase que queremos leer y acceder a los m\u00e9todos correspondientes para obtener informaci\u00f3n sobre ella. Por eso, primero, debes definir un objeto de tipo <code>Modul</code>, y leeremos el archivo de objetos con el m\u00e9todo <code>readObject</code> de <code>File</code>. Una vez le\u00eddo un objeto, crearemos la etiqueta que engloba cada uno de ellos: la etiqueta <code>modulo</code>:</p> <pre><code>M\u00f3dulo m = (M\u00f3dulo) f.readObject();\nElemento modulo = doc.createElement(\"modulo\");\n</code></pre> <p>Dentro de \u00e9l, a medida que extraemos las diferentes propiedades del objeto del m\u00f3dulo, crearemos nodos secundarios y los a\u00f1adiremos al m\u00f3dulo. Por ejemplo, para el nombre del m\u00f3dulo:</p> <pre><code>Elemento name = doc.createElement(\"nombre\");\nname.appendChild(doc.createTextNode(m.getNom()));\nmodule.appendChild(name);\n</code></pre> <p>Como podemos ver, hemos creado un objeto de tipo Elemento con la etiqueta 'nombre', y hemos a\u00f1adido como hijo un nodo de tipo texto (TEXT_NODE), que hemos extra\u00eddo directamente del objeto <code>Modul m</code> con su propia funci\u00f3n <code>getModul()</code>. Adem\u00e1s, hemos a\u00f1adido esta etiqueta a la etiqueta <code>&lt;modul&gt;</code>, con <code>appendChild</code>.</p> <p>Deberemos hacer lo mismo para las horas de cada m\u00f3dulo y la calificaci\u00f3n, pero por ello, deberemos tener en cuenta que los m\u00e9todos getHores y getNota no devuelven una cadena de texto, sino un entero y un decimal, por lo que tendr\u00e1n que ser convertidos a texto:</p> <pre><code>Elemento hours = doc.createElement(\"horas\");\nhours.appendChild(doc.createTextNode(Integer.toString(m.getHores()))));\nmodule.appendChild(hours);\n\nElemento calificaci\u00f3n = doc.createElement(\"calificacion\");\ncalification.appendChild(doc.createTextNode(Double.toString(m.getNote()))));\nmodule.appendChild(grade);\n</code></pre> <p>Pondremos todo este procedimiento dentro de un bucle que recorrer\u00e1 todo el archivo de objetos. Una vez hayamos le\u00eddo cada uno de los m\u00f3dulos, deberemos a\u00f1adirlos al elemento ra\u00edz con:</p> <pre><code>root.appendChild(modulo);\n</code></pre> <p>Y ya tendremos el documento XML en la ra\u00edz. No se debe convertir este objeto en el tipo <code>Element</code> en cadena de texto en orden a la obtenci\u00f3n de la vuelta y de la etiqueta. Para esto, se debe utilizar la utilidad <code>`Transformer</code>.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#351-transformer","title":"3.5.1. Transformer","text":"<p>Java nos ofrece la utilidad <code>Transformer</code> para convertir informaci\u00f3n entre diferentes formatos jer\u00e1rquicos, como el objeto Documento que contiene el DOM de nuestro XML, a un archivo de texto XML.</p> <p>La clase <code>Transformer</code>, como <code>DocumentBuilder</code>, es tambi\u00e9n una clase abstracta, por lo que tambi\u00e9n requiere una f\u00e1brica para ser instanciada. La clase Transformer trabaja con dos tipos de adaptadores. Los adaptadores son clases que hacen compatibles distintas jerarqu\u00edas. Estos adaptadores son <code>Source</code> y <code>Result</code>. Las clases que implementan estos adaptadores ser\u00e1n las encargadas de hacer compatibles los distintos tipos de contenedores con los que requiere la clase Transformer. As\u00ed, y para aclararlo, tenemos las clases <code>DOMSource</code>, <code>SAXSource</code> o <code>StreamSource</code>, que son adaptadores del contenedor de origen de la informaci\u00f3n para DOM, SAX o Stream; y <code>DOMResult</code>, <code>SAXResult</code> y <code>StreamResult</code> como adaptadores equivalentes para el contenedor de destino.</p> <p>En nuestro caso, ya que tenemos un DOM y queremos convertirlo en un Stream, necesitaremos un <code>DomSource</code> y un <code>StreamResult</code>. Veremos el c\u00f3digo necesario para ello:</p> <pre><code>Transformer trans = TransformerFactory.newInstance().newTransformer();\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(new FileOutputStream(file+\".xml\"));\n</code></pre> <p>Lo primero que hemos hecho es crear un objeto de tipo <code>Transformer</code> con el m\u00e9todo <code>newTransformer()</code> de una instancia (newInstance()) de la f\u00e1brica de Transformers TransformerFactory. A continuaci\u00f3n, hemos definido la fuente (source) y el resultado (resultado) para la transformaci\u00f3n, siendo la fuente un DomSource creado a partir del doc que contiene nuestro documento, y el resultado un StreamResult, que escribir\u00e1 el flujo en el disco a trav\u00e9s de un FileOutputStream.</p> <p>Por \u00faltimo, hacemos la transformaci\u00f3n de un elemento a otro, que generar\u00e1 autom\u00e1ticamente el archivo XML de salida:</p> <pre><code>trans.transform(source, result);\n</code></pre>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#36-tecnicas-avanzadas-vinculacion-xml","title":"3.6. T\u00e9cnicas avanzadas: vinculaci\u00f3n XML","text":"<p>La t\u00e9cnica de vinculaci\u00f3n consiste en generar clases Java con formatos espec\u00edficos, como XML, de modo que cada etiqueta o atributo XML corresponda a una propiedad de una determinada clase. Esta correspondencia se llama mapeo.</p> <p>En Java, existen diferentes librer\u00edas para la vinculaci\u00f3n o mapeo: JAXB, JuBX, XMLBinding, etc. JAXB (Java Architecture for XML Binding) es una potente librer\u00eda que se ha incluido en el est\u00e1ndar desde JDK 6, pero se ha eliminado en la versi\u00f3n 11 y se sugiere incluirla como paquete externo. JAXB utiliza anotaciones para obtener la informaci\u00f3n necesaria para el mapeo de la vinculaci\u00f3n.Las anotaciones son indicaciones especiales de Java que permiten asociar informaci\u00f3n y funcionalidad a los objetos, sin interferir en la estructura del modelo de datos. Las anotaciones pueden asociarse con un paquete, una clase, un atributo o un par\u00e1metro, y se declaran con el s\u00edmbolo <code>@</code> delante del nombre de la anotaci\u00f3n. Cuando el compilador detecta una anotaci\u00f3n, crea una instancia y la inyecta en el elemento afectado, sin interferir en la clase misma. Cuando una aplicaci\u00f3n necesita la informaci\u00f3n de las anotaciones, puede obtener la instancia inyectada.</p> <p>Por ejemplo, en la clase <code>Modul</code> que hab\u00edamos definido, utilizar\u00edamos la anotaci\u00f3n <code>@XmlRootElement</code> para indicar el elemento ra\u00edz del m\u00f3dulo, y las anotaciones <code>@XmlElement</code> para indicar que los setters de la clase tambi\u00e9n escribir\u00e1n elementos XML.</p> <pre><code>@XmlRootElement\nclass Modulo { \n\nString nombre; \nint horas; \ndouble nota; \n\npublic String getNom() { return nombre; } \n@XmlElement \npublic void setNom(String nombre) { this.nom = nombre; } \n\n\npublic int getHores() { return horas; } \n@XmlElement \npublic void setHores(int horas) { this.hores = horas; } \n\npublic double getNota() { return nota; } \n@XmlElement \npublic void setNota(double nota) { this.nota = nota;}\n\n\n}\n</code></pre> <p>Con esto tendr\u00edamos s\u00f3lo la clase con las anotaciones preparadas para guardar un m\u00f3dulo como documento XML. Para guardar toda la jerarqu\u00eda deber\u00edamos crear la clase <code>Curso</code>, que contendr\u00eda un <code>ArrayList</code> de m\u00f3dulos.</p>"},{"location":"Unidad%201%20Ficheros/3_XML_Files.es/#37-ejemplos-con-el-xml-inicial","title":"3.7. Ejemplos con el XML inicial","text":"<p>\ud83d\udcd6 Ejemplo 1: Lectura de XML con DOM</p> <pre><code>package org.dam;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport java.io.File;\n\npublic class LecturaCursoXML {\n    public static void main(String[] args) {\n        try {\n            File archivo = new File(\"curso.xml\");\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(archivo);\n\n            document.getDocumentElement().normalize();\n\n            System.out.println(\"Elemento ra\u00edz: \" + document.getDocumentElement().getNodeName());\n\n            NodeList listaModulos = document.getElementsByTagName(\"modulo\");\n\n            System.out.println(\"\\n=== M\u00d3DULOS DEL CURSO ===\");\n            System.out.printf(\"%-45s %-8s %-12s%n\", \"Nombre\", \"Horas\", \"Calificaci\u00f3n\");\n            System.out.println(\"--------------------------------------------------------------\");\n\n            for (int i = 0; i &lt; listaModulos.getLength(); i++) {\n                Node nodo = listaModulos.item(i);\n\n                if (nodo.getNodeType() == Node.ELEMENT_NODE) {\n                    Element elemento = (Element) nodo;\n\n                    String nombre = elemento.getElementsByTagName(\"nombre\").item(0).getTextContent();\n                    String horas = elemento.getElementsByTagName(\"horas\").item(0).getTextContent();\n                    String calificacion = elemento.getElementsByTagName(\"calificacion\").item(0).getTextContent();\n\n                    System.out.printf(\"%-45s %-8s %-12s%n\",\n                            nombre.length() &gt; 40 ? nombre.substring(0, 40) + \"...\" : nombre,\n                            horas,\n                            calificacion);\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}   \n</code></pre> <p>\ud83d\udcdd Ejemplo 2: Escritura de XML con DOM</p> <pre><code>package org.dam;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport java.io.File;\n\npublic class EscrituraCursoXML {\n    public static void main(String[] args) {\n        try {\n            // Crear el DocumentBuilder\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.newDocument();\n\n            // Crear el elemento ra\u00edz &lt;curso&gt;\n            Element curso = document.createElement(\"curso\");\n            document.appendChild(curso);\n\n            // Crear m\u00f3dulos seg\u00fan la estructura proporcionada\n            crearModulo(document, curso, \"Acceso a Datos\", 6, 8.45);\n            crearModulo(document, curso, \"Programaci\u00f3n de servicios y procesos\", 3, 9.0);\n            crearModulo(document, curso, \"Desarrollo de interfaces\", 6, 8.0);\n            crearModulo(document, curso, \"Programaci\u00f3n Multimedia y dispositivos m\u00f3viles\", 5, 7.34);\n            crearModulo(document, curso, \"Sistemas de Gesti\u00f3n Empresarial\", 5, 8.2);\n            crearModulo(document, curso, \"Empresa e iniciativa emprendedora\", 3, 7.4);\n\n            // Escribir el contenido en un archivo XML\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, \"yes\");\n            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\n            DOMSource source = new DOMSource(document);\n            StreamResult result = new StreamResult(new File(\"curso.xml\"));\n\n            transformer.transform(source, result);\n\n            System.out.println(\"Archivo XML creado correctamente!\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void crearModulo(Document document, Element curso, String nombre,\n                                    int horas, double calificacion) {\n        Element modulo = document.createElement(\"modulo\");\n        curso.appendChild(modulo);\n\n        Element nom = document.createElement(\"nombre\");\n        nom.appendChild(document.createTextNode(nombre));\n        modulo.appendChild(nom);\n\n        Element horasElem = document.createElement(\"horas\");\n        horasElem.appendChild(document.createTextNode(String.valueOf(horas)));\n        modulo.appendChild(horasElem);\n\n        Element calificacionElem = document.createElement(\"calificacion\");\n        calificacionElem.appendChild(document.createTextNode(String.valueOf(calificacion)));\n        modulo.appendChild(calificacionElem);\n    }\n}\n</code></pre> <p>\ud83c\udfd7\ufe0f Ejemplo 3: JAXB - Escritura y Lectura</p> <p>Clase Modulo para JAXB:</p> <p><pre><code>package org.dam;\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport jakarta.xml.bind.annotation.XmlType;\n\n@XmlRootElement(name = \"m\u00f3dulo\")\n@XmlType(propOrder = {\"nombre\", \"horas\", \"calificacion\"})\npublic class Modulo {\n    private String nombre;\n    private int horas;\n    private double calificacion;\n\n    public Modulo() {\n        // Constructor por defecto necesario para JAXB\n    }\n\n    public Modulo(String nombre, int horas, double calificacion) {\n        this.nombre = nombre;\n        this.horas = horas;\n        this.calificacion = calificacion;\n    }\n\n    @XmlElement(name = \"nom\")\n    public String getNombre() { return nombre; }\n    public void setNombre(String nombre) { this.nombre = nombre; }\n\n    @XmlElement(name = \"horas\")\n    public int getHoras() { return horas; }\n    public void setHoras(int horas) { this.horas = horas; }\n\n    @XmlElement(name = \"calificaci\u00f3n\")\n    public double getCalificacion() { return calificacion; }\n    public void setCalificacion(double calificacion) { this.calificacion = calificacion; }\n\n    @Override\n    public String toString() {\n        return String.format(\"%-40s %d horas - %.2f\",\n                nombre.length() &gt; 35 ? nombre.substring(0, 35) + \"...\" : nombre,\n                horas, calificacion);\n    }\n}\n</code></pre> Clase Curso para JAXB:</p> <pre><code>package org.dam;\n\nimport jakarta.xml.bind.annotation.XmlElement;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@XmlRootElement(name = \"curso\")\npublic class Curso {\n    private List&lt;Modulo&gt; modulos = new ArrayList&lt;&gt;();\n\n    @XmlElement(name = \"modulo\")\n    public List&lt;Modulo&gt; getModulos() { return modulos; }\n    public void setModulos(List&lt;Modulo&gt; modulos) { this.modulos = modulos; }\n\n    public void addModulo(Modulo modulo) {\n        modulos.add(modulo);\n    }\n}\n</code></pre> <p>Escritura con JAXB:</p> <pre><code>package org.dam;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.Marshaller;\nimport java.io.File;\n\npublic class EscrituraJAXBCurso {\n    public static void main(String[] args) {\n        try {\n            // Crear el curso con m\u00f3dulos\n            Curso curso = new Curso();\n            curso.addModulo(new Modulo(\"Acceso a Datos\", 6, 8.45));\n            curso.addModulo(new Modulo(\"Programaci\u00f3n de servicios y procesos\", 3, 9.0));\n            curso.addModulo(new Modulo(\"Desarrollo de interfaces\", 6, 8.0));\n            curso.addModulo(new Modulo(\"Programaci\u00f3n Multimedia y dispositivos m\u00f3viles\", 5, 7.34));\n            curso.addModulo(new Modulo(\"Sistemas de Gesti\u00f3n Empresarial\", 5, 8.2));\n            curso.addModulo(new Modulo(\"Empresa e iniciativa emprendedora\", 3, 7.4));\n\n            // Configurar JAXB\n            JAXBContext context = JAXBContext.newInstance(Curso.class);\n            Marshaller marshaller = context.createMarshaller();\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n            marshaller.setProperty(Marshaller.JAXB_ENCODING, \"UTF-8\");\n\n            // Escribir en archivo\n            marshaller.marshal(curso, new File(\"curso_jaxb.xml\"));\n            System.out.println(\"XML creado con JAXB exitosamente!\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>Lectura con JAXB:</p> <p><pre><code>package org.dam;\n\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.Unmarshaller;\nimport java.io.File;\n\npublic class LecturaJAXBCurso {\n    public static void main(String[] args) {\n        try {\n            JAXBContext context = JAXBContext.newInstance(Curso.class);\n            Unmarshaller unmarshaller = context.createUnmarshaller();\n\n            Curso curso = (Curso) unmarshaller.unmarshal(new File(\"curso_jaxb.xml\"));\n\n            System.out.println(\"=== M\u00d3DULOS DEL CURSO (JAXB) ===\");\n            System.out.printf(\"%-45s %-8s %-12s%n\", \"Nombre\", \"Horas\", \"Calificaci\u00f3n\");\n            System.out.println(\"--------------------------------------------------------------\");\n\n            for (Modulo modulo : curso.getModulos()) {\n                System.out.println(modulo);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> Recuerda a\u00f1adir la dependencia de jakarta en el pom.xml</p> <pre><code>        &lt;!-- https://mvnrepository.com/artifact/jakarta.xml.bind/jakarta.xml.bind-api --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.2&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Por lo que se refiere a este curso, no profundizaremos m\u00e1s en esta t\u00e9cnica, ya que para nuestros prop\u00f3sitos, el an\u00e1lisis XML que hemos visto en las secciones anteriores es suficiente, o no :)</p> <p>Cada vez m\u00e1s</p> <p>Utilizaremos muchas anotaciones en este curso, mantenga la calma...</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/","title":"4. Archivos JSON","text":"<p>JSON es otro formato de texto ligero para el intercambio de datos. JSON significa JavaScript Object Notation y es un subconjunto de la notaci\u00f3n literal de objetos del lenguaje, que se ha adoptado junto con XML como uno de los principales est\u00e1ndares para el intercambio y almacenamiento de datos.</p> <p>Una de las ventajas de JSON respecto a XML es la facilidad de escribir analizadores, pero lo que es m\u00e1s importante es que expresa lo mismo que XML pero de una forma mucho m\u00e1s concreta y concisa, por lo que se utiliza habitualmente en entornos donde el flujo de datos es importante, como es el caso de los servidores de Google, Yahoo, etc., que atienden a millones de usuarios.</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#41-formato-json","title":"4.1. Formato JSON","text":"<p>La especificaci\u00f3n completa puede verse aqu\u00ed</p> <p>Los tipos de datos que podemos representar en JSON son:</p> <ul> <li>N\u00fameros, tanto enteros como decimales.</li> <li>Cadenas de texto, expresadas entre comillas y con la posibilidad de incluir secuencias de escape.</li> <li>Booleans, para representar los valores <code>true</code> y <code>false</code>.</li> <li>Null, para representar el valor <code>null</code>.</li> <li>Array, para representar listas de cero o m\u00e1s valores, de cualquier tipo, cerradas entre corchetes y separadas por comas.</li> <li>Objetos, como colecciones de pares <code>&lt;clave&gt;:&lt;valor&gt;</code>, separados por comas y entre claves, y de cualquier tipo de valor.</li> </ul> <p>Lo veremos mejor con un ejemplo bien conocido: el de los m\u00f3dulos con los que estamos trabajando:</p> <pre><code>{ \n\"curso\": [ \n{ \n\"nombre\": \"Acceso a Datos\", \n\"horas\": 6, \n\"calificaci\u00f3n\": 8.45 \n}, \n{ \n\"nombre\": \"Programaci\u00f3n de servicios y procesos\", \n\"horas\": 3, \n\"calificaci\u00f3n\": 9.0 \n}, \n{ \n\"nombre\": \"Desarrollo de interfaces\", \n\"horas\": 6, \n\"calificaci\u00f3n\": 8.0 \n}, \n{ \n\"nombre\": \"Programaci\u00f3n Multimedia y dispositivos m\u00f3viles\", \n\"horas\": 5, \n\"calificaci\u00f3n\": 7.34 \n}, \n{ \n\"nombre\": \"Sistemas de Gesti\u00f3n Empresarial\", \n\"horas\": 5, \n\"calificaci\u00f3n\": 8.2 \n}, \n{ \n\"nombre\": \"Empresa e iniciativa emprendedora\", \n\"horas\": 3, \n\"calificaci\u00f3n\": 7.4 \n} \n]\n}\n</code></pre> <p>Veremos c\u00f3mo <code>curso</code> es un array o una lista de m\u00f3dulos (aunque ahora no utilizamos la etiqueta \"m\u00f3dulo\"), que en este caso son objetos con tres elementos: el nombre, que es una cadena de caracteres, las horas, que es un entero, y la calificaci\u00f3n, que se representa como un n\u00famero decimal. Cabe destacar que, como en XML, tambi\u00e9n necesitamos un objeto ra\u00edz, en este caso el elemento \"curso\".</p> <p>Internet est\u00e1 lleno de servicios que ofrecen informaci\u00f3n en formato JSON. Por ejemplo, puede visitar:</p> <ul> <li>https://arkhamdb.com/api/public/card/01001</li> <li>https://swapi.dev/api/films/1/</li> <li>http://hp-api.herokuapp.com/api/characters</li> </ul> <p>Existe una amplia gama de librer\u00edas de Java para manipular documentos JSON (GSON, Jackson, JSON.simple...). En nuestro caso, utilizaremos la librer\u00eda <code>org.json</code>, que podemos consultar en el repositorio Maven: https://mvnrepository.com/artifact/org.json/json</p> <p>En la siguiente secci\u00f3n comentaremos la funcionalidad de la librer\u00eda, y en un documento adjunto, veremos c\u00f3mo incorporarla a nuestros proyectos mediante el gestor de dependencias Gradle.</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#42-gson","title":"4.2. <code>Gson</code>","text":"<p>Gson es una biblioteca Java que permite convertir objetos Java a su representaci\u00f3n JSON. Tambi\u00e9n permite convertir una cadena JSON en un objeto Java equivalente. Gson puede trabajar con cualquier objeto Java, incluyendo objetos preexistentes cuyo c\u00f3digo fuente no se conoce.</p> <p>Existen algunos proyectos de c\u00f3digo abierto que permiten convertir objetos Java a JSON. Sin embargo, la mayor\u00eda requiere la inclusi\u00f3n de anotaciones Java en las clases, algo que no es posible si no se tiene acceso al c\u00f3digo fuente. Adem\u00e1s, la mayor\u00eda no admite completamente el uso de gen\u00e9ricos de Java. Gson considera ambos objetivos de dise\u00f1o muy importantes.</p> <p>Gson se centra principalmente en Java. Usarlo con otros lenguajes JVM como Kotlin o Scala puede funcionar correctamente en muchos casos, pero las caracter\u00edsticas espec\u00edficas de cada lenguaje, como los tipos no nulos de Kotlin o los constructores con argumentos predeterminados, no son compatibles. Esto puede generar un comportamiento confuso e incorrecto. Al usar lenguajes distintos de Java, es preferible una biblioteca JSON con soporte expl\u00edcito para ese lenguaje.</p>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#objetivos","title":"Objetivos","text":"<ul> <li>Proporcionar m\u00e9todos simples <code>toJson()</code> y <code>fromJson()</code> para convertir objetos Java a JSON y viceversa.</li> <li>Permitir la conversi\u00f3n de objetos preexistentes no modificables a y desde JSON.</li> <li>Amplio soporte para gen\u00e9ricos de Java.</li> <li>Permitir representaciones personalizadas de objetos.</li> <li>Admitir objetos de complejidad arbitraria (con jerarqu\u00edas de herencia profundas y uso extensivo de tipos gen\u00e9ricos).</li> </ul>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#42-clase-modulo","title":"4.2. Clase Modulo","text":"<p>Nuestros ejemplos se basan en los datos de los m\u00f3dulos de DAM vistos en las secciones anteriores. Considera este bloque de c\u00f3digo como punto de partida donde se crea un array <code>curso</code> y se llena con m\u00f3dulos. Para ello creamos la clase Modulo:</p> Modulo.java<pre><code>package org.example.pojo;\n\npublic class Modulo {\n    private String nombre;\n    private int horas;\n    private double nota;\n\n    // Constructores\n    public Modulo() {}  // Necesario para GSON\n\n    public Modulo(String nombre, int horas, double nota) {\n        this.nombre = nombre;\n        this.horas = horas;\n        this.nota = nota;\n    }\n\n    // Getters y Setters\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getHoras() {\n        return horas;\n    }\n\n    public double getNota() {\n        return nota;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s (%d horas) - Nota: %.2f\", nombre, horas, nota);\n    }\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#43-clase-curso","title":"4.3. Clase Curso","text":"<p>La clase Curso se va a considerar el contenedor principal. </p> <ul> <li>Se hace uso de <code>@SerializedName</code> para garantizar el mapeo exacto con el campo <code>curso</code>del JSON.</li> <li>M\u00e9todos de conversi\u00f3n integrados (<code>toJson()</code>/<code>fromJson()</code>).</li> </ul> Curso.java<pre><code>package org.example.pojo;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.annotations.SerializedName;\nimport java.util.List;\n\npublic class Curso {\n    @SerializedName(\"curso\")  // Anotaci\u00f3n para mapear exactamente el campo JSON\n    private List&lt;Modulo&gt; modulos;\n\n    // Constructor necesario para GSON\n    public Curso() {\n    }\n\n    // Constructor para creaci\u00f3n manual\n    public Curso(List&lt;Modulo&gt; modulos) {\n        this.modulos = modulos;\n    }\n\n    // Getter y Setter (obligatorios para GSON)\n    public List&lt;Modulo&gt; getModulos() {\n        return modulos;\n    }\n\n    public void setModulos(List&lt;Modulo&gt; modulos) {\n        this.modulos = modulos;\n    }\n\n    // M\u00e9todo para facilitar la conversi\u00f3n a JSON\n    public String toJson() {\n        return new GsonBuilder().setPrettyPrinting().create().toJson(this);\n    }\n\n    // M\u00e9todo est\u00e1tico para crear desde JSON\n    public static Curso fromJson(String json) {\n        return new Gson().fromJson(json, Curso.class);\n    }\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#44-clase-cursofileutils","title":"4.4. Clase CursoFileUtils","text":"<p>Esta clase contendr\u00e1 un par de m\u00e9todos que nos permitir\u00e1n guardar y leer los cursos del fichero JSON</p> CursoFileUtils.java<pre><code>package org.example.utils;\n\nimport org.example.pojo.Curso;\n\nimport java.io.*;\n\npublic class CursoFileUtils {\n    public static void guardarCurso(Curso curso, String filePath) throws IOException {\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(curso.toJson());\n        }\n    }\n\n    public static Curso cargarCurso(String filePath) throws IOException {\n        try (FileReader reader = new FileReader(filePath)) {\n            StringBuilder json = new StringBuilder();\n            int c;\n            while ((c = reader.read()) != -1) {\n                json.append((char) c);\n            }\n            return Curso.fromJson(json.toString());\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/4_JSON_Files.es/#44-clase-main","title":"4.4. Clase Main","text":"<p>Desde la clase Main podemos ver el funcionamiento del mismo</p> Main.java<pre><code>package org.example;\n\nimport org.example.pojo.Curso;\nimport org.example.pojo.Modulo;\nimport org.example.utils.CursoFileUtils;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            // 1. Crear datos\n            List&lt;Modulo&gt; modulos = Arrays.asList(\n                    new Modulo(\"Acceso a Datos\", 6, 8.45),\n                    new Modulo(\"Programaci\u00f3n\", 3, 9.0)\n            );\n\n            Curso curso = new Curso(modulos);\n\n            // 2. Guardar en archivo\n            CursoFileUtils.guardarCurso(curso, \"2dam.json\");\n            System.out.println(\"Datos guardados correctamente\");\n\n            // 3. Cargar desde archivo\n            Curso cursoCargado = CursoFileUtils.cargarCurso(\"2dam.json\");\n            System.out.println(\"\\nM\u00f3dulos cargados:\");\n            cursoCargado.getModulos().forEach(System.out::println);\n\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>Con esta separaci\u00f3n obtenemos la siguiente estructura:</p> <ol> <li>Anotaci\u00f3n @SerializedName: Garantiza el mapeo exacto con el campo \"curso\" del JSON.</li> <li>Separaci\u00f3n de responsabilidades:<ol> <li>Curso maneja la estructura contenedora</li> <li>Modulo maneja los datos individuales</li> <li>CursoFileUtils gestiona la persistencia</li> </ol> </li> <li>M\u00e9todos de conversi\u00f3n integrados (<code>toJson()</code>/<code>fromJson()</code>).</li> <li>Manejo seguro de recursos con try-with-resources.</li> </ol>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/","title":"5. Formatos extra","text":"<p>En esta secci\u00f3n estudiaremos dos tipos de archivos de texto que se utilizan ampliamente en inform\u00e1tica y la forma de trabajar con ellos.</p>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#51-archivos-csv","title":"5.1. Archivos CSV","text":"<p>Un archivo de valores separados por comas (CSV) es un archivo de texto est\u00e1ndar que utiliza una coma (<code>,</code>) para separar los valores. Cada l\u00ednea del archivo consiste en uno o m\u00e1s campos separados por comas. Cada campo puede o no estar cerrado entre comillas dobles. Adem\u00e1s, varios formatos utilizan distintos caracteres como separador, como el punto y coma (<code>;</code>) o el s\u00edmbolo de numeral (<code>#</code>). RFC 4180 define el formato o definiciones de un archivo CSV o archivo de texto/csv.</p> <p>En caso de que el s\u00edmbolo utilizado como separador aparezca dentro de los valores, es buena idea cerrar el contenido entre comillas. Se puede ver un ejemplo de archivo CSV aqu\u00ed:</p> <pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.0;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.0;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;0;8;383.0;170.0;3563.0;10.0;70;US\nPlymouth Cuda 340;0;8;340.0;160.0;3609.0;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.0;8.0;70;US\n</code></pre> <p>La forma de procesar un archivo CSV en Java es:</p> <ol> <li>Abrir el archivo como archivo de texto para la lectura. Debemos leer l\u00ednea por l\u00ednea, ya que cada l\u00ednea es un registro. Leer una l\u00ednea en una variable de tipo <code>String</code>.</li> <li>Procesar los registros individuales: </li> <li>Podemos separar cada campo. Una buena opci\u00f3n es utilizar el m\u00e9todo <code>split(char)</code> de la clase String. Obtengamos un array de cadenas con los valores de los campos individuales. </li> <li>Procesar cada valor de campo seg\u00fan sus necesidades.</li> </ol> <p>Atenci\u00f3n</p> <p>Es una buena idea empezar a utilizar las clases abstractas <code>Files</code> y <code>Paths</code>. Estas clases mejoran el uso de la clase File y sus clases derivadas, ofreciendo m\u00e9todos \u00fatiles que nos permiten realizar operaciones r\u00e1pidas con menos l\u00edneas de c\u00f3digo. Por ejemplo, la siguiente l\u00ednea, a partir del <code>filename</code>, la abre y despu\u00e9s lee todo el archivo, devolviendo una lista con las l\u00edneas separadas en cada elemento de la colecci\u00f3n. </p> <pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename)); \n</code></pre> <p>Veamos como podr\u00edamos estrcuturar nuestro programa para poder leer de un fichero CSV con esta estructura.</p> <p>Para ello nos definimos la clase Coche:</p> <pre><code>package org.dam;\n\n// Clase para representar un coche con los campos correctos\npublic class Coche {\n    String nombre;\n    int kilometros;\n    int velocidades;\n    double potenciaCV;\n    double potenciaKW;\n    double cilindrada;\n    double aceleracion0a100;\n    int decada;\n    String paisFabricacion;\n\n    public Coche(String[] datos) {\n        this.nombre = datos[0];\n        this.kilometros = Integer.parseInt(datos[1]);\n        this.velocidades = Integer.parseInt(datos[2]);\n        this.potenciaCV = Double.parseDouble(datos[3]);\n        this.potenciaKW = Double.parseDouble(datos[4]);\n        this.cilindrada = Double.parseDouble(datos[5]);\n        this.aceleracion0a100 = Double.parseDouble(datos[6]);\n        this.decada = Integer.parseInt(datos[7]);\n        this.paisFabricacion = datos[8];\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s - %d km, %d vel, %.1f CV, %.1f KW, %.1f cc, %.1f s (0-100), %ds, %s\",\n                nombre, kilometros, velocidades, potenciaCV, potenciaKW,\n                cilindrada, aceleracion0a100, decada, paisFabricacion);\n    }\n\n    // M\u00e9todo para mostrar informaci\u00f3n formateada\n    public String mostrarInfoDetallada() {\n        return String.format(\n                \"\\n=== %s ===\\n\" +\n                        \"Kil\u00f3metros: %d km\\n\" +\n                        \"N\u00famero de velocidades: %d\\n\" +\n                        \"Potencia: %.1f CV (%.1f KW)\\n\" +\n                        \"Cilindrada: %.1f cc\\n\" +\n                        \"Aceleraci\u00f3n 0-100 km/h: %.1f segundos\\n\" +\n                        \"D\u00e9cada: %ds\\n\" +\n                        \"Pa\u00eds de fabricaci\u00f3n: %s\",\n                nombre, kilometros, velocidades, potenciaCV, potenciaKW,\n                cilindrada, aceleracion0a100, decada, paisFabricacion\n        );\n    }\n}\n</code></pre> <p>Ahora el programa principal</p> <pre><code>package org.dam;\n\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LectorCSVCoches {\n\n    public static void main(String[] args) {\n        String fichero = \"coches.csv\";\n\n        try {\n            // Leer todas las l\u00edneas del archivo CSV\n            List&lt;String&gt; lines = Files.readAllLines(Paths.get(fichero));\n            List&lt;Coche&gt; coches = new ArrayList&lt;&gt;();\n\n            System.out.println(\"=== LECTURA DE ARCHIVO CSV DE COCHES ===\");\n            System.out.println(\"N\u00famero total de registros: \" + lines.size());\n\n            // Procesar cada l\u00ednea del archivo\n            for (int i = 0; i &lt; lines.size(); i++) {\n                String line = lines.get(i);\n                String[] campos = line.split(\";\");\n\n                // Verificar que tenga todos los campos necesarios\n                if (campos.length &gt;= 9) {\n                    try {\n                        Coche coche = new Coche(campos);\n                        coches.add(coche);\n                        System.out.println(coche.mostrarInfoDetallada());\n                    } catch (NumberFormatException e) {\n                        System.err.println(\"Error en formato num\u00e9rico en l\u00ednea \" + (i+1) + \": \" + line);\n                    }\n                } else {\n                    System.err.println(\"L\u00ednea incompleta \" + (i+1) + \": \" + line);\n                }\n            }\n\n            // Mostrar estad\u00edsticas generales\n            mostrarEstadisticas(coches);\n\n        } catch (IOException e) {\n            System.err.println(\"Error al leer el archivo: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    // M\u00e9todo para mostrar estad\u00edsticas de los coches\n    private static void mostrarEstadisticas(List&lt;Coche&gt; coches) {\n        if (coches.isEmpty()) return;\n\n        System.out.println(\"\\n=== ESTAD\u00cdSTICAS GENERALES ===\");\n\n        double totalPotenciaCV = 0;\n        double totalPotenciaKW = 0;\n        double totalCilindrada = 0;\n        double totalAceleracion = 0;\n        int totalKilometros = 0;\n\n        for (Coche coche : coches) {\n            totalPotenciaCV += coche.potenciaCV;\n            totalPotenciaKW += coche.potenciaKW;\n            totalCilindrada += coche.cilindrada;\n            totalAceleracion += coche.aceleracion0a100;\n            totalKilometros += coche.kilometros;\n        }\n\n        System.out.printf(\"N\u00famero de coches: %d%n\", coches.size());\n        System.out.printf(\"Potencia media: %.1f CV (%.1f KW)%n\",\n                totalPotenciaCV / coches.size(), totalPotenciaKW / coches.size());\n        System.out.printf(\"Cilindrada media: %.1f cc%n\", totalCilindrada / coches.size());\n        System.out.printf(\"Aceleraci\u00f3n media 0-100: %.1f segundos%n\", totalAceleracion / coches.size());\n        System.out.printf(\"Kil\u00f3metros totales: %d km%n\", totalKilometros);\n\n        // Agrupar por pa\u00eds\n        System.out.println(\"\\n=== COCHES POR PA\u00cdS ===\");\n        coches.stream()\n                .collect(java.util.stream.Collectors.groupingBy(c -&gt; c.paisFabricacion,\n                        java.util.stream.Collectors.counting()))\n                .forEach((pais, count) -&gt; System.out.printf(\"%s: %d coches%n\", pais, count));\n    }\n}\n</code></pre> <p>M\u00e1s informaci\u00f3n en: </p> <ul> <li>Files </li> <li>Paths</li> </ul>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#52-archivos-de-propiedades","title":"5.2. Archivos de propiedades","text":""},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#521-archivo-de-propiedades","title":"5.2.1. Archivo de propiedades","text":"<p>Por \u00faltimo, pero no menos importante, le mostraremos un tipo de archivo de texto importante, que son los archivos de propiedades. Estos archivos almacenan, como ya sab\u00e9is, varias propiedades que se utilizan durante la ejecuci\u00f3n del programa. Cuando el programa se inicia, carga estas propiedades y ajusta varias opciones. Ejemplos de estos archivos son <code>my.conf</code> en MySQL, <code>php.ini</code> en PHP, etc.</p> <p>El aspecto de este archivo consiste en varias l\u00edneas (una por propiedad) y cada l\u00ednea tiene el formato <code>atributo=valor</code>. Por ejemplo, un supuesto archivo:</p> <pre><code># properties of my program\npuerto=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>La forma de procesar un archivo de propiedades en Java es similar a un CSV:</p> <ol> <li>Abrir como archivo de texto para la lectura. Debemos leer l\u00ednea por l\u00ednea, ya que cada l\u00ednea es una propiedad distinta. Leer una l\u00ednea en una variable de tipo <code>String</code>.</li> <li>Procesar los registros individuales: </li> <li>Podemos separar cada campo. Una buena opci\u00f3n es utilizar el m\u00e9todo <code>split(char)</code> de la clase String. Obtengamos un array de cadenas con los valores de los campos individuales. Los separadores normalmente son <code>=</code>, <code>:</code>. </li> <li>La izquierda del separador es el nombre de la propiedad. </li> <li>La derecha del separador es el valor de la propiedad. </li> <li>Hay que tener en cuenta que si una l\u00ednea comienza con barra (<code>#</code>), es un comentario y se ignorar\u00e1.</li> </ol>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#522-propiedades-de-java","title":"5.2.2. Propiedades de Java","text":"<p>Java tiene un objeto muy \u00fatil para manejar este tipo de informaci\u00f3n. Con los objetos preperties de Java, podemos almacenar un conjunto de propiedades con una tabla de hash (b\u00e1sicamente una pareja clave-valor). Tiene m\u00e9todos preparados para cargar y guardar desde y hacia flujos de texto o, incluso, archivos XML. Algunos m\u00e9todos interesantes para las propiedades son:</p> <p>Lectura desde archivo (texto o XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Lee un conjunto de propiedades (parejas clave-elemento) desde el flujo de entrada de bytes.</li> <li><code>void load(Reader reader)</code> \u2192 Lee un conjunto de propiedades (parejas clave-elemento) desde el flujo de entrada de caracteres en un formato sencillo orientado a l\u00edneas.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Carga todas las propiedades representadas por el documento XML en el flujo de entrada especificado en esta tabla de propiedades.</li> </ul> <p>Escritura en archivo (texto o XML)</p> <ul> <li><code>void store(OutputStream out, Str.ing comments)</code> \u2192 Escribe este conjunto de propiedades (parejas clave-elemento) en esta tabla de propiedades en el flujo de salida en un formato adecuado para cargarlo en una tabla de propiedades utilizando el m\u00e9todo load(InputStream).</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Escribe este conjunto de propiedades (parejas clave-elemento) en esta tabla de propiedades en el flujo de caracteres de salida en un formato adecuado para utilizar el m\u00e9todo load(Reader).</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emite un documento XML que representa todas las propiedades contenidas en esta tabla.</li> </ul> <p>Trabajo con propiedades (heredado de HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Devuelve una vista de conjunto de las claves contenidas en este mapa.</li> <li><code>V get(Object key)</code> \u2192 Devuelve el valor (<code>V</code>) al que se asigna la clave especificada, o <code>null</code> si este mapa no contiene ninguna asignaci\u00f3n para la clave.</li> <li><code>boolean containsKey(Object key)</code> Comprueba si el objeto especificado es una clave de esta tabla de hash.</li> <li><code>V put(K key, V value)</code> \u2192 Asigna la clave especificada al valor especificado en esta tabla de hash.</li> <li><code>V remove(Object key)</code> \u2192 Elimina la clave (y se devuelve el valor correspondiente) de esta tabla de hash.</li> </ul>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#523-programa-de-ejemplo","title":"5.2.3. Programa de ejemplo","text":"<p>En el siguiente programa, puede ver un ejemplo de lectura y creaci\u00f3n de archivos de propiedades en Java.</p> <pre><code>package org.dam;\n\nimport java.io.*;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class PropertiesManager {\n\n    /**\n     * Carga el archivo especificado y muestra sus propiedades de diferentes maneras\n     * @param fichero\n     */\n    private void loadAndShowProperties(String fichero) {\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(fichero)));\n\n            System.out.println(\"=== CONJUNTO COMPLETO ===\");\n            System.out.println(properties);\n            System.out.println();\n\n            System.out.println(\"=== SALIDA DE LISTA ===\");\n            properties.list(System.out);\n            System.out.println();\n\n            Set&lt;Object&gt; keys = properties.keySet();\n\n                System.out.println(\"=== MI LISTADO ===\");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            System.err.println(\"Fichero no encontrado \" + fichero);\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.err.println(\"Error leyendo fichero: \" + fichero);\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Crear un objeto de propiedades, rellenado con muestras y almacenado\n     * en un archivo de texto y un archivo XML.\n     * @throws IOException\n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        // Almacenado en fichero de texto\n        props.store(new FileWriter(new File(\"promise.properties\")), \"Ejemplo fichero de propiedades\");\n\n        // Almacenado en fichero XML\n        props.storeToXML(new FileOutputStream(new File(\"promise.xml\")), \"Ejemplo de propiedades en XML\");\n\n        System.out.println(\"Fichero de Properties creado satisfactoriamente!\");\n        System.out.println(\"Fichero de texto: promise.properties\");\n        System.out.println(\"Fichero XML: promise.xml\");\n    }\n\n    /**\n     * M\u00e9todo principal para demostrar la funcionalidad\n     */\n    public static void main(String[] args) {\n        PropertiesManager manager = new PropertiesManager();\n\n        try {\n            // First, create the properties files\n            System.out.println(\"Creando ficheros...\");\n            manager.writeProperties();\n            System.out.println();\n\n            // Then, read and display the properties from the text file\n            System.out.println(\"Leyendo el fichero de propiedades...\");\n            manager.loadAndShowProperties(\"promise.properties\");\n            System.out.println();\n\n            // Also read and display from the XML file\n            System.out.println(\"Leyendo el fichero en XML..\");\n            manager.loadAndShowProperties(\"promise.xml\");\n\n        } catch (IOException e) {\n            System.err.println(\"Error en la ejecuci\u00f3n del programa principal: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#53-entorno-archivos-env-y-dot_env","title":"5.3. Entorno, archivos <code>.env</code> y <code>dot_env</code>","text":""},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#531-por-que-utilizar-variables-de-entorno","title":"5.3.1. \u00bfPor qu\u00e9 utilizar variables de entorno?","text":"<p>Las variables de entorno son un aspecto crucial para configurar y gestionar aplicaciones en distintos entornos, como desarrollo, pruebas y producci\u00f3n. Proporcionan una forma de pasar din\u00e1micamente datos de configuraci\u00f3n a las aplicaciones sin codificar valores directamente al c\u00f3digo fuente. Este enfoque mejora la flexibilidad, portabilidad y seguridad de las aplicaciones.</p> <p>En Java, acceder a las variables de entorno es sencillo gracias a la clase <code>System</code>, que proporciona m\u00e9todos para obtener las variables de entorno. Esta capacidad es especialmente \u00fatil para:</p> <ul> <li>Configurar par\u00e1metros de la aplicaci\u00f3n tales como URL de bases de datos, claves de API y rutas de archivos.</li> <li>Gestionar configuraciones espec\u00edficas del entorno sin alterar el c\u00f3digo fuente.</li> <li>Mantener informaci\u00f3n sensible, tales como contrase\u00f1as y tokens, fuera del c\u00f3digo fuente.</li> </ul> <p>Entendiendo c\u00f3mo utilizar de forma efectiva las variables de entorno en Java, los desarrolladores pueden crear aplicaciones m\u00e1s adaptables y seguras.</p>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#532-obtener-variables-de-entorno","title":"5.3.2. Obtener variables de entorno","text":"<p>Para acceder a las variables de entorno en Java, puede utilizar el m\u00e9todo <code>System.getenv()</code>. Este m\u00e9todo est\u00e1 sobrecargado y puede ser:</p> <ul> <li><code>System.getenv()</code> \u2192 devuelve un objeto <code>Map</code> que contiene todas las variables de entorno y sus valores correspondientes.</li> <li><code>System.getenv(String)</code> \u2192 devuelve una <code>String</code> con el valor de la variable de entorno espec\u00edfica o null si no existe.</li> </ul> <p>C\u00f3mo recuperar las variables de entorno en Java:</p> <pre><code>Map&lt;String, String&gt; env = System.getenv(); \n\n// Acceder a una variable de entorno espec\u00edfica \nString value = env.get(\"NOMBRE_VARIABLE\"); \n\n// Imprimir todas las variables de entorno \nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) { \nSystem.out.println(entry.getKey() + \" = \" + entry.getValue()); \n} \n</code></pre> <p>Tenga en cuenta que: </p> <ul> <li>La clase Map devuelve una colecci\u00f3n de entradas con parejas clave-valor. </li> <li>Las variables de entornorn distinguen entre may\u00fasculas y min\u00fasculas, as\u00ed que aseg\u00farese de utilizar las may\u00fasculas de forma correcta al acceder a ellas.</li> </ul>"},{"location":"Unidad%201%20Ficheros/5_Extra_Formats.es/#533-la-alternativa-dot-env","title":"5.3.3. La alternativa <code>dot-env</code>","text":"<p>Almacenar la configuraci\u00f3n en el entorno es uno de los principios de una aplicaci\u00f3n de doce factores. Cualquier cosa que pueda cambiar entre los entornos de despliegue, como los recursos de las bases de datos o las credenciales de los servicios externos, debe extraerse del c\u00f3digo y almacenarse en variables de entorno.</p> <p>Pero no siempre es pr\u00e1ctico establecer variables de entorno en m\u00e1quinas de desarrollo o servidores de integraci\u00f3n continua en los que se ejecutan varios proyectos. <code>Dotenv</code> carga las variables de un archivo <code>.env</code> en el entorno cuando se inicia.</p> <p>Desafortunadamente, Java no admite de forma nativa la carga de archivos <code>.env</code>, pero puede utilizar librer\u00edas externas para conseguir esta tarea. Una de las librer\u00edas populares para este prop\u00f3sito es <code>dotenv-java</code>. Esta librer\u00eda le permite cargar f\u00e1cilmente las variables de entorno de un archivo .env en su aplicaci\u00f3n Java. https://github.com/cdimascio/dotenv-java</p> <p>A\u00f1ada la dependencia</p> <p>Primero, debe a\u00f1adir la librer\u00eda <code>dotenv-java</code> a su proyecto. Si utiliza Maven, a\u00f1ada la siguiente dependencia al archivo pom.xml:</p> <pre><code>&lt;dependency&gt; \n&lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt; \n&lt;artifactId&gt;java-dotenv&lt;/artifactId&gt; \n&lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si utiliza Gradle, a\u00f1ada lo siguiente al archivo build.gradle:</p> <pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Cree el archivo <code>.env</code></p> <p>El archivo .env es como un archivo de configuraci\u00f3n. Puede almacenarlo en la ruta ra\u00edz de su aplicaci\u00f3n</p> <pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Cargue la configuraci\u00f3n</p> <pre><code>importe io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main { \npublic static void main(String[] args) { \n// Load the .env file \nDotenv dotenv = Dotenv.load(); \n\n// Retrieve environment variables \nString databaseUrl = dotenv.get(\"DATABASE_URL\"); \nString databaseUser = dotenv.get(\"DATABASE_USER\"); \nString databasePassword = dotenv.get(\"DATABASE_PASSWORD\"); \n\n// Print the values \nSystem.out.println(\"Database URL: \" + databaseUrl); \nSystem.out.println(\"Database User: \" + databaseUser); \nSystem.out.println(\"Database Password: \" + databasePassword); \n\n// Use the variables as needed \n// For example, establish a database connection using these variables \n}\n}\n</code></pre> <p>Atenci\u00f3n</p> <p>Tenga en cuenta que con la librer\u00eda java dotenv, utilizar\u00e1 <code>dotenv.get()</code> en lugar del m\u00e9todo <code>System.getenv()</code>, ya que est\u00e1 accediendo a un archivo local.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/","title":"Ejercicios sistema de archivos","text":""},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#ls-la","title":"<code>ls -la</code>","text":"<p>En este ejercicio, implementaremos una versi\u00f3n optimizada del programa <code>ls</code>. Listar\u00e1 un directorio en un modo de vista espec\u00edfico. Tanto el directorio como la vista se indicar\u00e1n al iniciar el programa.</p> <p>El modo de vista puede ser lista, columnas o tabla:</p> <ul> <li>Lista \u2192 Los nombres de los archivos se muestran uno encima del otro. </li> <li>Columnas \u2192 Igual que una lista, pero en varias columnas.</li> <li>Tabla \u2192 Se mostrar\u00e1 la informaci\u00f3n del archivo, con este patr\u00f3n: <code>DFRWH name size mod_data</code>:</li> <li><code>D</code> \u2192 es un directorio.</li> <li><code>F</code> \u2192 es un archivo.</li> <li><code>R</code> \u2192 podemos leer el archivo.</li> <li><code>W</code> \u2192 podemos escribir el archivo.</li> <li><code>H</code> \u2192 el archivo est\u00e1 oculto.</li> </ul>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#envio","title":"Env\u00edo","text":"<p>Un solo archivo <code>.java</code> con el programa. Para facilitarte la tarea, aqu\u00ed tienes c\u00f3digo para formatear una lista de cadenas en columnas. Se debe inicializar <code>MAX_FILES_BY_COLUMN = 4</code>.</p> <pre><code>public static void ListaColumnas(String[] filenames){\nint columnas = (filenames.length / MAX_FILES_BY_COLUMN)+1; String[][] salida = new String[MAX_FILES_BY_COLUMN][columnas];\nfor (int i=0;i&lt;filenames.length;i++){\nsalida[i % MAX_FILES_BY_COLUMN][i / MAX_FILES_BY_COLUMN]=\nfilenames[i];\n}\n//bucle para mostrar salida ls\nfor (int i=0;i&lt;MAX_FILES_BY_COLUMN;i++){\nfor (int j=0; j&lt;columnas;j++)\nSystem.out.print(salida[i][j] + \" - \");\nSystem.out.println(\" /n\");\n}\n}\n</code></pre>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-ocultos","title":"Archivos ocultos","text":"<p>Escribe un programa Java que encuentre todos los archivos ocultos de un directorio y sus subdirectorios recursivamente.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivo-mas-grande","title":"Archivo m\u00e1s grande","text":"<p>Escribe un programa Java para encontrar el archivo m\u00e1s grande de un conjunto de archivos en un directorio.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-de-texto","title":"Archivos de texto","text":""},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#cuantas-vocales","title":"\u00bfCu\u00e1ntas vocales?","text":"<p>Escribe un programa que reciba el nombre de un archivo de texto y una vocal. El programa mostrar\u00e1 el n\u00famero de veces que aparece esa vocal en el archivo.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#tail-y-head","title":"<code>tail</code> y <code>head</code>","text":"<p>Escribe tu propia versi\u00f3n de tail y head en las utilidades GNU. Puedes encontrar informaci\u00f3n en:</p> <ul> <li>tail</li> <li>head</li> </ul> <p>Nota</p> <p>Recuerda que estos programas muestran las \u00faltimas y las primeras diez l\u00edneas por defecto. Si quieres modificarlo, puedes usar <code>-nX</code>, donde X es el n\u00famero de l\u00edneas que quieres mostrar.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-binarios","title":"Archivos binarios","text":""},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#calcular-el-tamano-de-un-archivo-de-imagen-hard","title":"Calcular el tama\u00f1o de un archivo de imagen (HARD)","text":"<p>Seg\u00fan la especificaci\u00f3n de im\u00e1genes bmp o png, como se puede ver:</p> <ul> <li>Especificaci\u00f3n BMP</li> <li>Especificaci\u00f3n PNG</li> </ul> <p>Escribir un programa que reciba el nombre de un archivo png o bmp y devuelva el ancho y el alto de la imagen.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-csv","title":"Archivos CSV","text":"<p>Crear una funci\u00f3n para mostrar un archivo CSV, seg\u00fan los siguientes requisitos:</p> <ul> <li>Debemos indicar a la funci\u00f3n el car\u00e1cter separador.</li> <li>Debemos indicar a la funci\u00f3n si el CSV tiene una l\u00ednea de encabezado o no.</li> <li>(Mejora) La funci\u00f3n debe calcular el tama\u00f1o m\u00e1ximo de columna para cada l\u00ednea y mostrar cada columna con el tama\u00f1o calculado previamente, como MySQL muestra sus tablas.</li> </ul> <p>En la plataforma encontrar\u00e1s archivos CSV con los nombres de los jugadores de la MLB, pero puedes elegir el archivo que prefieras.</p>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-xml","title":"Archivos XML","text":"<p>En la plataforma encontrar\u00e1s un archivo llamado <code>monaco2023.xml</code> con mucha informaci\u00f3n sobre la carrera del campeonato de F1 2023 en M\u00f3naco. Adem\u00e1s de otra informaci\u00f3n, encontramos:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;granPremio&gt;\n    &lt;nombre&gt;Gran Premio de M\u00f3naco&lt;/nombre&gt;\n    &lt;a\u00f1o&gt;2023&lt;/a\u00f1o&gt;\n    &lt;fecha&gt;2023-05-28&lt;/fecha&gt;\n    &lt;circuito&gt;\n        &lt;nombre&gt;Circuito de M\u00f3naco&lt;/nombre&gt;\n        &lt;ubicacion&gt;Montecarlo, M\u00f3naco&lt;/ubicacion&gt;\n        &lt;longitud&gt;3.337 km&lt;/longitud&gt;\n        &lt;vueltas&gt;78&lt;/vueltas&gt;\n        &lt;distanciaTotal&gt;260.286 km&lt;/distanciaTotal&gt;\n        &lt;recordVuelta&gt;1:12.909 (Lewis Hamilton, 2021)&lt;/recordVuelta&gt;\n    &lt;/circuito&gt;\n\n    &lt;clasificacion&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Max Verstappen&lt;/nombre&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.365&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Fernando Alonso&lt;/nombre&gt;\n            &lt;equipo&gt;Aston Martin&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.449&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Esteban Ocon&lt;/nombre&gt;\n            &lt;equipo&gt;Alpine&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.553&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;4&lt;/posicion&gt;\n            &lt;nombre&gt;Carlos Sainz&lt;/nombre&gt;\n            &lt;equipo&gt;Ferrari&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.630&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;5&lt;/posicion&gt;\n            &lt;nombre&gt;Lewis Hamilton&lt;/nombre&gt;\n            &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n            &lt;tiempo&gt;1:11.725&lt;/tiempo&gt;\n        &lt;/piloto&gt;\n    &lt;/clasificacion&gt;\n\n    &lt;carrera&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Max Verstappen&lt;/nombre&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;1:48:51.980&lt;/tiempo&gt;\n            &lt;puntos&gt;25&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Fernando Alonso&lt;/nombre&gt;\n            &lt;equipo&gt;Aston Martin&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+27.921&lt;/tiempo&gt;\n            &lt;puntos&gt;18&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Esteban Ocon&lt;/nombre&gt;\n            &lt;equipo&gt;Alpine&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+36.990&lt;/tiempo&gt;\n            &lt;puntos&gt;15&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;4&lt;/posicion&gt;\n            &lt;nombre&gt;Lewis Hamilton&lt;/nombre&gt;\n            &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+39.062&lt;/tiempo&gt;\n            &lt;puntos&gt;12&lt;/puntos&gt;\n        &lt;/resultado&gt;\n        &lt;resultado&gt;\n            &lt;posicion&gt;5&lt;/posicion&gt;\n            &lt;nombre&gt;George Russell&lt;/nombre&gt;\n            &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n            &lt;vueltas&gt;78&lt;/vueltas&gt;\n            &lt;tiempo&gt;+56.284&lt;/tiempo&gt;\n            &lt;puntos&gt;10&lt;/puntos&gt;\n        &lt;/resultado&gt;\n    &lt;/carrera&gt;\n\n    &lt;vueltaRapida&gt;\n        &lt;piloto&gt;Lewis Hamilton&lt;/piloto&gt;\n        &lt;equipo&gt;Mercedes&lt;/equipo&gt;\n        &lt;tiempo&gt;1:15.650&lt;/tiempo&gt;\n        &lt;vuelta&gt;33&lt;/vuelta&gt;\n    &lt;/vueltaRapida&gt;\n\n    &lt;abandonos&gt;\n        &lt;abandono&gt;\n            &lt;piloto&gt;Charles Leclerc&lt;/piloto&gt;\n            &lt;equipo&gt;Ferrari&lt;/equipo&gt;\n            &lt;vuelta&gt;53&lt;/vuelta&gt;\n            &lt;causa&gt;Da\u00f1os por colisi\u00f3n&lt;/causa&gt;\n        &lt;/abandono&gt;\n        &lt;abandono&gt;\n            &lt;piloto&gt;Nyck de Vries&lt;/piloto&gt;\n            &lt;equipo&gt;AlphaTauri&lt;/equipo&gt;\n            &lt;vuelta&gt;41&lt;/vuelta&gt;\n            &lt;causa&gt;Problemas mec\u00e1nicos&lt;/causa&gt;\n        &lt;/abandono&gt;\n    &lt;/abandonos&gt;\n\n    &lt;clasificacionMundialPilotos&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Max Verstappen&lt;/nombre&gt;\n            &lt;puntos&gt;144&lt;/puntos&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Sergio P\u00e9rez&lt;/nombre&gt;\n            &lt;puntos&gt;105&lt;/puntos&gt;\n            &lt;equipo&gt;Red Bull Racing&lt;/equipo&gt;\n        &lt;/piloto&gt;\n        &lt;piloto&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Fernando Alonso&lt;/nombre&gt;\n            &lt;puntos&gt;93&lt;/puntos&gt;\n            &lt;equipo&gt;Aston Martin&lt;/equipo&gt;\n        &lt;/piloto&gt;\n    &lt;/clasificacionMundialPilotos&gt;\n\n    &lt;clasificacionMundialConstructores&gt;\n        &lt;equipo&gt;\n            &lt;posicion&gt;1&lt;/posicion&gt;\n            &lt;nombre&gt;Red Bull Racing&lt;/nombre&gt;\n            &lt;puntos&gt;249&lt;/puntos&gt;\n        &lt;/equipo&gt;\n        &lt;equipo&gt;\n            &lt;posicion&gt;2&lt;/posicion&gt;\n            &lt;nombre&gt;Aston Martin&lt;/nombre&gt;\n            &lt;puntos&gt;120&lt;/puntos&gt;\n        &lt;/equipo&gt;\n        &lt;equipo&gt;\n            &lt;posicion&gt;3&lt;/posicion&gt;\n            &lt;nombre&gt;Mercedes&lt;/nombre&gt;\n            &lt;puntos&gt;119&lt;/puntos&gt;\n        &lt;/equipo&gt;\n    &lt;/clasificacionMundialConstructores&gt;\n\n    &lt;clima&gt;\n        &lt;temperaturaAmbiente&gt;24\u00b0C&lt;/temperaturaAmbiente&gt;\n        &lt;temperaturaPista&gt;42\u00b0C&lt;/temperaturaPista&gt;\n        &lt;humedad&gt;65%&lt;/humedad&gt;\n        &lt;condiciones&gt;Soleado&lt;/condiciones&gt;\n    &lt;/clima&gt;\n\n    &lt;curiosidades&gt;\n        &lt;curiosidad&gt;Fernando Alonso consigui\u00f3 su primer podio en M\u00f3naco desde 2010&lt;/curiosidad&gt;\n        &lt;curiosidad&gt;Esteban Ocon logr\u00f3 su segundo podio en la F\u00f3rmula 1&lt;/curiosidad&gt;\n        &lt;curiosidad&gt;Red Bull Racing extendi\u00f3 su racha de victorias a 6 carreras&lt;/curiosidad&gt;\n        &lt;curiosidad&gt;Primera vez que Alpine y Aston Martin comparten podio&lt;/curiosidad&gt;\n    &lt;/curiosidades&gt;\n&lt;/granPremio&gt;\n</code></pre> <p>Dentro de <code>resultado</code>, en <code>carrera</code> encontraremos como posicion (atributo <code>posicion</code>) que determinar\u00e1 la posici\u00f3n en la que acab\u00f3 en la carrera. Adem\u00e1s, encontraremos los siguientes elementos:</p> <ul> <li>nombre: nombre del piloto.</li> <li>equipo: informaci\u00f3n sobre la marca del coche.</li> <li>vueltas: vueltas completadas.</li> <li>tiempo: tiempo en completar la carrera.</li> <li>puntos: puntos obtenidos por el piloto.</li> </ul> <p>En la plataforma encontrar\u00e1s:</p> <ul> <li>Clase Carrera: Implementaci\u00f3n completa, que necesita la parte del controlador del XML para crear un objeto Carrera.</li> </ul> <pre><code>    private int posicion;\n    private String nombre;\n    private String equipo;\n    private int vueltas;\n    private String tiempo;\n    private int puntos;\n</code></pre> <ul> <li> <p>Clase Competicion: Esta no tendr\u00e1 constructor, constructor por defecto. Para esta se deber\u00e1 implementar lo siguiente:</p> <ul> <li><code>public ArrayList&lt;Carrera&gt; cargaResultadosXML(String nomXML)</code>, que recibe el nombre del archivo XML y carga todos los resultados. </li> <li><code>public void saveAsCSV(String nombreFichero, ArrayList&lt;Carrera&gt; losResultados)</code>, que guardar\u00e1 en un archivo de texto csv los resultados cargados previamente.</li> </ul> </li> <li> <p>La clase del programa principal ya se proporciona implementada.</p> </li> </ul>"},{"location":"Unidad%201%20Ficheros/6_Ejercicios.es/#archivos-json","title":"Archivos JSON","text":"<p>En la plataforma encontrar\u00e1s un archivo llamado <code>SW.json</code>. Este recupera informaci\u00f3n sobre los personajes de la famosa saga. Escribe un programa para obtener:</p> <ul> <li>Personajes que no condujeron ning\u00fan veh\u00edculo.</li> <li>Lista de personajes, ordenados por n\u00famero de pel\u00edculas en las que aparecen.</li> <li>Crea un archivo XML como este, con un breve resumen:</li> </ul> <pre><code>&lt;character films=\"4\" vehicle=\"0\"&gt;\n&lt;name&gt;Luke Skywalker&lt;/name&gt;\n&lt;mass&gt;77&lt;/mass&gt;\n&lt;url&gt;https://swapi.dev/api/people/1/&lt;/url&gt;\n&lt;/character&gt;\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/","title":"1. Desfase objeto-relacional","text":"<p>Los Sistemas de Gesti\u00f3n de Bases de Datos (SGBD) se basan principalmente en el modelo Entidad-Relaci\u00f3n (E/R), donde la informaci\u00f3n se almacena en varias tablas relacionadas entre s\u00ed. Es una tecnolog\u00eda sencilla y eficiente, que ha resistido al paso de los a\u00f1os y que todav\u00eda es el modelo utilizado por la mayor\u00eda de bases de datos y SGBD actualmente. Pese a su \u00e9xito, el modelo tiene algunas limitaciones como la representaci\u00f3n de informaci\u00f3n mal estructurada o compleja.</p> <p>Los modelos conceptuales nos ayudan a moldear una realidad compleja y se basan en un proceso de abstracci\u00f3n de la realidad. Cada modelo tiene una forma de capturar esta realidad, pero todos ellos est\u00e1n m\u00e1s cercanos a la mentalidad humana que a la memoria de un ordenador.</p> <p>Cuando modelizamos una base de datos, utilizamos el modelo conceptual de Entidad-Relaci\u00f3n y posteriormente realizamos un proceso de transformaci\u00f3n en tablas y normalizaci\u00f3n de este modelo para obtener un modelo de datos relacional.</p> <p>En el caso de la programaci\u00f3n orientada a objetos, intentamos representar la realidad mediante objetos y las relaciones entre ellos. \u00c9ste es otro tipo de modelo conceptual, pero que tiene como objetivo representar la misma realidad que el modelo relacional.</p> <p>As\u00ed pues, tenemos dos aproximaciones distintas para representar la realidad de un problema: el Modelo Relacional de la base de datos y el modelo Orientado a Objetos de nuestras aplicaciones.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#11-representacion-de-la-informacion-con-el-modelo-relacional","title":"1.1. Representaci\u00f3n de la informaci\u00f3n con el modelo relacional","text":"<p>El modelo relacional se basa en tablas y la relaci\u00f3n entre ellas:</p> <ul> <li>Cada tabla tiene tantas columnas como atributos queremos representar y tantas filas como registros o elementos de ese tipo contiene.</li> <li>Las tablas tienen una clave primaria, que identifica cada uno de los registros, y puede estar formada por uno o m\u00e1s atributos.</li> <li>La relaci\u00f3n entre tablas se representa mediante claves externas, que consisten en incluir en una tabla la clave primaria de otra tabla, como referencia a la misma. Cuando se elimina un registro de una tabla, cuya clave primaria es referenciada por otra, debe garantizarse que se mantiene la integridad referencial de la base de datos. Entonces, antes de esta eliminaci\u00f3n de una clave primaria, podemos: </li> <li>No permitir la eliminaci\u00f3n (NO ACTION), </li> <li>Realizar la eliminaci\u00f3n en cascada, eliminando tambi\u00e9n todos los registros que hac\u00edan referencia a la clave primaria del registro eliminado (CASCADE), </li> <li>Establecer a null (SET NULL), de modo que la clave externa que hac\u00eda referencia a la clave primaria de la otra tabla tome el valor de <code>NULL</code>.</li> <li>Los diferentes campos de las tablas tambi\u00e9n pueden tener ciertas restricciones asociadas, como: </li> <li>Restricci\u00f3n de valor no nulo, por lo que el campo no puede ser nulo en ning\u00fan caso, </li> <li>Restricci\u00f3n de unicidad en uno o varios campos, por lo que el valor debe ser \u00fanico en toda la tabla. </li> <li>Restricci\u00f3n de dominio, o lo que es lo mismo, puede tener un conjunto de valores posibles por defecto.</li> </ul> <p>Atenci\u00f3n</p> <p>Las claves primarias tienen ambas propiedades: valor no nulo y unicidad.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#111-ejemplo","title":"1.1.1. Ejemplo","text":"<p>Una base de datos para almacenar informaci\u00f3n sobre jugadores, juegos, etc. puede ser as\u00ed:</p> <p></p> <p>Implementada con el SGBD <code>MySQL</code>:</p> <pre><code>CREATE SCHEMA IF NOT EXISTS `BDJuegos` DEFAULT CHARACTER SET utf8 ;\nUSE `BDJuegos` ;\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`jugador` ( \n`id` INT NOT NULL, \n`nick` VARCHAR(45) NULL, \n`fechaRegistro` DATETIME NULL, \nPRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`Genero` ( \n`id` INT NOT NULL, \n`nombre` VARCHAR(45) NULL, \n`descripcion` VARCHAR(256) NULL, \nPRIMARY KEY (`id`))\nENGINE = InnoDB;\n\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`Juego` ( \n`id` INT NOT NULL, \n`nombre` VARCHAR(45) NULL, \n`descripcion` VARCHAR(256) NULL, \n`Genero_id` INT NOT NULL, \nPRIMARY KEY (`id`), \nINDEX `fk_Juego_Genero1_idx` (`Genero_id` ASC), \nCONSTRAINT `fk_Juego_Genero1` \nFOREIGN KEY (`Genero_id`) \nREFERENCES `BDJuegos`.`Genero` (`id`) \nON DELETE NO ACTION \nON UPDATE NO ACTION)\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJuegos`.`Puntuaciones` ( \n`jugador_id` INT NOT NULL, \n`Juego_id` INT NOT NULL, \n`puntuacion` INT NULL, \nPRIMARY KEY (`jugador_id`, `Juego_id`), \nINDEX `fk_jugador_has_Juego_Juego1_idx` (`Juego_id` ASC), \nINDEX `fk_jugador_has_Juego_jugador1_idx` (`jugador_id` ASC), \nCONSTRAINT `fk_jugador_has_Juego_jugador1` \nFOREIGN KEY (`jugador_id`) \nREFERENCES `BDJuegos`.`jugador` (`id`) \nON DELETE NO ACTION \nON UPDATE NO ACTION, \nCONSTRAINT `fk_jugador_has_Juego_Juego1` \nFOREIGN KEY (`Juego_id`) \nREFERENCES `BDJuegos`.`Juego` (`id`) \nON DELETE NO ACTION \nON UPDATE NO ACTION)\nENGINE = InnoDB;\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#12-representacion-de-la-informacion-con-el-modelo-orientado-a-objetos","title":"1.2. Representaci\u00f3n de la informaci\u00f3n con el modelo orientado a objetos","text":"<p>Como la entidad-relaci\u00f3n, el modelo orientado a objetos es un modelo de datos conceptual, pero que da importancia a la modelizaci\u00f3n de los objetos.</p> <p>Un objeto puede representar cualquier elemento concibetual: entidades, procesos, acciones... Un objeto no s\u00f3lo representa las caracter\u00edsticas o propiedades, sino que tambi\u00e9n se centra en los procesos que sufren. En t\u00e9rminos del modelo orientado a objetos, decimos que un objeto es datos m\u00e1s operaciones o comportamiento.</p> <p>En la unidad introductoria ya revisamos la programaci\u00f3n orientada a objetos, as\u00ed que nos limitaremos a una breve revisi\u00f3n de los principales conceptos:</p> <ul> <li>Un objeto es una entidad con ciertas propiedades y cierto comportamiento.</li> <li>En t\u00e9rminos de POO, las propiedades se conocen como atributos, y el conjunto de sus valores determina el estado del objeto en un momento dado.</li> <li>El comportamiento est\u00e1 determinado por una serie de funciones y procedimientos que llamamos m\u00e9todos, y que modifican el estado del objeto.</li> <li>Un objeto tambi\u00e9n tendr\u00e1 un nombre con el que se identifica.</li> <li>Una clase es una abstracci\u00f3n de un conjunto de objetos, y un objeto debe pertenecer necesariamente a alguna clase.</li> <li>Las clases definen los atributos y m\u00e9todos que los objetos de esa clase tendr\u00e1n.</li> <li>Un objeto se dice que es una instancia de una clase.</li> </ul> <p>El mismo ejemplo que hemos representado recientemente, con una representaci\u00f3n orientada a objetos, podr\u00eda ser:</p> <p></p> <p>Como podemos ver, tiene una estructura similar, a la que tambi\u00e9n hemos a\u00f1adido algunos m\u00e9todos como getters y setters. Adem\u00e1s, las distintas clases no tienen un atributo identificador, puesto que cada objeto se identifica a s\u00ed mismo. Aqu\u00ed tenemos una peque\u00f1a aproximaci\u00f3n de c\u00f3mo implementar\u00edamos esta jerarqu\u00eda en Java.</p> <p>La clase <code>Genere</code> es una clase POJO, que s\u00f3lo almacena informaci\u00f3n (nombre y descripci\u00f3n del tipo de juego) e implementa getters y setters.</p> <pre><code>package org.dam;\n\npublic class Genero {\n    protected String nombre;\n    protected String descripcion;\n\n    public Genero(String nombre, String descripcion) {\n        this.nombre = nombre;\n        this.descripcion = descripcion;\n    }\n\n    public String getNombre() {return nombre;}\n    public void setNombre(String nombre) {this.nombre = nombre;}\n\n    public String getDescripcion() {return descripcion;}\n    public void setDescripcion(String descripcion) {\n        this.descripcion = descripcion;\n    }\n}\n</code></pre> <p>La clase <code>Juego</code> almacena el nombre, la descripci\u00f3n y el g\u00e9nero del juego. A diferencia del modelo relacional, donde lo que se almacena ser\u00eda una clave externa al g\u00e9nero, ya que aqu\u00ed no tenemos claves externas, almacenamos el propio objeto (la referencia).</p> <pre><code>package org.dam;\n\npublic class Juego {\n    protected String nombre;\n    protected String descripcion;\n    protected Genero genero;\n\n    public Juego(String nombre, String descripcion, Genero genero) {\n        this.nombre = nombre;\n        this.descripcion = descripcion;\n        this.genero = genero;\n\n    }\n\n    public String getNombre() {return this.nombre;}\n    public void setNombre(String nombre) {this.nombre = nombre;}\n\n    public String getDescripcion() {return this.descripcion;}\n    public void setDescripcion(String descripcion) {\n        this.descripcion= descripcion;\n    }\n\n    public Genero getGenero() {return this.genero;}\n\n    public void setGenero(Genero genero) {this.genero = genero;}\n}\n</code></pre> <p>La clase <code>Puntuaciones</code> presenta la relaci\u00f3n entre <code>Jugador</code> y <code>Juego</code> (cuando un jugador juega a un juego) y almacena los puntos y una referencia al juego.</p> <pre><code>package org.dam;\n\npublic class Puntuaciones {\n    private int puntuacion;\n    private Juego juego;\n\n    public Puntuaciones(int puntuacion, Juego juego) {\n        this.puntuacion = puntuacion;\n        this.juego = juego;\n    }\n\n    public int getPuntuacion() {return puntuacion;}\n    public void setPuntuacion(int puntuacion) {\n        this.puntuacion = puntuacion;\n    }\n\n    public Juego getJuego() {return juego;}\n\n    public void setJuego(Juego juego) {this.juego = juego;}\n}\n</code></pre> <p>Y finalmente, la clase <code>Jugador</code> almacena el apodo y la fecha de registro para cada jugador, y despu\u00e9s, un array con todos los juegos que el jugador ha jugado:</p> <pre><code>package org.dam;\n\nimport java.util.Date;\nimport java.util.Set;\n\npublic class Jugador {\n\n    private String nick;\n    private Date fechaRegistro;\n    private Set&lt;Puntuaciones&gt; puntuaciones;\n\n    public Jugador(String nick, Date fechaRegistro) {\n        this.nick = nick;\n        this.fechaRegistro = fechaRegistro;\n    }\n\n    public String getNick() {return nick;}\n    public void setNick(String nick) {this.nick = nick;}\n\n    public Date getFechaRegistro() {return fechaRegistro;}\n    public void setFechaRegistro(Date fechaRegistro) {\n        this.fechaRegistro = fechaRegistro;\n    }\n\n    public Set getPuntuaciones() {return this.puntuaciones;}\n    public void setPuntuacion(Juego juego, int puntuacion) {\n        Puntuaciones registro = new Puntuaciones(puntuacion, juego);\n        this.puntuaciones.add(registro);\n    }\n}\n</code></pre> <p>La interfaz <code>Set</code> y la clase <code>HashSet</code></p> <p><code>Set</code> es una interfaz del paquete <code>java.util</code> que trata una colecci\u00f3n o conjunto de elementos sin desorden y sin duplicados. </p> <p>Por otra parte, <code>HashSet</code> es una clase que implementa la interfaz <code>Set</code> y que se basa en una tabla de hash, una estructura de datos que permite localizar objetos bas\u00e1ndose en una clave que indica la posici\u00f3n en la tabla, permitiendoel acceso directo al elemento, lo que les hace ideales para b\u00fasquedas, inserciones y eliminaciones.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/1_Object_relational_impedance_mismatch.es/#13-modelo-relacional-vs-modelo-orientado-a-objetos","title":"1.3. Modelo Relacional vs Modelo Orientado a Objetos","text":"<p>Conceptualmente, el modelo orientado a objetos es un modelo din\u00e1mico, que se centra en los objetos y en los procesos que \u00e9stos experimentan, pero que no tiene en cuenta, desde el principio, su persistencia. Debemos ser capaces, por tanto, de guardar los estados de los objetos de forma permanente y cargarlos cuando la aplicaci\u00f3n los necesite, as\u00ed como mantener la consistencia entre estos datos almacenados y los objetos que los representan en la aplicaci\u00f3n.</p> <p>Una forma de ofrecer esta persistencia a los objetos ser\u00eda utilizar un SGBD Relacional, pero nos encontraremos con algunas complicaciones. La primera, desde un punto de vista conceptual, es que el modelo Entidad-Relaci\u00f3n se centra en los datos, mientras que el modelo orientado a objetos se centra en los objetos, entendidos como grupos de datos y operaciones realizadas sobre ellos.</p> <p>Otra diferencia, bastante importante, es la vinculaci\u00f3n de los elementos entre un modelo y otro. Por un lado, el modelo relacional a\u00f1ade informaci\u00f3n adicional a las tablas en forma de clave externa, mientras que en el modelo orientado a objetos no necesitamos este dato externo, sino que la vinculaci\u00f3n entre objetos se realiza a trav\u00e9s de referencias entre ellos. Un objeto, por ejemplo, no necesitar\u00e1 una clave primaria, ya que el objeto se identifica por s\u00ed mismo.</p> <p>Como hemos visto en el ejemplo de las secciones anteriores, las tablas en el modelo relacional ten\u00edan una clave primaria para identificar los objetos y claves externas para expresar las relaciones, mientras que en el modelo orientado a objetos \u00e9stas desaparecen, expresando las relaciones entre objetos mediante referencias. Adem\u00e1s, la forma en que se expresan estas relaciones tambi\u00e9n es diferente. En el modelo relacional, por ejemplo, el registro de puntuaciones es una tabla que enlaza la mesa de jugadores con la mesa de juegos y a\u00f1ade la puntuaci\u00f3n del jugador en el juego. Por otra parte, en la implementaci\u00f3n en Java que hemos hecho tenemos objetos de tipo <code>Registro</code> que almacenan una puntuaci\u00f3n y una referencia al juego, pero es la clase Jugador la que mantiene el conjunto de registros de sus puntuaciones.</p> <p>Por otra parte, al manipular los datos, hay que tener en cuenta que el modelo relacional dispone de lenguajes (principalmente SQL) dise\u00f1ados exclusivamente para este prop\u00f3sito, mientras que en un lenguaje orientado a objetos funciona de forma diferente, por lo que ser\u00e1 necesario incorporar mecanismos que permitan realizar estas consultas desde el lenguaje de programaci\u00f3n. Adem\u00e1s, cuando obtenemos los resultados de la consulta, tambi\u00e9n encontramos otro problema, y es la conversi\u00f3n de los resultados. Cuando se realiza una consulta a una base de datos, siempre se devuelve un resultado en forma de tabla, por lo que ser\u00e1 necesario transformar estos resultados en estados de los objetos de la aplicaci\u00f3n.</p> <p>Todas estas diferencias implican lo que se conoce como desfase relacional-objeto, y que nos obligar\u00e1 a realizar determinadas conversiones entre objetos y tablas cuando queremos guardar la informaci\u00f3n en un SGBD. En esta unidad y en las siguientes, veremos c\u00f3mo superar este retraso desde distintos enfoques.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/","title":"2. Conectores","text":""},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#21-la-arquitectura-cliente-servidor-en-sgbd","title":"2.1. La arquitectura cliente-servidor en SGBD","text":"<p>Una vez conocemos el retraso relacional-objeto, centr\u00e9monos en c\u00f3mo acceder a bases de datos relacionales desde los lenguajes de programaci\u00f3n. Los SGBD, se popularizaron en los a\u00f1os 80, siendo los m\u00e1s extendidos actualmente. Salvo algunas excepciones, funcionan siguiendo una arquitectura cliente-servidor, de modo que tenemos un servidor donde ejecuta el SGBD y varios clientes que se conectan al servidor y hacen las peticiones correspondientes.</p> <p>Los SGBD ofrec\u00edan sus propios lenguajes de programaci\u00f3n, pero estaban muy ligados a ellos y el mantenimiento de la aplicaci\u00f3n era muy caro. Por este motivo, la tendencia era desacoplar (separar) a los SGBD del lenguaje de programaci\u00f3n, y hacer uso de est\u00e1ndares de conexi\u00f3n entre ellos.</p> <p>Gracias a la arquitectura cliente-servidor, los SGBD pudieron separar los datos por un lado y los programas para acceder por otros. Esta versatilidad ten\u00eda un peque\u00f1o inconveniente, y es que era necesario desarrollar por un lado el servidor, pero por otro, tambi\u00e9n la parte del cliente para poder conectarse a los servidores. Estas conexiones entre clientes y servidores requerir\u00e1n de protocolos y lenguajes espec\u00edficos. Aqu\u00ed nace el concepto de middleware, entendido como una capa intermedia de persistencia, formada por bibliotecas, lenguajes y protocolos ubicados en el cliente y en el servidor y que permiten conectar la base de datos con las aplicaciones.</p> <p>Aunque inicialmente cada SGBD implement\u00f3 soluciones espec\u00edficas, se impusieron est\u00e1ndares, entre ellos el lenguaje de consulta SQL (Structured Query Language), y que supuso un gran avance, ya que unific\u00f3 la manera de acceder a las bases de datos, aunque las aplicaciones continuaron requieren una API para hacer uso de SQL.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#22-protocolos-de-acceso-a-bases-de-datos","title":"2.2. Protocolos de acceso a bases de datos","text":"<p>Cuando hablamos de protocolos de acceso a bases de datos, nos encontramos con dos reglas principales de conexi\u00f3n:</p> <ul> <li>ODBC (Open Data Base Connectivity): \u00c9sta es una API (Application Program Interface) desarrollada por Microsoft para sistemas Windows que permite a\u00f1adir diferentes conectores a varias bases de datos relacionales basadas en SQL, de una manera sencilla y transparente. Utilizando ODBC, las aplicaciones pueden abrir conexiones en la base de datos, enviar consultas, actualizaciones y gestionar los resultados.</li> <li>JDBC (Java Database Connectivity), que define una API multiplataforma que los programas Java pueden utilizar para conectarse al SGBD.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#23-jdbc","title":"2.3. JDBC","text":"<p>Como hemos dicho, JDBC es una API de conexi\u00f3n a bases de datos espec\u00edfica de Java. Su modo de funcionamiento es el siguiente:</p> <ul> <li>Se ofrece una API, encapsulada en clases, que garantiza uniformidad en la forma en que las aplicaciones se conectan a la base de datos, independientemente del SGBD subyacente.</li> <li>Necesitaremos un controlador para cada base de datos a la que queremos conectarnos. Java no tiene ninguna librer\u00eda ODBC espec\u00edfica, pero, para no perder el potencial de estas conexiones, se han incorporado controladores especiales que act\u00faan como adaptadores entre JDBC y ODBC, por lo que es posible, a trav\u00e9s de este puente, conectar cualquier aplicaci\u00f3n Java con cualquier conexi\u00f3n ODBC. Actualmente, casi todos los SGBD tienen controladores JDBC, pero en caso de que no tenga conocimiento, puede utilizar este puente ODBC-JDBC.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#231-arquitectura-jdbc","title":"2.3.1. Arquitectura JDBC","text":"<p>La biblioteca est\u00e1ndar JDBC proporciona un conjunto de interfaces independientes de la implementaci\u00f3n. Los controladores de cada DBMS ser\u00e1n los encargados de su implementaci\u00f3n. Las aplicaciones, para acceder a la base de datos, tendr\u00e1n que utilizar las interfaces JDBC, de modo que la implementaci\u00f3n de cada DBMS sea completamente transparente para la aplicaci\u00f3n.</p> JDBC <p>Como podemos ver, las aplicaciones Java acceden a los distintos m\u00e9todos que API especifica como interfaces, pero son los controladores los que acceden a la base de datos.</p> <p>Hay que decir que las aplicaciones pueden utilizar varios controladores JDBC simult\u00e1neamente y acceder, por tanto, a m\u00faltiples bases de datos. La aplicaci\u00f3n especifica un controlador JDBC utilizando una URL (Universal Resource Locator) en el gestor de controladores, y \u00e9ste es el responsable de establecer correctamente las conexiones con las bases de datos a trav\u00e9s de los controladores. Los controladores pueden ser de distintos tipos:</p> <ul> <li>Tipo I o controladores de puente, caracterizados por hacer uso de tecnolog\u00eda externa a JDBC y actuar como adaptadores entre JDBC y la tecnolog\u00eda espec\u00edfica utilizada. Un ejemplo es el puente JDBC-ODBC.</li> <li>Tipo II o controladores con API parcialmente nativa, o controladores nativos. Est\u00e1n entrenados por un lado en Java y por otro hacen uso de librer\u00edas del sistema operativo. Su uso se debe a algunos SGBD que incorporan conectores propietarios que no siguen ning\u00fan est\u00e1ndar (normalmente pre-ODBC/JDBC).</li> <li>Tipo III o controladores Java a trav\u00e9s de protocolo de red, que son controladores desarrollados en Java que traducen las llamadases JDBC en un protocolo de red contra un servidor proxy. Es un sistema muy flexible, ya que los cambios en la implementaci\u00f3n de la base de datos no afectan a las aplicaciones.</li> <li>Tipo IV o 100% Java puras, tambi\u00e9n llamados protocolo nativos, y \u00e9stos son controladores escritos \u00edntegramente en Java. Las solicitudes al SGBD se realizan a trav\u00e9s del protocolo de red que utiliza el propio SGBD, por lo que no es necesario ning\u00fan c\u00f3digo nativo al cliente ni un servidor proxy. Es la alternativa que se ha acabado imponiendo, puesto que no requiere ning\u00fan tipo de instalaci\u00f3n.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/2_Connectors.es/#24-mysql-docker-workbench","title":"2.4. MySQL, Docker, Workbench","text":"<p>Este a\u00f1o utilizaremos MySQL como SGBD, por su amplia utilizaci\u00f3n en diversos contextos y por su simplicidad. Para utilizarlo, debes instalar <code>mysql-server</code> como servicio en tu sistema, como has estudiado en los \u00faltimos a\u00f1os.</p> <p>El servidor MySQL se puede instalar en tu ordenador, o puedes instalarlo en una m\u00e1quina virtual o configurarlo como contenedor Docker. Por tener un sistema m\u00e1s limpio, la opci\u00f3n recomendada es con contenedor Docker, ya que podr\u00e1s ejecutar varias versiones de MySQL sin interferencias entre ellas.</p> <p>Note</p> <p>Tiene una documentaci\u00f3n adicional sobre c\u00f3mo crear un contenedor MySQL en un documento llamado Docker para MySQL. As\u00ed pues, y con respecto al resto del documento, asumiremos que ya tiene la imagen de Docker de MySQL y un contenedor en ejecuci\u00f3n en el puerto <code>3308</code> (MySQL utiliza el puerto 3306 por defecto, pero en nuestro contenedor expondremos el servicio en el puerto 3308, en caso de que ya tenga un servidor MySQL 3 local).</p> <pre><code># Remember that to create the container (only fisrt time)\n\ndocker run --name mysql-srv \n-p 3308:3306 \n-e MYSQL_ROOT_PASSWORD=\"root\" \n-d mysql:latest\n\n# Se crea y start el container\n\n# To stop the container\ndocker stop mysql-srv\n\n# And to start the container ( AVOID TO run IT AGAIN !!!)\ndocker start mysql-srv\n</code></pre> <p>Y finalmente, pero no menos importante, evidentemente, puede utilizar una herramienta gr\u00e1fica para acceder a MySQL, como <code>mysql-workbench</code> o <code>dbeaver</code>. Debe configurar una conexi\u00f3n al puerto de Docker:</p> mysql-workbench <p>Espacio</p> <p>Revisa las notas de tu m\u00f3dulo de bases de datos sobre c\u00f3mo trabajar con Workbench: </p> <ul> <li>Carga y ejecuta scripts SQL </li> <li>Recupera la estructura de la base de datos </li> <li>Edita y crea SQL </li> <li>Edita y guarda datos</li> </ul> <p>Dispones del scrip Esquema BD Juegos para cargar los ejemplos de los apuntes</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/","title":"3. Conectando a bases de datos","text":""},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#31-controlador-jdbc-de-mysql","title":"3.1. Controlador JDBC de MySQL","text":"<p>Para crear programas Java utilizando el controlador de MySQL, necesitamos cargarlo en nuestro programa y previamente en nuestro entorno de desarrollo. C\u00f3mo utilizaremos <code>Maven</code> vamos a ver c\u00f3mo hacerlo:</p> <ol> <li>Debemos encontrar la versi\u00f3n del controlador de nuestro servidor JDBC, y podemos encontrarlo en el repositorio central de Maven https://mvnrepository.com.</li> <li>Buscamos <code>mysql jdbc</code>, y obtendremos como primer resultado MySQL Connector/J.</li> <li>Aseg\u00farese de seleccionar la versi\u00f3n correcta, y luego seleccione el gestor de paquetes (gradle, maven, etc.) y obtendr\u00e1:</li> </ol> <pre><code>&lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n    &lt;version&gt;9.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ol> <li>Cuando guarde o compile su proyecto, podr\u00e1 importar los controladores correctamente.</li> </ol> mysql-maven"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#32-url-de-conexion","title":"3.2. URL de conexi\u00f3n","text":"<p>Una vez haya importado el controlador, debe decirle a su programa Java c\u00f3mo conectarse a su base de datos y finalmente conectarse a su programa. Para esta tarea, debemos crear una <code>Connection</code> utilizando una URL especial llamada URL de conexi\u00f3n. Como otras URL, una URL de conexi\u00f3n puede contener:</p> <ul> <li>Protocolo \u2192  utilizaremos <code>jdbc</code>.</li> <li>SGBD \u2192  podr\u00edamos utilizar <code>mysql</code>, <code>postgres</code>, <code>sqlite</code>, <code>sqlserver</code> o cualquier SGBD con un conector JDBC.</li> <li>Direcci\u00f3n del servidor \u2192  podemos utilizar tanto un nombre completo como la direcci\u00f3n IP del servidor.</li> <li>[opcional]Port \u2192 el puerto donde el servidor est\u00e1 escuchando. Si no se utiliza ninguna, el controlador intentar\u00e1 conectarse al puerto predeterminado. Recuerde separar el puerto de la direcci\u00f3n con <code>:</code>.</li> <li>Otros par\u00e1metros, separ\u00e1ndolos con <code>?</code> al principio y con <code>&amp;</code> entre los par\u00e1metros. Por ejemplo: </li> <li>user=<code>usuario</code> </li> <li>pass=<code>contrase\u00f1a</code> </li> <li>useUnicode=<code>true</code> </li> <li>characterEncoding=<code>UTF-8</code></li> </ul> <p>Una muestra de URL de conexi\u00f3n puede ser:</p> <pre><code>String connectionUrl = \"jdbc:mysql://localhost:3308/Cycling?useUnicode=true&amp;characterEncoding=UTF-8&amp;user=root&amp;password=root\";\n</code></pre> <p>Una mejor opci\u00f3n ser\u00eda:</p> <pre><code>String server=\"localhost\";\nint puerto=3308;\nString user=\"root\";\nString pass=\"root\";\nString DBName=\"BDJuegos\";\nString connectionUrl = \"jdbc:mysql://\"+server+\":\"+puerto;\nconnectionUrl+=\"/\" + DBName;\nconnectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\nconnectionUrl+=\"&amp;user=\"+user;\nconnectionUrl+=\"&amp;password=\"+pass;\n</code></pre> <p>Atenci\u00f3n</p> <p>Tenga en cuenta que ambos ejemplos son c\u00f3digo hard-coded, ya que tiene los valores del servidor (usuario y contrase\u00f1a) escritos dentro de cadenas de texto. Es mejor opci\u00f3n almacenar estos valores dentro de variables o archivos de propiedades.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#33-clase-connection","title":"3.3. Clase <code>Connection</code>","text":"<p>En Java, la clase necesaria para gestionar el controlador es <code>java.sql.DriverManager</code>. Intenta cargar los controladores del sistema cuando lee la propiedad de los controladores JDBC, pero podemos indicar que se cargue utilizando la instrucci\u00f3n:</p> <pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>La clase que centralizar\u00e1 todas las operaciones con la base de datos es <code>java.sql.Connection</code>, y debemos obtenerla desde el <code>DriverManager</code> con cualquiera de los 3 m\u00e9todos est\u00e1ticos que tiene:</p> <ul> <li><code>static Connection getConnection(String url)</code> $\\rightarrow$ Devuelve una conexi\u00f3n, si es posible, a la base de datos con los par\u00e1metros especificados en la URL de conexi\u00f3n. Recuerde crear una URL de conexi\u00f3n a partir de la parte anterior.</li> <li><code>static Connection getConnection(String url, Properties info)</code> $\\rightarrow$ Devuelve una conexi\u00f3n, si es posible, a la base de datos, con algunos par\u00e1metros especificados en la URL y otros en un objeto de propiedades (<code>Properties</code> clase estudiada en la unidad 1). Veremos ejemplos m\u00e1s adelante.</li> <li><code>static Connection getConnection(String url, String user, String pass)</code> $\\rightarrow$ Devuelve una conexi\u00f3n, si es posible, a la base de datos con los par\u00e1metros especificados en la URL. Los datos de usuario y contrase\u00f1a se proporcionan en dos par\u00e1metros adicionales, por lo que no es necesario escribirlos en la URL de conexi\u00f3n.</li> </ul> <p>Una muestra inicial ser\u00e1:</p> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args)\n            throws ClassNotFoundException, SQLException {\n\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        String server = \"localhost\";\n        int puerto = 3308;\n        String user = \"root\";\n        String pass = \"root\";\n        String DBName = \"BDJuegos\";\n        String connectionUrl = \"jdbc:mysql://\" + server + \":\" + puerto;\n        connectionUrl += \"/\" + DBName;\n        connectionUrl += \"?useUnicode=true&amp;characterEncoding=UTF-8\";\n\n        Connection conn = DriverManager.getConnection(connectionUrl, user, pass);\n\n// if no excepto se catched, you connected to your DBMS\n    }\n}\n</code></pre> <p>Con el objeto <code>Connection</code> que tenemos ahora conectado, enviaremos nuestras consultas y pediremos informaci\u00f3n, como veremos m\u00e1s adelante.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#34-organizando-nuestra-conexion","title":"3.4. Organizando nuestra conexi\u00f3n","text":"<p>Nuestra aplicaci\u00f3n debe conectarse a una (o m\u00e1s) bases de datos. Podemos realizar muchas peticiones a estas base de datos, y si estamos implementando una aplicaci\u00f3n multithreaded, el n\u00famero de peticiones puede aumentar mucho. Por eso, debemos controlar d\u00f3nde y cu\u00e1ndo se crean y se cierran las conexiones. Una buena idea es crear una clase que encapsule todos estos procesos. El esqueleto de esta clase ser\u00eda el siguiente:</p> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class ConnexionBD {\n\n    private Connection laConexion = null;\n\n// write here access variables, like user, server or whatever\n\n    private void connect() {\n// do the connetion (look the sample).\n// Take care. private method. It will be called inside the class\n    }\n\n    // close connection, if it's opened\n    public void disConnect() throws SQLException {\n        if (laConexion != null) {\n            laConexion.close();\n        }\n    }\n\n    // returns the connection.\n// It will be create first time of after closed\n    public Connection getConexion(){\n        if (laConexion == null) {\n            this.connect();\n        }\n        return this.laConexion;\n    }\n}\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/3_Connecting.es/#341-ejercicio-resuelto","title":"3.4.1. Ejercicio resuelto","text":"<p>Crea un proyecto \u00fanico con dos clases. Una para conectarte a tu base de datos, como el \u00faltimo ejemplo, y una clase principal que se conecte y muestre si ha habido alg\u00fan error.</p> <p>La soluci\u00f3n del ejercicio est\u00e1 enlazada aqu\u00ed conexion.properties y ConexionDB.java</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/","title":"4. Clase <code>ResultSet</code>.","text":"<p>Ahora que estamos conectados a la base de datos, es hora de empezar a pedir informaci\u00f3n a DBMS. Esta informaci\u00f3n se proporcionar\u00e1 en forma de consultas (SQL) u otros m\u00e9todos, pero casi el 90% de las veces, como en el caso de las consultas SQL, la informaci\u00f3n devuelta se encuentra en un formato tabular. Los formatos tabulares son bien conocidos porque programas como MySQL Workbench o DBeaver muestran los datos de esta forma.</p> <p>En Java, la clase que permite trabajar con datos en formato tabular provenientes de bases de datos se llama <code>Resultset</code>. Un <code>Resultset</code> est\u00e1 compuesto por una tabla (filas y columnas) y un puntero en una fila, llamado cursor.</p> <p></p> <ol> <li>Cuando recuperamos datos de las bases de datos, la informaci\u00f3n se guarda en la tabla y el cursor apunta a una fila imaginaria vac\u00eda llamada <code>beforeFirst</code>.</li> <li><code>Resultset</code> contiene un m\u00e9todo especial llamado <code>next()</code>, que realiza dos acciones: </li> <li>Devuelve <code>true</code> si hay una fila de datos despu\u00e9s de la fila actual apuntada por el cursor y <code>false</code> de lo contrario. </li> <li>Avanza el cursor y apunta a la siguiente fila, s\u00f3lo si hab\u00eda una.</li> <li>Cuando el cursor de un <code>Resultset</code> devuelve <code>false</code>, significa que se han visitado todas las filas y ahora el cursor apunta a otra fila imaginaria llamada <code>afterLast</code>.</li> </ol> <p>Cuando el cursor apunta a una fila real, es cuando podemos recuperar los datos de las columnas de la fila actual. Podemos utilizar un m\u00e9todo especial y sobrecargado, de la siguiente forma:</p> <ul> <li><code>getXXX(int posici\u00f3nColumna)</code> \u2192  devuelve los datos, donde <code>XXX</code> es un tipo de datos (Int, Float, Double, String, etc.) de la posici\u00f3n de la columna, empezando por 1.</li> <li><code>getXXX(String nombreColumna)</code> \u2192  devuelve los datos, donde <code>XXX</code> es un tipo de datos (Int, Float, Double, String, etc.) de la columna con el nombre proporcionado.</li> </ul> <p>Peligro</p> <p>Tenga en cuenta: </p> <ul> <li>Las columnas comienzan en 1 en lugar de 0, a diferencia de los arrays. </li> <li>Si no conoce el tipo de datos de una columna, puede utilizar <code>getObject</code> y \u00e9ste devolver\u00e1 un <code>Object</code> gen\u00e9rico. </li> <li>Estos m\u00e9todos pueden generar una <code>SQLException</code> si el rango o el nombre de la columna est\u00e1 fuera de rango o no existe.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/#41-resulsetmetadata","title":"4.1. ResulSetMetaData","text":"<p>Los ResultSets de una consulta tambi\u00e9n tienen un conjunto de metadatos. Estos metadatos se pueden obtener utilizando <code>ResultSetMetaData</code>. Los m\u00e9todos m\u00e1s relevantes de esta clase son:</p> <ul> <li><code>int getColumnCount()</code> \u2192 Obtiene el n\u00famero de columnas en el ResultSet.</li> <li><code>String getColumnName(index)</code> \u2192  Obtiene el nombre de la columna indicada en el \u00edndice (recuerda que el primero es 1).</li> <li><code>String getColumnTypeName(index)</code> \u2192  Obtiene el tipo de la columna.</li> </ul> <p>ResulSetMetaData se obtiene de cada ResultSet generado previamente, con el m\u00e9todo <code>getMetaData()</code>.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/#42-algoritmo-resultset","title":"4.2. Algoritmo ResultSet","text":"<p>Independientemente del contenido de datos de tu ResultSet, la forma en que debemos trabajar es la siguiente:</p> <pre><code>// Connect to DB\nConnection conn = ...;\n\n// recover data\nResultSet rst=con...\n\n// while data available exists\nwhile (rst.next()){ \n//process the current row\n}\n</code></pre> <p>S\u00e9 consciente de que:</p> <ul> <li>Dentro del bucle while no es necesario llamar <code>next()</code> de nuevo. Se salta una fila de lo contrario.</li> <li>Cuando se han procesado las \u00faltimas filas, <code>next()</code> devuelve <code>false</code> y el bucle finaliza.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/4_Resultset.es/#43-ejemplo","title":"4.3. Ejemplo","text":"<p>En este blog de c\u00f3digo, vamos a ver un ejemplo breve para ejecutar una consulta (<code>Select * from table</code>). Veremos otras consultas en las siguientes secciones.</p> <pre><code> try {\n            ConnexionDB laConexionDB = new ConnexionDB(\"BDJuegos\");\n\n            Connection con = laConexionDB.getConnexion();\n\n            DatabaseMetaData dbmd = con.getMetaData();\n\n            System.out.println(\"\\nDBMS information--------\" );\n            System.out.println(\"DBMS:\\t\" + dbmd.getDatabaseProductName());\n            System.out.println(\"DBMS:\\t\"+ dbmd.getDriverName());\n            System.out.println(\"DBMS:\\t\" + dbmd.getURL());\n            System.out.println(\"DBMS:\\t\" + dbmd.getUserName());\n\n            System.out.println(String.format(\"%-15s %-15s %-15s \", \"Database\", \"Table\", \"Type\"));\n            System.out.println(\"-------------------------------------------------------\");\n            ResultSet rsmd = dbmd.getTables(\"BDJuegos\", null, null, null);\n            while (rsmd.next()) {\n                System.out.println(String.format(\"%-15s %-15s %-15s\", rsmd.getString(1), rsmd.getString(3), rsmd.getString(4)));\n            }\n\n            rsmd.close();\n\n            String table = \"Genero\"; // we set the name of an existing table\n            ResultSet columnas = dbmd.getColumns(\"BDJuegos\", null, table, null);\n\n            System.out.println(String.format(\"%-25s %-15s %-15s \", \"Atributo/Claves\", \"Tipo\", \"\u00bfPuede ser nulo?\"));\n            while (columnas.next()) {\n                String columnName = columnas.getString(4);\n                String tipo = columnas.getString(6);\n                String nullable = columnas.getString(18);\n\n                System.out.println(String.format(\"%-25s %-15s %-15s\", columnName,tipo,nullable));\n            }\n            con.close();\n\n        } catch (SQLException ex) {\n            System.out.println(ex);\n        }   \n</code></pre> <p>La soluci\u00f3n del ejercicio est\u00e1 enlazada aqu\u00ed conexion.properties, ConexionDB.java y el Main.java</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/","title":"5. Metadata de la base de datos","text":"<p>Antes de recuperar datos, estudiaremos c\u00f3mo obtener informaci\u00f3n sobre la base de datos a la que estamos conectados. Los metadatos de una base de datos describen su estructura: las tablas que componen la base de datos, los campos que forman estas tablas, los tipos de estos campos, etc. Aunque normalmente conocemos esta estructura previamente, es posible que necesitemos informaci\u00f3n en alguna ocasi\u00f3n, por eso tenemos las interfaces <code>DatabaseMetaData</code> y <code>ResultSetMetaData</code>.</p> <p>La interfaz <code>DatabaseMetaData</code> nos proporciona informaci\u00f3n sobre las tablas y vistas de la base de datos, as\u00ed como su estructura. A continuaci\u00f3n tenemos algunos de los m\u00e9todos m\u00e1s relevantes de esta interfaz.</p> <ul> <li><code>String getDatabaseProductName()</code> \u2192  Obtiene el nombre de SGBD.</li> <li><code>String getDriverName()</code> \u2192  Obtiene el nombre del controlador JDBC que se est\u00e1 utilizando.</li> <li><code>String getURL()</code> \u2192  Obtiene la URL de la conexi\u00f3n.</li> <li><code>String getUserName()</code> \u2192  Obtiene el nombre del usuario conectado a la base de datos.</li> <li><code>ResultSet getTables(String catalog, String schema, String patternTableName, String[] type)</code> \u2192  Obtiene informaci\u00f3n de las tablas disponibles en el cat\u00e1logo indicado.</li> <li><code>ResultSet getColumns(String catalog, String schema, String patternNameTable, String patternColumnName)</code> \u2192  Obtiene informaci\u00f3n de los campos de la tabla especificada en el cat\u00e1logo y esquema indicados.</li> <li><code>ResultSet getPrimaryKeys(String catalog, String schema, String patternNameTable)</code> \u2192  Obtiene la lista de campos que forman la clave primaria.</li> <li><code>ResultSet getImportedKeys(String catalog, String schema, String patternNameTable)</code> \u2192  Obtiene una lista con las claves externas definidas en la tabla.</li> <li><code>ResultSet getExportedKeys(String catalog, String schema, String patternNameTable)</code> \u2192  Obtiene una lista con las claves externas que apuntan a esta tabla.</li> </ul> <p>Informaci\u00f3n</p> <p>En este punto, cabe se\u00f1alar que los t\u00e9rminos cat\u00e1logo y esquema tienden a confundirse. Seg\u00fan los est\u00e1ndares, un cat\u00e1logo contiene varios esquemas, con informaci\u00f3n detallada del sistema, desde la forma de almacenamiento interno hasta los esquemas conceptuales. En un cat\u00e1logo, parece que existe un esquema llamado INFORMATION_SCHEMA, con las vistas y dominios del esquema de informaci\u00f3n del sistema. </p> <p>En cualquier caso, la mayor\u00eda de los SGBD coinciden el cat\u00e1logo con el nombre de la base de datos. Adem\u00e1s, en esta consulta especificamos el nombre de la base de datos como cat\u00e1logo, mientras que si abrimos MySQLWorkbench, la base de datos se representa como un esquema. Puede encontrar m\u00e1s informaci\u00f3n al respecto en estos enlaces: </p> <ul> <li>https://stackoverflow.com/questions/7022755/whats-the-difference-between-a-catalog-and-a-schema-in-a-relational-database </li> <li>https://www.quora.com/What-is-the-difference-between-system-catalog-and-database-schemain-a-Database</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#51-ejercicio-resuelto","title":"5.1. Ejercicio resuelto","text":"<p>Vamos a crear un programa Java que muestre informaci\u00f3n interna de una base de datos <code>BDJuegos</code>, mediante <code>DataBaseMetaData</code>. Veremos el programa paso a paso.</p> <p>Info</p> <p>Puede ver toda la informaci\u00f3n del m\u00e9todo y c\u00f3mo los datos se almacenan en cada ResultSet del m\u00e9todo en este enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#511-crear-la-connection","title":"5.1.1. Crear la connection","text":"<p>Recuerda c\u00f3mo conectarte a un SGBD de forma sencilla:</p> <pre><code>// load JDBC driver\n2 Class.forName(\"com.mysql.cj.jdbc.Driver\");\n3 // Conecto a DBMS and DB BDJuegos, with user and pass\n4 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3308/BDJuegos\", \"root\", \"root\");\n</code></pre> <p>Muy sencillo, carga el controlador y con\u00e9ctate a la base de datos de la forma que hemos estudiado.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#512-recupera-los-metadatos-del-sgbd-y-muestralos-en-un-formato-amigable","title":"5.1.2. Recupera los metadatos del SGBD y mu\u00e9stralos en un formato amigable","text":"<p>Utilizaremos la clase Color para mostrar los datos en formato de texto en la consola.</p> <pre><code>// get the metadata\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(Colores.Blue+\"\\nDBMS information--------\"+Colores.Reset);\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getDatabaseProductName());\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getDriverName());\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getURL());\nSystem.out.println(Colores.Bright_White+\"SGBD:\\t\"+Colores.Reset + dbmd.getUserName());\n</code></pre> <p>Como puede ver, obtenemos el nombre del SGBD, el controlador, el URL y el usuario que estamos utilizando. Obviamente, es lo mismo que pusimos al crear el objeto <code>Connection</code>, pero es un buen ejemplo para mostrar informaci\u00f3n.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#513-recuperar-tablas-en-un-esquemabase-de-datos","title":"5.1.3. Recuperar tablas en un esquema/base de datos","text":"<p>Utilizando el m\u00e9todo <code>getTables()</code> podemos recuperar las tablas y m\u00e1s informaci\u00f3n. Supongamos que <code>BDJuegos</code> existe en nuestro SGBD:</p> <pre><code>System.out.println(Colores.Bright_White+String.format(\"%-15s %-15s %-15s\",\"Database\",\"Table\",\"Type\"));\nSystem.out.println(\"-------------------------------------------------------\"+Colores.Reset);\nResultSet rsmd = dbmd.getTables(\"BDJuegos\", null, null, null);\nwhile (rsmd.next()) { \nSystem.out.println(String.format(\"%-15s %-15s %-15s\",rsmd.getString(1),rsmd.getString(3),rsmd.getString(4)));\n}\n</code></pre> <p>Comentarios:</p> <p>Repasa <code>String.format()</code> para establecer una longitud espec\u00edfica de cada columna.</p> <p>Seg\u00fan la documentaci\u00f3n de javadoc, obtenemos que el ResultSet devuelto por <code>getTables</code> tiene las siguientes columnas: </p> <ol> <li>TABLE_CAT String \u2192 cat\u00e1logo de la tabla (puede ser nulo) </li> <li>TABLE_SCHEM String \u2192 esquema de la tabla (puede ser nulo) </li> <li>TABLE_NAME String \u2192 nombre de la tabla </li> <li>TABLE_TYPE String \u2192 tipos de tabla. Los tipos t\u00edpicos son \"TABLE\", \"VIEW\", \"SYSTEM TABLE\", \"GLOBAL TEMPORARY\", \"LOCAL TEMPORARY\", \"ALIAS\", \"SYNONYM\". </li> <li>REMARKS String \u2192 comentario explicativo sobre la mesa </li> <li>TYPE_CAT String \u2192 cat\u00e1logo de los tipos (puede ser nulo) </li> <li>TYPE_SCHEM String \u2192 esquema de los tipos (puede ser nulo) </li> <li>TYPE_NAME String \u2192 nombre del tipo (puede ser nulo) </li> <li>SELF_REFERENCING_COL_NAME String \u2192 nombre de la columna \"identificador\" designada de una tabla indicada (puede ser nulo) </li> <li>REF_GENERATION String \u2192 especifica c\u00f3mo se crean los valores en SELF_REFERENCING_COL_NAME Los valores pueden ser \"SYSTEM\", \"USER\", \"DERIVED\" (puede ser nulo).</li> </ol> <p>Obtenemos las columnas 1, 3 y 4.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/5_Metadata.es/#514-obtener-las-columnas-de-la-tabla","title":"5.1.4. Obtener las columnas de la tabla","text":"<p>Es el momento de obtener las columnas de una tabla, utilizando el m\u00e9todo <code>getColumns()</code>:</p> <pre><code>String table=...; // we set the name of an existing table\nResultSet columnas = dbmd.getColumns(\"BDJuegos\",null , tabla, null);\nSystem.out.println(Colores.Bright_White+String.format(\"%-25s %-15 s%-15s\",\"Atributo/Claves\",\"Tipos\",\"\u00bfPuede ser nulo?\"+Colores.reset));\n\nwhile (columnas.next()){ \nString columnName=columnes.getString(4); \nString tipo=columnes.getString(6); \nString nullable=columnes.getString(18); \n\nSystem.out.println(String.format(\"%-25s %-15s %15s\",columnName,tipo,nullable));\n}\n</code></pre> <p>Comentarios:</p> <ul> <li><code>getColumns()</code> devuelve un ResultSet con 24 columnas, con mucha informaci\u00f3n de la tabla. S\u00f3lo obtenemos las columnas 4, 6 y 18 con el nombre, el tipo y si puede ser nulo.</li> <li>Del mismo modo, para obtener informaci\u00f3n sobre las claves, podemos utilizar: </li> <li><code>getPrimaryKeys()</code> devuelve un ResultSet con las claves primarias de las tablas. </li> <li><code>getExportedKeys()</code> devuelve un ResultSet con las columnas que apuntan a la clave primaria de la tabla actual. Esto significa todos los campos de otras tablas que apuntan a la clave primaria de la tabla actual. </li> <li><code>getImportedKeys()</code> devuelve un ResultSet con las columnas que son claves primarias importadas en la tabla actual. Esto significa las columnas que son claves externas (y apuntan a una clave primaria de otras tablas).</li> </ul> <p>Tiene todo el ejemplo en la carpeta <code>DatabaseMeta</code> de la aplicaci\u00f3n de ejemplo y en el siguiente enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/","title":"6. Statements and CRUD operations","text":"<p>En esta secci\u00f3n estudiaremos el principal objetivo de trabajar con bases de datos: manipular datos. Siempre trabajaremos con la misma plantilla:</p> <ol> <li>Conectar a la base de datos.</li> <li>Preparar la consulta.</li> <li>Ejecutar la consulta.</li> <li>Procesamiento de los datos, si es necesario.</li> </ol> <p>El punto 1 se ha estudiado en las secciones anteriores.</p> <p>Para crear las consultas, deberemos utilizar las siguientes clases/interfaces:</p> <ul> <li><code>Statement</code> \u2192 Se utiliza de forma general y es \u00fatil cuando queremos realizar sentencias SQL est\u00e1ticas, ya que no acepta par\u00e1metros. Creamos un <code>Statement</code> con el m\u00e9todo <code>createStatement()</code> de la clase <code>Connection</code>.</li> <li><code>PreparedStatement</code> \u2192 Se utiliza cuando queremos lanzar varias consultas y, adem\u00e1s, se permite realizar sentencias din\u00e1micas. Creamos un <code>PreparedStatement</code> con el m\u00e9todo <code>prepareStatement()</code> de la clase <code>Connection</code>.</li> <li><code>CallableStatement</code> \u2192 Se utiliza para acceder a procedimientos almacenados en la base de datos y tambi\u00e9n acepta par\u00e1metros de entrada. Creamos un <code>CallableStatement</code> con el m\u00e9todo <code>prepareCall()</code> de la clase <code>Connection</code>.</li> </ul> <p>Cuando la sentencia est\u00e1 preparada, podemos ejecutarla con:</p> <ul> <li><code>executeQuery</code> \u2192 Ejecuta sentencias que esperamos que devuelvan datos (consultas SELECT). El valor de retorno de esta ejecuci\u00f3n es, como ya supondr\u00e1, un ResultSet.</li> <li><code>executeUpdate</code> \u2192 Ejecuta sentencias que no se espera que devuelvan datos, pero que se utilizar\u00e1n para modificar la base de datos conectada (consultas INSERT, DELETE, UPDATE y CREATE TABLE).</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#61-create-insert","title":"6.1. Create (Insert)","text":"<p>Vamos a ver un ejemplo sencillo de declaraci\u00f3n <code>INSERT</code>.</p> <pre><code>ConnexionDB conDB=new ConnexioDB(\"BDJuegos\");\nConnection con=conDB.getConnexio();\n\nString SQL=\"INSERT INTO Juego VALUES (1, 'Double Dragon', 'Dos hermanos gemelos expertos en artes marciales deben hacerse camino en un escenario urbano donde miembros de bandas rivales quieren dejarlos fuera de combate.', 1);\";\n\nStatement st=con.createStatement();\n\nint affectedRows=st.executeUpdate(SQL);\n\nSystem.out.println(affectedRows+ \"row has been inserted\");\n</code></pre> <p>Como puede ver, es muy f\u00e1cil de entender el c\u00f3digo. Creamos una declaraci\u00f3n vac\u00eda y despu\u00e9s ejecutamos el SQL \"per se\". La ejecuci\u00f3n devuelve el n\u00famero de filas insertadas. Veremos mejores formas de insertar datos, utilizando scripts.</p> <p>Info</p> <p>Este c\u00f3digo es una versi\u00f3n reducida, puesto que cuando trabajamos con bases de datos pueden aparecer <code>SQLException</code>. Supongamos que el proceso de conexi\u00f3n ya se ha realizado.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#62-read-select","title":"6.2. Read (Select)","text":"<p>La lectura es el proceso m\u00e1s importante que realizaremos, ya que s\u00f3lo con el proceso de inicio de sesi\u00f3n dentro de una aplicaci\u00f3n estamos recuperando informaci\u00f3n de una base de datos. En todos los casos, debemos escribir la sentencia (SQL), ejecutarla y finalmente procesar los datos devueltos. Dependiendo de c\u00f3mo preparamos la sentencia, podemos distinguir entre:</p> <ol> <li>Sentencias fijas</li> <li>Sentencias variables</li> <li>Sentencias preparadas</li> </ol> <p>Veremos con detalle ambos modos. Utilizaremos para ello el script <code>instituto</code>  en el siguiente enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#621-sentencias-fijas","title":"6.2.1. Sentencias fijas","text":"<p>Estas sentencias, como su nombre indica, son sentencias fijas o constantes. SQL es fija y no tiene ninguna variable.</p> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) throws SQLException {\n\n        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        String SQL = \"Select * from persona\";\n        // The statement\n        Statement st = con.createStatement();\n        // The execution\n        ResultSet rst = st.executeQuery(SQL);\n\n        // processing\n        while (rst.next()) {\n            System.out.print(Colores.Bright_Blue + \"Person: \" + Colores.Reset);\n            /*\n            System.out.println(\n            rst.getString(3)+ \", \"+\n            rst.getString(2)+ \" - \"+\n            rst.getInt(4));\n            */\n            System.out.println(\n                    rst.getString(\"apellidos\") + \", \" +\n                            rst.getString(\"nombre\") + \" - \" +\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n    }\n}\n</code></pre> <p>En el procesamiento de la informaci\u00f3n, ResultSet tiene:</p> <ul> <li><code>type getType(int columnIndex)</code> \u2192 m\u00e9todo sobrecargado que devuelve el tipo de datos dado, utilizando el \u00edndice de columna del ResultSet. Recuerda que la primera columna es 1 en lugar de 0. El tipo puede ser Int, String, Double, etc. si conoces el tipo. Para columnas desconocidas, puedes utilizar <code>Object</code> como tipo gen\u00e9rico.</li> <li><code>type getType(String columnName)</code> \u2192 mismo que el m\u00e9todo anterior, pero accediendo a la columna con el nombre que hemos seleccionado en la consulta o el nombre en la tabla.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#622-sentencias-variables","title":"6.2.2. Sentencias variables","text":"<p>Imagina que quieres recuperar nombres que contengan la cadena <code>Ma</code> en su interior.</p> <pre><code>String SQL=\"Select * from persona where nombre like '%Ma%'\";\n</code></pre> <p>En ese caso, esta consulta est\u00e1 codificada directamente, y si quieres cambiar la parte del texto, debes modificar tu c\u00f3digo. Para evitar la codificaci\u00f3n directa, podemos escribir:</p> <pre><code>ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        // String SQL=\"Select * from persona where nombre like '%Ma%'\";\n\n        String nombre=Utilidades.leerTextoC(\"Introduce una parte del nombre: \");\n        // The query\n        String SQL=\"Select * from persona where nombre like '%\" + nombre + \"%'\";\n        // The statement\n        Statement st=con.createStatement();\n        // The execution\n        ResultSet rst=st.executeQuery(SQL);\n\n        // processing\n        while(rst.next()){\n            System.out.print(Colores.Bright_Blue+ \"Personas con \" +nombre+\": \"+ Colores.Reset);\n            System.out.println(\n                    rst.getString(\"apellidos\")+ \", \"+\n                            rst.getString(\"nombre\")+ \" \"+\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n    }\n</code></pre> <p>Como podemos ver, los datos est\u00e1n ahora en variables, pero la construcci\u00f3n de SQL es m\u00e1s compleja. Hay que tener en cuenta que los textos deben estar entre comillas y los n\u00fameros no, lo que facilita cometer errores. Pero puede ser peor, este tipo de c\u00f3digo puede incurrir en problemas de inyecci\u00f3n SQL, como vemos en el siguiente ejemplo:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        String id_persona=Utilidades.leerTextoC(\"Dame el id: \");\n        // The query\n        String SQL=\"Select * from persona where id_persona =\"+id_persona;\n        // The statement\n        Statement st=con.createStatement();\n        // The execution\n        ResultSet rst=st.executeQuery(SQL);\n\n        // processing\n        while(rst.next()){\n            System.out.print(Colores.Bright_Blue+ \"Personas con \" +id_persona+\": \"+ Colores.Reset);\n            System.out.println(\n                    rst.getString(\"apellidos\")+ \", \"+\n                            rst.getString(\"nombre\")+ \" \"+\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n    }\n</code></pre> <ul> <li>Si el usuario introduce <code>4</code> \u2192 Se mostrar\u00e1 las persona con ID igual a 4</li> <li>Si el usuario introduce <code>4 or 1</code> \u2192 Se mostrar\u00e1n todas las personas</li> </ul> <p>Debe evitarse este tipo de consultas en las declaraciones de validaci\u00f3n de usuario, para las que utilizaremos las sentencias preparadas y, obviamente, ser muy cautelosos en la verificaci\u00f3n de las entradas.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#623-sentencias-preparadas","title":"6.2.3. Sentencias preparadas","text":"<p>Para evitar el problema de la inyecci\u00f3n SQL, siempre que tengamos par\u00e1metros en nuestra consulta, utilizaremos sentencias preparadas. En las sentencias preparadas, donde debemos utilizar un marcador, en lugar de componerla con concatenaciones dentro de la cadena, le indicaremos con un interrogante (<code>?</code>), un car\u00e1cter llamado placeholder.</p> <p>A continuaci\u00f3n, deberemos asignar valores a estos placeholders, utilizando los m\u00e9todos <code>setType(int pos)</code> donde <code>Type</code> es el tipo de datos que asignaremos y <code>pos</code> es la posici\u00f3n del placeholder, empezando por <code>1</code>. Veremos el ejemplo:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        String id_persona=Utilidades.leerTextoC(\"Dame el id: \");\n        // The query\n        String SQL=\"Select * from persona where id_persona = ?\";\n\n        // The statement\n        PreparedStatement pst = con.prepareStatement(SQL);\n\n        pst.setString(1, id_persona);\n\n        // The execution\n        ResultSet rst=pst.executeQuery();\n\n        // processing\n        while(rst.next()){\n            System.out.print(Colores.Bright_Blue+ \"Personas con \" +id_persona+\": \"+ Colores.Reset);\n            System.out.println(\n                    rst.getString(\"apellidos\")+ \", \"+\n                            rst.getString(\"nombre\")+ \" \"+\n                            rst.getInt(\"edad\"));\n        }\n\n        rst.close();\n</code></pre> <p>Consejo</p> <p>Puedes combinar ResultSet con ResultSetMetaData para obtener los nombres de las columnas y tipos de datos almacenados en la base de datos.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#63-actualizacion-update-y-borrado-delete","title":"6.3. Actualizaci\u00f3n (Update) y Borrado (Delete)","text":"<p>La actualizaci\u00f3n y borrado de una fila se consideran como actualizaciones de la base de datos, ya que modifican el estado de la base de datos. De hecho, tambi\u00e9n consideramos la inserci\u00f3n como una actualizaci\u00f3n de la base de datos. Ambas tareas se incluyen en el m\u00e9todo <code>executeUpdate()</code>. Vamos a estudiarlo a trav\u00e9s de ejemplos:</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#631-ejemplo-de-borrado","title":"6.3.1. Ejemplo de borrado","text":"<p>Vamos a borrar filas de una mesa de personas entre las edades dadas:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        // give the age's bounds\n        int minEdad = Utilidades.leerEnteroC(\"Dame la edad m\u00ednima: \");\n        int maxEdad = Utilidades.leerEnteroC(\"Dame la edad m\u00e1xima: \");\n        // The query\n        String SQL=\"Delete from persona where edad between ? and ?\";\n\n        // The statement\n        PreparedStatement pst = con.prepareStatement(SQL);\n\n        pst.setInt(1, minEdad);\n        pst.setInt(2, maxEdad);\n\n        System.out.println(pst);\n        // The execution\n        int deletedRows = pst.executeUpdate();\n\n        System.out.println(deletedRows + \" han sido eliminadas\");\n\n        pst.close();\n</code></pre> <p>Peligro</p> <p>Eliminar datos es una operaci\u00f3n muy delicada. Cuida de: </p> <ul> <li>No olvides la cl\u00e1usula <code>WHERE</code> cuando eliminas, ya que eliminar\u00e1s todos los datos de la tabla. </li> <li>Si quieres eliminar toda la tabla, incluyendo la estructura (definici\u00f3n + tabla), debes utilizar <code>DROP TABLE</code> en lugar de <code>DELETE</code>. </li> <li>Si intentas eliminar una fila que est\u00e1 referenciada por una clave externa, obtendr\u00e1s la excepci\u00f3n <code>SQLIntegrityConstraintViolationException</code> y un mensaje como No se puede eliminar o actualizar una fila padre: falla una restricci\u00f3n de clave externa.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#632-ejemplo-de-actualizacion","title":"6.3.2. Ejemplo de Actualizaci\u00f3n","text":"<p>Vamos a a\u00f1adir a\u00f1os a las personas con el ID dado:</p> <pre><code>        ConexionDB conDB = new ConexionDB(\"instituto\");\n        Connection con = conDB.getConexion();\n        // hardcoded String\n        // give the age's bounds\n        int difEdad = Utilidades.leerEnteroC(\"Dame el n\u00famero de a\u00f1os: \");\n        int idMin = Utilidades.leerEnteroC(\"Dame el id m\u00ednimo: \");\n        // The query\n        String SQL=\"Update persona set edad=edad+ ? where id_persona&gt; ?\";\n\n        // The statement\n        PreparedStatement pst = con.prepareStatement(SQL);\n\n        pst.setInt(1, difEdad);\n        pst.setInt(2, idMin);\n\n        System.out.println(pst);\n        // The execution\n        int updatedRows = pst.executeUpdate();\n\n        System.out.println(updatedRows + \" han sido actualizadas\");\n\n        pst.close();\n</code></pre> <p>Warning</p> <p>Recuerda que: </p> <ul> <li>La cl\u00e1usula <code>UPDATE</code> no necesita <code>FROM</code> para que indiquemos directamente el nombre de la tabla. </li> <li>Aparece la cl\u00e1usula <code>SET</code>, con pares <code>campo=valor_actualizado</code>, para asignar el nuevo valor a los campos seleccionados. </li> <li>Si olvidamos la cl\u00e1usula <code>FROM</code>, se actualizar\u00e1n todas las filas.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#64-scripts","title":"6.4. Scripts","text":"<p>Un script, que normalmente se ha creado en un archivo externo, es un conjunto de instrucciones SQL ejecutadas en orden de arriba abajo. Podemos tomar como estrategia leer el archivo l\u00ednea por l\u00ednea y ejecutarlo una por una, pero JDBC permite ejecutar un conjunto de instrucciones en bloque. Para ello, lo primero que debemos hacer es habilitar m\u00faltiples ejecuciones a\u00f1adiendo un par\u00e1metro a la conexi\u00f3n, que es <code>allowMultiQueries=true</code>.</p> <p>A continuaci\u00f3n, debemos cargar el archivo y componer una cadena con todo el script. Para normalizarlo y hacerlo totalmente port\u00e1til, debemos tener cuidado con los saltos de l\u00ednea, ya que dependiendo del sistema es una combinaci\u00f3n <code>\\n</code> o <code>\\r\\n</code>. Podemos leer l\u00ednea por l\u00ednea y guardarlo en un <code>StringBuilder</code>, a\u00f1adiendo <code>System.getProperty(\"line.separator\")</code> o <code>System.lineSeparator()</code>como separadores.</p> <p>Despu\u00e9s s\u00f3lo necesitaremos crear una declaraci\u00f3n con esta cadena y ejecutarla con <code>executeUpdate()</code>. Lo veremos a continuaci\u00f3n:</p> <pre><code>ConexionDB conDB = new ConexionDB(\"instituto\");\n\n        Connection con = conDB.getConexion();\n\n        File script = new File(\"EsquemaCine.sql\");\n\n        try (BufferedReader bfr = new BufferedReader(new FileReader(script))) {\n\n            StringBuilder sb = new StringBuilder();\n            String linea;\n\n            while ((linea = bfr.readLine()) != null) {\n                // Elimina los comentarios y espacios en blanco\n                linea = linea.trim();\n                if (linea.isEmpty() || linea.startsWith(\"--\") || linea.startsWith(\"#\")) {\n                    continue; // Omite l\u00edneas vac\u00edas y comentarios\n                }\n\n                sb.append(linea);\n\n                // Si la l\u00ednea termina en ';', es el final de una sentencia y deberemos ejecutar esta.\n                if (linea.endsWith(\";\")) {\n                    String query = sb.toString();\n                    try (Statement stm = con.createStatement()) {\n                        stm.execute(query);\n                    }\n                 catch (SQLException e) {\n                     System.out.println(\"Error SQL ejecutando el script: \" + e.getMessage());\n                 }\n                    // Reinicia el StringBuilder para la pr\u00f3xima sentencia\n                    sb.setLength(0);\n\n                } else {\n                    // Si no, a\u00f1ade un espacio para separar partes de la misma sentencia\n                    sb.append(\" \");\n                }\n\n            }\n            System.out.println(\"Script ejecutado correctamente.\");\n\n        } catch (IOException e) {\n            System.out.println(\"Error de I/O al leer el script: \" + e.getMessage());\n        }\n</code></pre> <p>Consejo</p> <p>\u00bfRecuerdas las clases <code>Files</code> y <code>Paths</code>? Reescribe el \u00faltimo ejemplo para obtener un c\u00f3digo m\u00e1s limpio.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#65-transacciones","title":"6.5. Transacciones","text":"<p>Si queremos proteger la integridad de los datos, as\u00ed como evitar situaciones de bloqueo inesperadas en aplicaciones multithread, debemos proteger nuestras operaciones, especialmente aqu\u00e9llas que modifican los datos mediante el uso de transacciones.</p> <p>Una transacci\u00f3n define un entorno de ejecuci\u00f3n en el que las operaciones de guardado se mantienen almacenadas en la memoria hasta que la transacci\u00f3n se complete. Si en un momento determinado algo falla, el estado se devuelve al punto inicial de la misma (punto inicial) oa alg\u00fan punto de marca intermedio. Por defecto, abrir una conexi\u00f3n inicia una transacci\u00f3n:</p> <ul> <li>Cada ejecuci\u00f3n en la conexi\u00f3n genera una transacci\u00f3n por s\u00ed misma.</li> <li>Si queremos desactivar esta opci\u00f3n para que la transacci\u00f3n abarque varias ejecuciones, debemos marcarlo mediante <code>Connection.setAutoCommit(false);</code>.</li> <li>Para aceptar definitivamente la transacci\u00f3n lo haremos mediante <code>Connection.commit();</code></li> <li>Para cancelar la transacci\u00f3n <code>Connection.rollback();</code></li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#66-resultsets-actualizables","title":"6.6. ResultSets actualizables","text":"<p>Los m\u00e9todos de trabajo revisados en las secciones anteriores, especialmente cuando se actualizan o borran filas, funcionan directamente en la base de datos. Esto significa que borre o actualice una fila sin cargarla previamente en la memoria. \u00bfQu\u00e9 ocurre si desea mostrar los datos al usuario y luego el usuario decide borrar o actualizar la fila? En este caso, es mejor utilizar ResultSets actualizables.</p> <p>Hemos estudiado ResultSet como una colecci\u00f3n de filas y lo utilizamos s\u00f3lo para la lectura. Tambi\u00e9n podemos utilizarlo para editar y borrar datos. Para ello, debemos abrir el ResultSet de una forma diferente a la que hemos visto hasta ahora. Y, por \u00faltimo, pero no menos importante, depender\u00e1 de la base de datos la disponibilidad de crear este tipo de ResultSets.</p> <p>Para ello, no depende del ResultSet ni de c\u00f3mo se cre\u00f3 el Statement. Debemos utilizar este constructor:</p> <pre><code>public abstract Statement createStatement( \nint arg0, // resultSetType \nint arg1, // resultSetConcurrency \nint arg2) // resultSetHoldability \nthrows SQLException\n</code></pre> <p>Como puede ver, hay 3 argumentos para indicar qu\u00e9 tipo de ResultSet damos al final. Estos tres argumentos pueden ser:</p> <ul> <li><code>resultSetType</code> \u2192 \u00e9stas son opciones sobre c\u00f3mo moverse y pasar por las filas del ResultSet: </li> <li><code>TYPE_FORWARD_ONLY</code> \u2192 opci\u00f3n por defecto. El ResultSet s\u00f3lo puede ocurrir una vez. </li> <li><code>TYPE_SCROLL_INSENSITIVE</code> \u2192 Permite rebobinar y saltar a una posici\u00f3n absoluta o relativa. </li> <li><code>TYPE_SCROLL_SENSITIVE</code> \u2192 Al igual que antes, pero permite ver los cambios realizados en la base de datos.</li> <li><code>ResultSetConcurrency</code> \u2192 \u00e9stas son opciones sobre si se puede actualizar el ResultSet o no: </li> <li><code>CONCUR_READ_ONLY</code> \u2192 opci\u00f3n por defecto. S\u00f3lo lectura. Si queremos actualizar algo, s\u00f3lo podemos utilizar las cl\u00e1usulas <code>DELETE</code> o <code>UPDATE</code>. </li> <li><code>CONCUR_UPDATABLE</code> \u2192 Las filas de ResultSet se pueden actualizar o borrar.</li> <li><code>ResultSetHoldability</code> \u2192 estas opciones son sobre el comportamiento al cerrar el ResultSet: </li> <li><code>HOLD_CURSORS_OVER_COMMIT</code> \u2192 El ResultSet se mantiene abierto despu\u00e9s de confirmar la transacci\u00f3n. </li> <li><code>CLOSE_CURSORS_AT_COMMIT</code> \u2192 El ResultSet se cierra despu\u00e9s de confirmar la transacci\u00f3n. Mejora el rendimiento.</li> </ul> <p>En el siguiente ejemplo, podemos preguntar a nuestro DBMS si estos tipos de ResultSet est\u00e1n soportados:</p> <pre><code>ConexionDB conDB = new ConexionDB(\"instituto\");\nConnection con = conDB.getConexion();\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(\"TYPE_FORWARD_ONLY: \" + dbmd.supportsResultSetType(ResultSet.TYPE_FORWARD_ONLY));\nSystem.out.println(\"TYPE_SCROLL_INSENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));\nSystem.out.println(\"TYPE_SCROLL_SENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));\nSystem.out.println(\"CONCUR_READ_ONLY: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));\nSystem.out.println(\"CONCUR_UPDATABLE: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));\n</code></pre>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#661-movimiento-del-resultset","title":"6.6.1. Movimiento del ResultSet","text":"<p>Como podemos ver, no s\u00f3lo podemos mover el cursor hacia delante:</p> <ul> <li><code>next</code>, <code>previous</code>, <code>first</code> y <code>last</code> \u2192 como su nombre indica, se mueven hacia delante, hacia atr\u00e1s, al principio ya la \u00faltima fila. Devuelve true si el cursor apunta a una fila y false de lo contrario.</li> <li><code>beforeFirst</code> y <code>afterLast</code> \u2192 el cursor apuntar\u00e1 fuera de las filas, antes de la primera o despu\u00e9s de la \u00faltima fila.</li> <li><code>relative(int n)</code> \u2192 el cursor se mueve n files (hacia adelante o hacia atr\u00e1s, dependiendo del signo).</li> <li><code>absolute(int n)</code> \u2192 el cursor apunta a la fila n.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#662-eliminacion-de-filas-en-un-resultset","title":"6.6.2. Eliminaci\u00f3n de filas en un ResultSet","text":"<p>Despu\u00e9s de colocar el cursor en la fila que se desea eliminar, se puede eliminar del ResultSet (y de la base de datos) con el m\u00e9todo <code>deleteRow()</code>. Cuando se elimina una fila, el cursor apuntar\u00e1 a la fila anterior a la que se ha eliminado.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#663-actualizacion-de-filas-en-un-resultset","title":"6.6.3. Actualizaci\u00f3n de filas en un ResultSet","text":"<p>Despu\u00e9s de colocar el cursor en la fila deseada, se debe:</p> <ol> <li>Actualizar las columnas deseadas, utilizando el m\u00e9todo <code>updateType(int column, type newValue)</code>, donde la columna i-\u00e9sima (o con su nombre) se asigna el nuevo valor del tipo dado.</li> <li>Una vez que se hayan modificado todas las columnas deseadas, se guardan los cambios con <code>updateRow()</code>.</li> </ol> <p>Consejo</p> <p>No podemos actualizar una fila entera, debemos actualizar columna por columna y despu\u00e9s actualizar la fila.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/6_CRUD.es/#164-insercion-de-filas-en-un-resultset","title":"1.6.4. Inserci\u00f3n de filas en un ResultSet","text":"<p>Si queremos insertar una nueva fila en un ResultSet, debemos:</p> <ol> <li>Generar una nueva fila vac\u00eda, y esto se logra con el m\u00e9todo <code>moveToInsertRow()</code>.</li> <li>En esta fila, aplicamos el m\u00e9todo <code>updateType(int column, type newValue)</code> a todas las columnas a las que queremos asignar un valor, y finalmente</li> <li>Procedemos a insertar la nueva fila con <code>insertRow()</code>.</li> </ol> <p>Importante</p> <ul> <li>Estas operaciones de actualizaci\u00f3n, eliminaci\u00f3n e inserci\u00f3n s\u00f3lo pueden realizarse en consultas que provienen de una tabla sin agrupaciones. </li> <li>Para evitar complejidad en nuestros programas, vale la pena evaluar la conveniencia de traducir las actualizaciones del ResultSet a SQL puro y ejecutarlas directamente en las bases de datos mediante nuevas sentencias.</li> </ul> <p>Disponemos de todos los ejemplos en el proyecto <code>SentFija</code> en el siguiente enlace.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/","title":"7. De filas a Objetos","text":"<p>Finalmente, para cerrar la unidad, trabajaremos de forma natural: recuperaremos datos de la base de datos, crearemos objetos a partir del ResultSet y guardaremos los datos en la base de datos.</p> <p>Estudiaremos una nueva forma de crear nuestros POJO (y BEAN), utilizando una librer\u00eda moderna llamada Lombok.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#71-pojo-bean-y-proyecto-lombok","title":"7.1. POJO, BEAN y Proyecto Lombok","text":"<p>Debemos crear clases seg\u00fan nuestro modelo orientado a objetos. Dependiendo de c\u00f3mo hayamos dado las clases, pueden ser POJO o BEAN u otro tipo de clases. Vamos a entenderlo (extra\u00eddo de aqu\u00ed: enlace).</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#711-pojo","title":"7.1.1. POJO","text":"<p>Esto significa Plain Old Java Object. Es una clase que:</p> <ul> <li>No debe extender ninguna clase.</li> <li>No debe implementar ninguna interfaz.</li> <li>No debe contener anotaciones espec\u00edficas.</li> </ul> <p>No existen restricciones en los modificadores de acceso de los campos. Pueden ser privados, por defecto, protegidos o p\u00fablicos. Tampoco es necesario incluir ning\u00fan constructor en \u00e9ste.</p> <p>Un ejemplo de POJO ser\u00eda, por ejemplo:</p> <pre><code>// AS POJO\npublic class Modulo { \n// atributos \nString nombre; \nint horas; \ndouble nota; \n// constructor \npublic ModulO(String nombre, int horas, double nota) { \nthis.nombre = nombre; \nthis.horas = horas; \nthis.nota = nota; \n} \n// getters \npublic String getModulO(){return this.nombre;} \npublic int getHorAs() {return this.horas;} \npublic double getNota() {return this.nota;} \n\n@Override \npublic String toString() { \nreturn \"Modulo{\" + \"nombre=\" + nombre + \", horas=\" + horas + \", nota=\" + nota + \"}\"; \n}\n}\n</code></pre> <p>Como puede ver, un POJO es la m\u00ednima clase que podemos hacer.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#712-bean","title":"7.1.2. BEAN","text":"<p>Los Beans son un tipo especial de POJO. Hay algunas restricciones para que un POJO sea un Bean.</p> <ul> <li>Todos los JavaBeans son POJOs, pero no todos los POJOs son JavaBeans.</li> <li><code>Serializable</code>, deben implementar la interfaz Serializable. Sin embargo, algunos POJOs que no implementan la interfaz Serializable se llaman POJOs porque Serializable es una interfaz marcadora y, por tanto, no supone una carga excesiva.</li> <li>Los campos deben ser privados. Esto proporciona un control completo sobre los campos.</li> <li>Los campos deben tener getters o setters o ambos.</li> <li>Debe haber un constructor sin argumentos en un Bean.</li> <li>Los campos s\u00f3lo se acceden mediante constructor o getters y setters.</li> </ul> <pre><code>// AS POJO\npublic class Modulo { \n// atributos \nprivate String nombre; \nprivate int horas; \nprivate double nota; \n// constructor \npublic Modulo() { } \n// getters \npublic String getModulo(){return this.nombre;} \npublic int getHoras() {return this.horas;} \npublic double getNota() {return this.nota;}\n// setters \npublic void getModulo(){return this.nombre;} \npublic void getHoras() {return this.horas;} \npublic void getNota() {return this.nota;} \n\n@Override \npublic String toString() { \nreturn \"Modulo{\" + \"nombre=\" + nombre + \", horas=\" + horas + \", nota=\" + nota + \"}\"; \n}\n}\n</code></pre> <p>Para resumir, las clases POJO y Beans se utilizan para definir objetos Java para aumentar su legibilidad y reutilizaci\u00f3n. Los POJOs no tienen otras restricciones mientras que los beans son POJOs especiales con algunas restricciones.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#713-lombok","title":"7.1.3. Lombok","text":"<p>Independientemente de si utilizamos POJO o BEAN, hay algunas tareas repetitivas que debemos realizar para crear nuestras clases. La mayor\u00eda de estas tareas son implementadas por los IDE, como crear getters, setters, encapsular campos, crear constructores, etc. Project Lombok es una librer\u00eda que evita realizar estas tareas repetitivas, y decimos lo que queremos y la librer\u00eda y el compilador hacen el resto.</p> <p>En este enlace configuraci\u00f3n de Lombok encontrar\u00e1s c\u00f3mo configurar la librer\u00eda en cada gestor de proyectos (gradle, maven, etc.) y en cada IDE (Netbeans, Eclipse, IntelliJ, etc.).</p> <p>Una vez instalada, basta con decir mediante anotaciones lo que quieres:</p> <ul> <li><code>@Getter</code> \u2192 generar\u00e1 todos los getters.</li> <li><code>@Setter</code> \u2192 generar\u00e1 todos los setters.</li> <li><code>@Data</code> \u2192 todos los m\u00e9todos que necesitan un POJO, incluyendo <code>ToString</code>.</li> <li><code>@AllArgsConstructor</code> o <code>@NoArgsConstructor</code> \u2192 generar\u00e1 el constructor que quieras.</li> </ul> <p>En el siguiente v\u00eddeo v\u00eddeo se explica como a\u00f1adir la dependencia a Maven y como hacer usp de lombok.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#72-cargando-objetos","title":"7.2. Cargando objetos","text":"<p>Vamos a finalizar con un ejemplo:</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#721-clase-persona","title":"7.2.1. Clase Persona","text":"<p>Esta clase es el POJO de una persona. Crear\u00e1 getters, setters, toString y los m\u00e9todos principales con s\u00f3lo unas pocas l\u00edneas y algunas anotaciones.</p> <pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Persona { \nprivate int id_persona; \nprivate String nombre; \nprivate String apellidos; \nprivate int edad;\n}\n</code></pre> <p>Hay que tener en cuenta que con Lombok el trabajo resulta f\u00e1cil.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/7_Row_to_Object.es/#722-llenando-un-array","title":"7.2.2. Llenando un Array","text":"<p>Para llenar una estructura de datos desde la base de datos, primero es necesario obtener los datos. Es necesario crear el objeto <code>Statement</code> o <code>PreparedStatement</code> y ejecutar la consulta.</p> <p>La tarea principal es transformar el <code>ResultSet</code> en una lista, pero es una tarea sencilla:</p> <ul> <li>Recorre el ResultSet (con next), y para cada fila: </li> <li>Crea un objeto con los valores almacenados en las columnas </li> <li>A\u00f1ade este objeto a la lista</li> </ul> <pre><code>package org.dam;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\n\n\npublic class Main {\n    public static void main(String[] args) throws SQLException {\n        ArrayList&lt;Persona&gt; lasPersonas = new ArrayList();\n\n        ConexionDB conDB = new ConexionDB(\"instituto\");\n\n        Connection con = conDB.getConexion();\n\n        String SQL = \"Select * from persona\";\n        // The statement\n        Statement st = con.createStatement(\n                ResultSet.TYPE_SCROLL_INSENSITIVE,\n                ResultSet.CONCUR_READ_ONLY);\n\n        // The execution\n        ResultSet rst = st.executeQuery(SQL);\n\n        if (!rst.next()) {\n            System.out.println(\"No hay personas en la BD2\");\n            rst.beforeFirst();\n            while (rst.next()) {\n                Persona p = new Persona(\n                        rst.getInt(1),\n                        rst.getString(2),\n                        rst.getString(3),\n                        rst.getInt(4));\n                System.out.println(\"A\u00f1adiendo\" + p);\n                lasPersonas.add(p);\n            }\n        }\n\n        System.out.println(\"A\u00f1adido \" + lasPersonas.size() + \" personas\");\n        rst.close();\n    }\n}\n</code></pre> <p>Ahora podr\u00e1s cambiar la informaci\u00f3n en los objetos y, finalmente, si se ha realizado alguna modificaci\u00f3n, deber\u00e1s guardarla en la base de datos. Las preguntas son:</p> <ul> <li>\u00bfC\u00f3mo puedo saber si se ha actualizado un objeto?</li> <li>\u00bfC\u00f3mo puedo saber qu\u00e9 campo debe guardarse?</li> </ul> <p>Como puedes ver, existen varias tareas que requieren un control de la modificaci\u00f3n de los datos y c\u00f3mo guardarlos. Esta tarea ser\u00e1 f\u00e1cil con ORM y la estudiaremos.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/","title":"Actividad Cliente MySQL","text":"<p>Vamos a crear un cliente de SGBD, como MySQL Workbench, pero en una versi\u00f3n de consola con una shell y un prompt. Nuestro cliente nos permite conectarnos a un servidor, seleccionar una base de datos y por \u00faltimo ejecutar varias consultas SQL.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#11-modo-de-servidor","title":"1.1. Modo de servidor","text":"<p>Al iniciar nuestro programa, pedir\u00e1 los datos del servidor.</p> <pre><code>java -jar cliente\n...\n$ Server: 127.0.0.1\n$ Port: 3308\n$ Username: root\n$ Password:\n$ (root) on 127.0.0.1:3308&gt;\n</code></pre> <p>Como puede ver en la \u00faltima l\u00ednea, el prompt es <code>(usuario) on IP:port&gt;</code>. Nuestro cliente muestra siempre d\u00f3nde estamos conectados.</p> <p>La lista de \u00f3rdenes que nuestro cliente aceptar\u00e1 cuando est\u00e9 conectado es (modo servidor):</p> <ul> <li><code>show database</code> o <code>show db</code> \u2192 muestra una lista con todas las bases de datos de nuestro SGBD.</li> <li><code>info</code> \u2192 muestra informaci\u00f3n sobre el SGBD y la configuraci\u00f3n de la conexi\u00f3n.</li> <li><code>import nombre_del_script</code> \u2192 permite cargar un script SQL desde un archivo.</li> <li><code>use nombre_de_la_bd</code> \u2192 cambia nuestro programa al modo base de datos.</li> <li><code>quit</code> \u2192 finaliza nuestro programa.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#12-mode-de-base-de-dades","title":"1.2. Mode de Base de Dades","text":"<p>Una vez que estemos conectados a un servidor y hayamos seleccionado una base de datos, nuestro cliente entrar\u00e1 en el modo de base de datos:</p> <pre><code>$ (root) on 127.0.0.1:3308&gt;use instituto\n$ (root) on 127.0.0.1:3308[instituto]&gt;\n</code></pre> <p>Puedes ver que el nombre de la base de datos se a\u00f1ade al prompt y ahora el programa est\u00e1 esperando comandos para la base de datos. Tienes que implementar estos comandos:</p> <ul> <li><code>sh tables</code> \u2192 muestra todas las tablas de la base de datos seleccionada.</li> <li><code>describe nombre_de_la_tabla</code> \u2192 muestra la descripci\u00f3n de esta tabla: campos, tipos de datos y claves primarias como m\u00ednimo.</li> <li><code>insert Nombre_de_la_Tabla</code> \u2192 de forma interactiva, pide al usuario el valor de cada campo e inserta una nueva fila.</li> <li><code>sql</code> \u2192 ejecuta cualquier consulta en la base de datos seleccionada.</li> <li><code>quit</code> \u2192 vuelve al modo SGBD.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#2-estructura-del-proyecto-y-consejo","title":"2. Estructura del proyecto y consejo","text":"<p>El proyecto contiene las siguientes clases:</p> <p></p> <p>Vamos a revisar las funciones de clase</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#21-servermanager","title":"2.1. ServerManager","text":"<p>Contiene main, y cuando se inicia, pide al usuario la informaci\u00f3n del servidor. A continuaci\u00f3n, inicia la clase <code>ConnectionManager</code> con los valores proporcionados.</p>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#22-connectionmanager","title":"2.2. ConnectionManager","text":"<p>Gestiona la consola principal del programa y tiene como atributos:</p> <pre><code>String server;\nString port;\nString user;\nString pass;\n</code></pre> <p>y como m\u00e9todos:</p> <ul> <li><code>ConnectionManager()</code> \u2192 constructor por defecto.</li> <li><code>ConnectionManager(String server, String port, String user, String pass)</code> \u2192 constructor general.</li> <li><code>public Connection connectDBMS()</code> \u2192 inicia y devuelve una conexi\u00f3n.</li> <li><code>public void showInfo()</code> \u2192 muestra la informaci\u00f3n del servidor.</li> <li><code>public void showDatabases()</code> \u2192 mostra les taules del servidor.</li> <li><code>public void importScript(String script)</code> \u2192 carga y ejecuta un script.</li> <li><code>public void startShell()</code> \u2192 inicia la consola del servidor. Esta consola est\u00e1 ya implementada.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#23-gestor-de-base-de-datos","title":"2.3. Gestor de Base de Datos","text":"<p>Gestiona la consola del modo base de datos y necesita un atributo adicional respecto al Gestor de Conexi\u00f3n:</p> <pre><code>String server;\nString port;\nString user;\nString pass;\nString dbname;\n</code></pre> <p>y como m\u00e9todos:</p> <ul> <li><code>DatabaseManager()</code> \u2192 constructor por defecto.</li> <li><code>DatabaseManager(String server, String port, String user, String pass,String dbname)</code> \u2192 constructor general.</li> <li><code>public Connection connectDatabase()</code> \u2192 inicia y devuelve una conexi\u00f3n a la base de datos actual.</li> <li><code>public void insertIntoTable(String table)</code> \u2192 inicia el asistente de inserci\u00f3n para la tabla dada.</li> <li><code>public void showDescTable(String table)</code> \u2192 muestra los metadatos de la tabla.</li> <li><code>public void executeSelect(String query)</code> \u2192 ejecuta una consulta dada (de cualquier tipo) y muestra los resultados en la pantalla, si los hubiere.</li> <li><code>public void startShell()</code> \u2192 inicia la consola del modo base de datos. Tienes que realizar una implementaci\u00f3n completa.</li> </ul>"},{"location":"Unidad%202%20Conectores%20de%20BBDD/clienteSQL/#3-inserciones-a-las-tablas","title":"3. Inserciones a las tablas.","text":"<p>El m\u00e9todo <code>insertIntoTable</code> es probablemente el m\u00e1s dif\u00edcil de la tarea, ya que es necesario pedir primero los metadatos de la tabla para conocer los campos y los tipos de datos de la tabla, y despu\u00e9s pedir al usuario los valores y los formatos.</p> <p>El consejo que se dar\u00e1 es crear tres listas con:</p> <ol> <li>Lista de campos a insertar.</li> <li>Lista de valores que se asignar\u00e1n.</li> <li>Lista de tipos de cada campo.</li> </ol> <p>Adem\u00e1s, es necesario generar una lista o cadena de marcadores de posici\u00f3n con tantos <code>?</code> como sea necesario.</p> <p>Consejo</p> <p>Recuerda que, al pedir los metadatos de la tabla, las columnas que necesitas son: </p> <ul> <li>Columna 4: nombre de la columna </li> <li>Columna 6: tipos de datos de la columna </li> <li>Columna 18: nullable o no. Este campo es obligatorio si no es nullable. </li> <li>Columna 23: incremental o no. No necesitas ese campo si es incremental. </li> </ul> <p>Por \u00faltimo, verifica el ajuste de los placeholders, ya que dependen del tipo de datos. Tener en cuenta que: </p> <ul> <li>Los datos <code>int</code> utilizar\u00e1n <code>setInt()</code> </li> <li>Los datos <code>datetime</code> utilizar\u00e1n <code>setDate()</code>, con un casting en <code>java.sql.Date</code> en lugar de <code>java.Date</code> </li> <li>Por defecto el <code>setString</code> y confiar en que el casting autom\u00e1tico haga su trabajo.</li> </ul> <p>Disponemos del paquete <code>ClienteSQL_alu</code> el siguiente enlace.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/","title":"1 Mapping","text":""},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#1-introduccion-tecnicas-de-mapeo","title":"1. Introducci\u00f3n. T\u00e9cnicas de mapeo.","text":"<p>En unidades anteriores hemos estudiado el acceso de nuestros programas a los ficheros y bases de datos relacionales. Como hemos visto, el gran problema es que nuestros programas manipulan objetos, mientras que las bases de datos manipulan tablas, lo que provoca el uso de modelos diferentes y termina en el ya citado vac\u00edo objeto-relacional.</p> <p>El mapeo objeto-relacional viene a llenar el vac\u00edo entre estos dos modelos, evitando que gastemos tiempo en nuestro c\u00f3digo convirtiendo entre los resultados de las operaciones y nuestros objetos. Con el uso de un ORM (Object Relational Mapping), una vez establecida la correspondencia entre los modelos, en nuestros programas s\u00f3lo trabajaremos con un modelo, el modelo orientado a objetos. De esta forma conseguimos evitar que nuestros programas caigan en ese vac\u00edo, centr\u00e1ndonos en la l\u00f3gica de negocio.</p> <p>Las t\u00e9cnicas ORM (Object-Relational Mapping Tools) son las encargadas, mediante un conjunto de descripciones y metadatos (datos que describen los datos), de hacer una correspondencia entre los datos primitivos de ambos modelos y sus estructuras: entre tablas y objetos, campos y atributos, sus identificadores y sus claves primarias. Esta correspondencia no siempre ser\u00e1 sencilla y tendr\u00e1n que estar disponibles metadatos que puedan expresar una mayor complejidad.</p> <p>Por ejemplo:</p> <ul> <li>Quiz\u00e1s encontraremos que a veces puede ser interesante almacenar una propiedad en m\u00e1s de una columna, o varias propiedades en una sola columna.</li> <li>En otras ocasiones, puede haber propiedades que no se almacenen, o campos de la base de datos que no aparezcan en los objetos.</li> <li>Utilice atributos con tipos de datos no primitivos que necesitan ser convertidos en otras tablas, y decida qu\u00e9 campos ser\u00e1n claves externas que apunten a las nuevas tablas.</li> </ul> <p>Al igual que la definici\u00f3n de los datos, necesitaremos un mecanismo de persistencia de objetos, de modo que los objetos puedan ser \"rastreados\" en la memoria y cuando se reflejen cambios en ellos, se reflejen directamente en la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#12-mapeo","title":"1.2. Mapeo","text":"ORM <p>Con estas herramientas de mapeo conseguiremos:</p> <ul> <li>Reducir el tiempo de desarrollo</li> <li>Olvidarnos de nuestro SGBD subyacente</li> <li>Trabajar con objetos, atributos y m\u00e9todos. No necesita saber nada sobre tablas y relaciones.</li> </ul> <p>Todas las herramientas de mapeo se basan en estas tres bases s\u00f3lidas.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#121-tecnicas-de-mapeo","title":"1.2.1. T\u00e9cnicas de mapeo","text":"<p>Destacamos dos t\u00e9cnicas de mapeo objeto-relacional:</p> <ul> <li>Aquellas que incrustan las definiciones dentro del c\u00f3digo de las clases y est\u00e1n vinculadas al lenguaje, como macros de C++ o anotaciones de PHP y Java.</li> <li>Aquellas que guardan las definiciones en archivos independientes del c\u00f3digo, generalmente en XML o JSON.</li> </ul> <p>Estas t\u00e9cnicas no son exclusivas, puesto que ambas est\u00e1n disponibles en la mayor\u00eda de entornos e incluso pueden coexistir en la misma aplicaci\u00f3n.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#122-lenguaje-de-consulta","title":"1.2.2. Lenguaje de consulta","text":"<p>Dado que los SGBD incluyen SQL como lenguaje de consulta, la mayor\u00eda de los ORM incluyen su propio lenguaje, basado en OQL (Object Query Language). Como en SQL, podemos pedir informaci\u00f3n, pero basada en objetos en lugar de tablas.</p>"},{"location":"Unidad%203%20Hibernate/1_Mapping.es/#123-sincronizacion","title":"1.2.3. Sincronizaci\u00f3n","text":"<p>Los ORM incluyen varios procesos centrados en:</p> <ul> <li>Seguir y descubrir los cambios que experimentan los objetos durante su ciclo de vida para almacenarlos.</li> <li>Crear e iniciar nuevas instancias de objetos a partir de los datos almacenados en la base de datos.</li> <li>A partir de los objetos, extraer su informaci\u00f3n para reflejarla en las tablas de la base de datos.</li> </ul> <p>Note</p> <p>Estudiaremos el ciclo de vida de los objetos cuando se cargan y guardan de la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/","title":"2. Hibernate","text":"Hibernate <p>Hibernate es un framework ORM para Java, que facilita la correspondencia de atributos entre una base de datos relacional y el modelo de objetos de nuestra aplicaci\u00f3n mediante archivos XML o anotaciones en los beans de entidad. Es un software libre distribuido bajo la licencia GPL 2.0, por lo que puede utilizarse en aplicaciones comerciales.</p> <p>Hibernate es la implementaci\u00f3n m\u00e1s popular de la especificaci\u00f3n JPA (Java Persistence API), un est\u00e1ndar de Java para la persistencia de objetos. JPA proporciona una API uniforme mientras que Hibernate ofrece la implementaci\u00f3n robusta que maneja la correspondencia ORM.</p> <p>La funci\u00f3n principal de Hibernate con JPA ser\u00e1 ofrecer al programador las herramientas para detallar su modelo de datos mediante anotaciones est\u00e1ndar, de modo que sea el propio ORM el que interact\u00fae con la base de datos, mientras que el desarrollador se dedica a manipular objetos.</p> Hibernate Arquitecture <p>JPA introduce el EntityManager como interfaz principal para las operaciones de persistencia, reemplazando en muchos casos el uso directo de Session de Hibernate. Los objetos creados son rastreados en el contexto de persistencia, y las operaciones se sincronizan con la base de datos al confirmar las transacciones.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#21-configuracion","title":"2.1 Configuraci\u00f3n","text":"<p>Hibernate, como implementaci\u00f3n de JPA, no necesita una instalaci\u00f3n espec\u00edfica, puesto que est\u00e1 integrado en nuestro proyecto como librer\u00edas. Utilizaremos Maven como gestor de paquetes para automatizar las dependencias.</p> <p>Utilizaremos Maven como gestor de paquetes.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#22-dependencias","title":"2.2 Dependencias.","text":"<p>En nuestros proyectos se utilizar\u00e1n dos herramientas b\u00e1sicas: Hibernate y un controlador para conectarse a la base de datos seleccionada. Obviamente, es necesario a\u00f1adir las dependencias al gestor de paquetes. En Maven, las dependencias se incluyen en el archivo <code>Pom.xml</code>, en la carpeta ra\u00edz de nuestro proyecto. Dentro de la etiqueta <code>&lt;dependencias&gt;</code> hay que a\u00f1adir:</p> MavenGradle <pre><code>&lt;dependencies&gt;\n    &lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n        &lt;version&gt;9.4.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.hibernate.orm/hibernate-core --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n        &lt;version&gt;7.1.2.Final&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Jakarta Persistence API --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n        &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n        &lt;version&gt;3.2.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Logging --&gt;\n    &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n        &lt;version&gt;1.5.19&lt;/version&gt;\n        &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;version&gt;1.18.42&lt;/version&gt;\n        &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>// Hibernate como implementaci\u00f3n JPA\nimplementation(\"org.hibernate.orm:hibernate-core:7.1.2.Final\")\n\n// MySQL Connector\n// https://mvnrepository.com/artifact/com.mysql/mysql-connector-j\nimplementation(\"com.mysql:mysql-connector-j:9.4.0\")\n\n// API JPA (Jakarta Persistence)\n// https://mvnrepository.com/artifact/jakarta.persistence/jakarta.persistence-api\nimplementation(\"jakarta.persistence:jakarta.persistence-api:3.2.0\")\n\n// https://mvnrepository.com/artifact/org.projectlombok/lombok\nimplementation(\"org.projectlombok:lombok:1.18.42\")\n\n// https://mvnrepository.com/artifact/ch.qos.logback/logback-classic\nimplementation(\"ch.qos.logback:logback-classic:1.5.19\")\n</code></pre> <p>Recuerda...</p> <p>Recuerda que puedes encontrar los paquetes en https://mvnrepository.com/repos/central</p> <p>Adem\u00e1s vamos a hacer uso del paquete logback-classic el cual nos proporcionar\u00e1 informaci\u00f3n de los log de nuestra aplicaci\u00f3n. La dependecia se puede ver en los gestores anteriores.</p> <p>Para ello necesitaremos configurar el fichero logback.xml:</p> <pre><code>src/\n\u251c\u2500\u2500 main/\n\u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u2514\u2500\u2500 (tu c\u00f3digo de la librer\u00eda)\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 META-INF/\n\u2502       \u2502   \u2514\u2500\u2500 persistence.xml\n\u2502       \u2514\u2500\u2500 logback.xml\n</code></pre> <p>Antes de abordar la configuraci\u00f3n, vamos a ver los niveles que queremos de log, fichero logback.xml</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#221-opcion-recomendada-para-las-librerias","title":"2.2.1. Opci\u00f3n recomendada para las librerias","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;!-- Configuraci\u00f3n para Hibernate --&gt;\n    &lt;logger name=\"org.hibernate.engine\" level=\"INFO\"/&gt;\n    &lt;logger name=\"org.hibernate.mapping.Table\" level=\"INFO\"/&gt;\n    &lt;logger name=\"org.hibernate.service.internal.SessionFactoryServiceRegistryImpl\" level=\"INFO\"/&gt;\n\n     &lt;!-- Tu librer\u00eda - nivel INFO para mensajes importantes --&gt;\n    &lt;logger name=\"tu.paquete.libreria\" level=\"INFO\"/&gt;\n\n    &lt;!-- Configuraci\u00f3n general --&gt;\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n    &lt;/root&gt;\n\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Esta es la informaci\u00f3n que nos va a dar cuando estemos probando nuestro desarrollo.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#222-opcion-de-produccion","title":"2.2.2. Opci\u00f3n de producci\u00f3n","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;!-- Nivel WARN para evitar la mayor\u00eda de los logs --&gt;\n    &lt;logger name=\"org.hibernate\" level=\"WARN\"/&gt;\n    &lt;logger name=\"org.demo\" level=\"WARN\"/&gt;\n\n    &lt;root level=\"WARN\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n    &lt;/root&gt;\n\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#223-desactivar-completamente-los-log","title":"2.2.3. Desactivar completamente los log","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;root level=\"OFF\"/&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#23-estructura-del-proyecto","title":"2.3. Estructura del proyecto","text":"<p>Una vez que hemos a\u00f1adido las dependencias, debemos crear una estructura de proyecto para organizar nuestras clases, con el objetivo de separar la l\u00f3gica del programa. A continuaci\u00f3n, mostraremos una breve descripci\u00f3n, profundizando en cada punto m\u00e1s adelante.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#231-entidades-jpa","title":"2.3.1. Entidades JPA","text":"<p>Las entidades JPA son la evoluci\u00f3n de los Beans tradicionales:</p> <p>Como extensi\u00f3n de los POJOs, aparecen los Beans, sin restricciones en los atributos, constructores y herencia. Tienen algunas restricciones:</p> <ul> <li>Sus atributos deben ser <code>private</code> (encapsulaci\u00f3n).</li> <li>Deben implementar la interfaz <code>Serializable</code>.</li> <li>Deben tener getters y setters p\u00fablicos.</li> <li>Deben tener un constructor gen\u00e9rico (sin argumentos).</li> </ul> <p>Recuerda</p> <p>La serializaci\u00f3n en tiempo de ejecuci\u00f3n asocia a cada clase serializable un n\u00famero de versi\u00f3n, llamado <code>serialVersionUID</code>, que se utiliza durante la deserializaci\u00f3n para verificar que el emisor y el receptor de un objeto serializado han cargado clases para ese objeto que son compatibles en relaci\u00f3n a la serializaci\u00f3n. </p> <p>Si el receptor ha cargado una clase para el objeto que tiene un <code>serialVersionUID</code> distinto al de la clase del emisor correspondiente, entonces la deserializaci\u00f3n dar\u00e1 lugar a una <code>InvalidClassException</code>. Una clase serializable puede declarar su propio <code>serialVersionUID</code> expl\u00edcitament mediante la declaraci\u00f3n de un campo llamado <code>serialVersionUID</code> que debe ser est\u00e1tico, final y de tipo long: </p> <p>As\u00ed, los Beans son componentes de acceso a datos y representan a entidades en nuestra aplicaci\u00f3n. Es una buena idea crear nuestros Beans en la misma carpeta, normalmente llamada <code>Modelo</code>.</p> <p>Nosotros vamos a trabajar con JPA que es lo que la industria hace uso actualmente.</p> <pre><code>import jakarta.persistence.*;\nimport lombok.Data;\n\nimport java.io.Serializable;\n\n@Data\n@Entity\n@Table(name = \"Peli\")\npublic class Peli implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idPeli;\n\n    @Column(name = \"titulo\", nullable = false)\n    private String titulo;\n\n    @Column(name = \"anyo\")\n    private int anyo;\n\n    @Column(name = \"director\")\n    private String elDirector;\n\n    // Constructor por defecto (OBLIGATORIO en JPA)\n    public Peli() {\n    }\n\n    // Constructor con par\u00e1metros\n    public Peli(String titulo, int anyo, String elDirector) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.elDirector = elDirector;\n    }\n\n\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#232-archivos-de-mapeo","title":"2.3.2. Archivos de mapeo","text":"<p>\u00a1IMPORTANTE! Con JPA, los archivos <code>*.hbm.xml</code> NO SON NECESARIOS. Todo el mapeo se define mediante anotaciones en las clases entidad.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#24-configuracion-del-proyecto","title":"2.4. Configuraci\u00f3n del proyecto","text":"<p>Vamos a examinar m\u00e1s detenidamente el archivo de configuraci\u00f3n de Hibernate. En el archivo de configuraci\u00f3n de Hibernate podemos establecer las opciones de forma desordenada, pero se recomienda agrupar los bloques de opciones para aclarar y mantener el c\u00f3digo, as\u00ed como indicar mediante comentarios qu\u00e9 estamos haciendo en cada momento. Lo veremos con un ejemplo completo, que detallaremos paso a paso en las siguientes secciones.</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#241-hibernatecfgxml","title":"2.4.1. Hibernate.cfg.xml","text":"XML <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE hibernate-configuration PUBLIC\n\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n\n&lt;hibernate-configuration&gt;\n    &lt;session-factory&gt;\n        &lt;!-- Configuraci\u00f3n de conexi\u00f3n --&gt;\n        &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3308/DBName&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt;\n\n        &lt;!-- Pool de conexiones --&gt;\n        &lt;property name=\"hibernate.connection.pool_size\"&gt;5&lt;/property&gt;\n\n        &lt;!-- Dialecto --&gt;\n        &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n\n        &lt;!-- Contexto de sesi\u00f3n --&gt;\n        &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;\n\n        &lt;!-- Mostrar SQL (solo desarrollo) --&gt;\n        &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;\n        &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;\n\n        &lt;!-- Estrategia DDL --&gt;\n        &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;\n\n        &lt;!-- Mapeo de clases entidad JPA --&gt;\n        &lt;mapping class=\"paquete.entidad.Peli\" /&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#242-alternativa-persistencexml","title":"2.4.2 Alternativa: persistence.xml","text":"XML <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;\n&lt;persistence xmlns=\"https://jakarta.ee/xml/ns/persistence\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_2.xsd\"\n            version=\"3.2\"&gt;\n    &lt;persistence-unit name=\"PelisUP\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;\n\n        &lt;class&gt;Peli&lt;/class&gt;\n\n        &lt;properties&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.url\" value=\"jdbc:mysql://localhost:3308/Cine1_V1\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.user\" value=\"root\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.password\" value=\"root\"/&gt;\n\n            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQLDialect\"/&gt;\n            &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#243-opciones-hbm2ddlauto","title":"2.4.3 Opciones hbm2ddl.auto","text":"Opci\u00f3n Descripci\u00f3n <code>create</code> Crea siempre la BD cuando se carga la session factory. Se pierden los datos. <code>update</code> Los datos se mantienen, pero la estructura se actualiza. \u00datil en producci\u00f3n. <code>create-drop</code> Como create pero elimina la base de datos al final. <code>validate</code> Comprueba el mapeo entre la base de datos y los beans. <code>none</code> No realiza acciones DDL."},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#244-carga-de-scripts","title":"2.4.4 Carga de scripts","text":"<p>Para insertar datos de prueba, crea un archivo <code>import.sql</code> en <code>src/main/resources</code>. Se ejecutar\u00e1 autom\u00e1ticamente despu\u00e9s de la creaci\u00f3n de tablas.</p> <p>Para m\u00faltiples scripts:</p> XML <pre><code>&lt;property name=\"hibernate.hbm2ddl.import_files\"&gt; \n/import1.sql, /import2.sql\n&lt;/property&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#25-configuracion-de-sesiones","title":"2.5 Configuraci\u00f3n de sesiones","text":""},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#251-hibernateutil-con-jpa","title":"2.5.1 HibernateUtil con JPA","text":"Java <pre><code>import org.hibernate.SessionFactory;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\n\npublic class HibernateUtil { \n\n    private static final SessionFactory sessionFactory; \n\n    static { \n        try { \n            StandardServiceRegistry registry = new StandardServiceRegistryBuilder()\n                    .configure(\"hibernate.cfg.xml\")\n                    .build();\n\n            MetadataSources sources = new MetadataSources(registry);\n            sources.addAnnotatedClass(Peli.class);\n\n            Metadata metadata = sources.getMetadataBuilder().build();\n            sessionFactory = metadata.getSessionFactoryBuilder().build();\n\n        } catch (Throwable ex) { \n            System.err.println(\"Error en la inicializaci\u00f3n. \" + ex); \n            throw new ExceptionInInitializerError(ex); \n        } \n    } \n\n    public static SessionFactory getSessionFactory() { \n        return sessionFactory; \n    }\n\n    public static void shutdown() {\n        if (sessionFactory != null) {\n            sessionFactory.close();\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#252-jpautil-alternativa-estandar","title":"2.5.2 JPAUtil (Alternativa est\u00e1ndar)","text":"Java <pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.Persistence;\n\npublic class JPAUtil {\n    private static final EntityManagerFactory emf = \n        Persistence.createEntityManagerFactory(\"miUnidadPersistencia\");\n\n    public static EntityManager getEntityManager() {\n        return emf.createEntityManager();\n    }\n\n    public static void close() {\n        if (emf != null &amp;&amp; emf.isOpen()) {\n            emf.close();\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#26-operaciones-basicas","title":"2.6 Operaciones b\u00e1sicas","text":""},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#261-persistir-entidades","title":"2.6.1 Persistir entidades","text":"Con SessionCon EntityManager <pre><code>Session session = HibernateUtil.getSessionFactory().openSession();\nTransaction tx = session.beginTransaction();\n\nPeli nuevaPeli = new Peli(\"Inception\", 2010, \"Christopher Nolan\");\nsession.persist(nuevaPeli);\n\ntx.commit();\nsession.close();\n</code></pre> <pre><code>EntityManager em = JPAUtil.getEntityManager();\nEntityTransaction tx = em.getTransaction();\ntx.begin();\n\nem.persist(nuevaPeli);\n\ntx.commit();\nem.close();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#262-buscar-por-id","title":"2.6.2 Buscar por ID","text":"Con SessionCon EntityManager <pre><code>Peli peli = session.find(Peli.class, 1L);\n</code></pre> <pre><code>Peli peli = em.find(Peli.class, 1L);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#263-actualizar-entidades","title":"2.6.3 Actualizar entidades","text":"Java <pre><code>Peli peli = em.find(Peli.class, 1L);\npeli.setTitulo(\"Nuevo t\u00edtulo\");\n// La actualizaci\u00f3n es autom\u00e1tica al hacer commit\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#264-eliminar-entidades","title":"2.6.4 Eliminar entidades","text":"Java <pre><code>Peli peli = em.find(Peli.class, 1L);\nem.remove(peli);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#27-consultas-con-jpql","title":"2.7 Consultas con JPQL","text":""},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#271-consulta-basica","title":"2.7.1 Consulta b\u00e1sica","text":"Java <pre><code>TypedQuery&lt;Peli&gt; query = em.createQuery(\n    \"SELECT p FROM Peli p WHERE p.anyo &gt; :anio\", Peli.class);\nquery.setParameter(\"anio\", 2000);\nList&lt;Peli&gt; pelis = query.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#272-consulta-con-multiples-resultados","title":"2.7.2 Consulta con m\u00faltiples resultados","text":"Java <pre><code>TypedQuery&lt;Object[]&gt; query = em.createQuery(\n    \"SELECT p.titulo, p.director FROM Peli p\", Object[].class);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#273-consultas-nativas-sql","title":"2.7.3 Consultas nativas SQL","text":"Java <pre><code>Query query = em.createNativeQuery(\"SELECT * FROM Peli WHERE anyo &gt; ?\", Peli.class);\nquery.setParameter(1, 2000);\nList&lt;Peli&gt; pelis = query.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#28-ejemplo-completo","title":"2.8 Ejemplo completo","text":"Java <p>```java</p> <p>import jakarta.persistence.*;</p> <p>import java.util.List;</p> <p>public class Main {     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"PelisUP\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();</p> <pre><code>    try {\n        tx = em.getTransaction();\n        tx.begin();\n\n        // Crear y guardar nueva entidad\n        Peli peli = new Peli(\"The Matrix\", 1999, \"Lana Wachowski\");\n        em.persist(peli);\n\n        // Buscar entidad\n        Peli encontrada = em.find(Peli.class, peli.getIdPeli());\n        System.out.println(\"Encontrada: \" + encontrada);\n\n        // Consulta JPQL\n        TypedQuery&lt;Peli&gt; query = em.createQuery(\n                \"SELECT p FROM Peli p WHERE p.anyo &gt;= :anio\", Peli.class);\n        query.setParameter(\"anio\", 2000);\n        List&lt;Peli&gt; pelisRecientes = query.getResultList();\n        pelisRecientes.forEach(System.out::println);\n        tx.commit();\n\n    } catch (Exception e) {\n        if (tx != null &amp;&amp; tx.isActive()) {\n            tx.rollback();\n        }\n        e.printStackTrace();\n    } finally {\n        em.close();\n    }\n}\n</code></pre> <p>}     ```</p>"},{"location":"Unidad%203%20Hibernate/2_Hibernate.es/#29-ventajas-de-jpa","title":"2.9 Ventajas de JPA","text":"Ventaja Descripci\u00f3n Portabilidad Puedes cambiar entre diferentes implementaciones JPA Est\u00e1ndar Las anotaciones JPA son reconocidas universalmente Integraci\u00f3n Mejor compatibilidad con Spring y otros frameworks Mantenimiento C\u00f3digo m\u00e1s limpio y f\u00e1cil de mantener Futuro JPA es el est\u00e1ndar actual de la industria <p>Mejores pr\u00e1cticas</p> <p>- Siempre usa anotaciones JPA en lugar de archivos XML</p> <p>- Maneja las transacciones correctamente</p> <p>- Usa <code>@Entity</code> y <code>@Table</code> para el mapeo de entidades</p> <p>- Define <code>@Id</code> y estrategia de generaci\u00f3n apropiada</p> <p>- Cierra recursos en bloques finally o usa try-with-resources</p> <p>Atenci\u00f3n</p> <p>Esta implementaci\u00f3n mantiene la compatibilidad con el patr\u00f3n Singleton para SessionFactory/EntityManagerFactory, asegurando una \u00fanica instancia en la aplicaci\u00f3n.</p> <p>El proyecto completo lo puedes descargar aqui demo1</p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/","title":"3. Mapeo de Entidades con JPA y Hibernate","text":"<p>Una vez estudiada la configuraci\u00f3n inicial, es momento de mapear nuestras entidades y relaciones usando JPA. Partiendo del modelo relacional, usaremos la entidad <code>Peli</code>:</p> <pre><code>CREATE TABLE `Peli` (\n  `idPeli` int(11) NOT NULL AUTO_INCREMENT,\n  `titulo` varchar(45) NOT NULL,\n  `anyo` varchar(45) NOT NULL,\n  `director` varchar(45) NOT NULL,\n  PRIMARY KEY (`idPeli`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n</code></pre> <p>Aqu\u00ed hay un script DBCine.sql con el que trabajar. </p> <p>Estructura del Proyecto <pre><code>JPAhibernate/\n\u251c\u2500\u2500 src/main/java/\n\u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2514\u2500\u2500 Peli.java                 # Entidad principal\n\u2502   \u251c\u2500\u2500 util/\n\u2502   \u2502   \u2514\u2500\u2500 JpaUtil.java              # Utilidad para JPA\n\u2502   \u2514\u2500\u2500 Main.java                     # Aplicaci\u00f3n principal\n\u251c\u2500\u2500 src/main/resources/\n\u2502   \u251c\u2500\u2500 META-INF/\n\u2502   \u2502   \u2514\u2500\u2500 persistence.xml           # Configuraci\u00f3n JPA\n\u2502   \u2514\u2500\u2500 logback.xml                   # Configuraci\u00f3n de logs\n\u2514\u2500\u2500 pom.xml                          # Dependencias Maven\n</code></pre></p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#31-configuracion-de-dependencias","title":"3.1. Configuraci\u00f3n de dependencias","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#pomxml","title":"pom.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.cipfpcheste.dam2&lt;/groupId&gt;\n    &lt;artifactId&gt;JPAhibernate&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;JPAhibernate&lt;/name&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;\n        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;\n        &lt;junit.version&gt;5.11.0&lt;/junit.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Conector MySQL --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n            &lt;version&gt;9.4.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Hibernate ORM --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n            &lt;version&gt;7.1.2.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Jakarta Persistence API --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n            &lt;version&gt;3.2.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Logging con Logback --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n            &lt;version&gt;1.5.19&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#explicacion-de-dependencias","title":"Explicaci\u00f3n de Dependencias","text":"Dependencia Versi\u00f3n Prop\u00f3sito <code>mysql-connector-j</code> 9.4.0 Conector oficial para MySQL <code>hibernate-core</code> 7.1.2.Final Implementaci\u00f3n ORM de Hibernate <code>jakarta.persistence-api</code> 3.2.0 API est\u00e1ndar de JPA (Jakarta) <code>logback-classic</code> 1.5.19 Sistema de logging avanzado"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#32-archivos-de-configuracion","title":"3.2.  Archivos de Configuraci\u00f3n","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#persistencexml","title":"persistence.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence version=\"3.2\"\n             xmlns=\"https://jakarta.ee/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence\n             https://jakarta.ee/xml/ns/persistence/persistence_3_2.xsd\"&gt;\n\n    &lt;persistence-unit name=\"cinePU\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n        &lt;description&gt;Unidad de persistencia para aplicaci\u00f3n Cine - Hibernate 7.1.2&lt;/description&gt;\n\n        &lt;!-- Proveedor Hibernate 7 --&gt;\n        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;\n\n        &lt;!-- Entidades --&gt;\n        &lt;class&gt;model.Peli&lt;/class&gt;\n\n        &lt;properties&gt;\n            &lt;!-- Conexi\u00f3n a Base de Datos - FORMATO NUEVO --&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.driver\"\n                      value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.url\"\n                      value=\"jdbc:mysql://localhost:3308/Cine1_V1?createDatabaseIfNotExist=true\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.user\" value=\"root\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.password\" value=\"root\"/&gt;\n\n            &lt;!-- Configuraci\u00f3n espec\u00edfica de Hibernate 7 --&gt;\n            &lt;property name=\"hibernate.dialect\"\n                      value=\"org.hibernate.dialect.MySQLDialect\"/&gt;\n            &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt;\n            &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt;\n\n            &lt;!-- NUEVAS PROPIEDADES HIBERNATE 7 --&gt;\n            &lt;property name=\"hibernate.connection.provider_disables_autocommit\" value=\"true\"/&gt;\n            &lt;property name=\"hibernate.session.events.log\" value=\"false\"/&gt;\n\n            &lt;!-- Pool de conexiones --&gt;\n            &lt;property name=\"hibernate.connection.pool_size\" value=\"5\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#propiedades-de-configuracion-clave","title":"Propiedades de Configuraci\u00f3n Clave","text":"Propiedad Valor Descripci\u00f3n <code>hibernate.dialect</code> <code>MySQLDialect</code> Dialecto SQL para MySQL <code>hibernate.hbm2ddl.auto</code> <code>update</code> Actualiza esquema autom\u00e1ticamente <code>hibernate.show_sql</code> <code>true</code> Muestra SQL en consola <code>hibernate.format_sql</code> <code>true</code> Formatea SQL para mejor legibilidad <code>hibernate.connection.pool_size</code> <code>5</code> Tama\u00f1o del pool de conexiones"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#logbackxml","title":"logback.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- Logs espec\u00edficos para Hibernate 7 --&gt;\n    &lt;logger name=\"org.hibernate\" level=\"INFO\"/&gt;\n    &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/&gt;\n    &lt;logger name=\"org.hibernate.orm.jdbc.bind\" level=\"TRACE\"/&gt;\n    &lt;logger name=\"org.hibernate.stat\" level=\"DEBUG\"/&gt;\n\n    &lt;root level=\"INFO\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\" /&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#33-modelo-de-datos","title":"3.3.  Modelo de Datos","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#pelijava","title":"Peli.java","text":"<pre><code>package model;\n\nimport jakarta.persistence.*;\nimport java.io.Serializable;\n\n@Entity\n@Table(name = \"Peli\")\npublic class Peli implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idPeli;\n\n    @Column(name = \"titulo\", nullable = false, length = 100)\n    private String titulo;\n\n    @Column(name = \"anyo\", nullable = false)\n    private int anyo;\n\n    @Column(name = \"director\", nullable = false, length = 100)\n    private String elDirector;\n\n    // Constructores\n    public Peli() {}\n\n    public Peli(String titulo, int anyo, String elDirector) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.elDirector = elDirector;\n    }\n\n    // Getters y setters\n    public Long getIdPeli() {\n        return idPeli;\n    }\n\n    public void setIdPeli(Long idPeli) {\n        this.idPeli = idPeli;\n    }\n\n    public String getTitulo() {\n        return titulo;\n    }\n\n    public void setTitulo(String titulo) {\n        this.titulo = titulo;\n    }\n\n    public int getAnyo() {\n        return anyo;\n    }\n\n    public void setAnyo(int anyo) {\n        this.anyo = anyo;\n    }\n\n    public String getElDirector() {\n        return elDirector;\n    }\n\n    public void setElDirector(String elDirector) {\n        this.elDirector = elDirector;\n    }\n\n    @Override\n    public String toString() {\n        return \"Peli{\" +\n                \"idPeli=\" + idPeli +\n                \", titulo='\" + titulo + '\\'' +\n                \", anyo=\" + anyo +\n                \", director='\" + elDirector + '\\'' +\n                '}';\n    }\n}\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#anotaciones-jpa-explicadas","title":"Anotaciones JPA Explicadas","text":"Anotaci\u00f3n Uso Descripci\u00f3n <code>@Entity</code> Clase Marca la clase como entidad persistente <code>@Table</code> Clase Especifica el nombre de la tabla en BD <code>@Id</code> Campo Indica la clave primaria <code>@GeneratedValue</code> Campo Estrategia de generaci\u00f3n de IDs <code>@Column</code> Campo Mapea el campo a columna de BD <p>Informaci\u00f3n</p> <p>M\u00e1s informaci\u00f3n, aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#estrategia-de-generacion-de-ids","title":"Estrategia de Generaci\u00f3n de IDs","text":"<pre><code>@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long idPeli;\n</code></pre> <p>La estrategia <code>IDENTITY</code> usa la auto-incrementaci\u00f3n de MySQL para generar los IDs autom\u00e1ticamente.</p>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#34-utilidades-jpa","title":"3.4.  Utilidades JPA","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#jpautiljava","title":"JpaUtil.java","text":"<pre><code>package util;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.Persistence;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class JpaUtil {\n    private static final String PERSISTENCE_UNIT_NAME = \"cinePU\";\n    private static EntityManagerFactory entityManagerFactory;\n\n    static {\n        initialize();\n    }\n\n    private static void initialize() {\n        try {\n            System.out.println(\"Inicializando Hibernate 7.1.2...\");\n\n            // Configuraci\u00f3n program\u00e1tica adicional si es necesaria\n            Map&lt;String, Object&gt; configOverrides = new HashMap&lt;&gt;();\n            configOverrides.put(\"hibernate.connection.autocommit\", \"false\");\n\n            entityManagerFactory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME, configOverrides);\n\n            System.out.println(\"EntityManagerFactory creado exitosamente con Hibernate 7\");\n            System.out.println(\"Metadata: \" + entityManagerFactory.getMetamodel().getEntities().size() + \" entidades cargadas\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error inicializando Hibernate 7: \" + e.getMessage());\n            e.printStackTrace();\n            throw new ExceptionInInitializerError(\"Fallo en inicializaci\u00f3n de Hibernate 7: \" + e.getMessage());\n        }\n    }\n\n    public static EntityManager getEntityManager() {\n        if (entityManagerFactory == null) {\n            initialize();\n        }\n        return entityManagerFactory.createEntityManager();\n    }\n\n    public static EntityManagerFactory getEntityManagerFactory() {\n        return entityManagerFactory;\n    }\n\n    public static void close() {\n        if (entityManagerFactory != null &amp;&amp; entityManagerFactory.isOpen()) {\n            entityManagerFactory.close();\n            System.out.println(\"EntityManagerFactory cerrado\");\n            entityManagerFactory = null;\n        }\n    }\n\n    public static boolean isInitialized() {\n        return entityManagerFactory != null &amp;&amp; entityManagerFactory.isOpen();\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#patron-singleton-para-entitymanagerfactory","title":"Patr\u00f3n Singleton para EntityManagerFactory","text":"<p>El <code>EntityManagerFactory</code> es un objeto pesado que debe crearse una sola vez en toda la aplicaci\u00f3n. Por eso usamos:</p> <ul> <li>Bloque est\u00e1tico: Se ejecuta al cargar la clase</li> <li>Singleton: Una \u00fanica instancia compartida</li> <li>Lazy initialization: Se crea solo cuando se necesita</li> </ul>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#ciclo-de-vida-de-entitymanager","title":"Ciclo de Vida de EntityManager","text":"<pre><code>// 1. Obtener EntityManager\nEntityManager em = JpaUtil.getEntityManager();\n\ntry {\n    // 2. Iniciar transacci\u00f3n\n    EntityTransaction tx = em.getTransaction();\n    tx.begin();\n\n    // 3. Operaciones JPA\n    em.persist(entidad);\n\n    // 4. Confirmar transacci\u00f3n\n    tx.commit();\n\n} finally {\n    // 5. CERRAR SIEMPRE el EntityManager\n    em.close();\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#35-aplicacion-principal","title":"3.5. Aplicaci\u00f3n Principal","text":""},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#mainjava","title":"Main.java","text":"<pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityTransaction;\nimport model.Peli;\nimport util.JpaUtil;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"=== HIBERNATE 7.1.2 - JPA PURO ===\");\n\n        EntityManager em = null;\n        EntityTransaction tx = null;\n\n        try {\n            // 1. Obtener EntityManager\n            em = JpaUtil.getEntityManager();\n            System.out.println(\" EntityManager obtenido - Hibernate 7.1.2\");\n\n            // 2. Verificar conexi\u00f3n\n            boolean connected = em.isOpen();\n            System.out.println(\" EntityManager abierto: \" + connected);\n\n            // 3. Iniciar transacci\u00f3n\n            tx = em.getTransaction();\n            tx.begin();\n            System.out.println(\"Transacci\u00f3n iniciada\");\n\n            // 4. Crear y persistir entidad\n            Peli pelicula = new Peli(\"Avatar: El sentido del agua\", 2022, \"James Cameron\");\n            System.out.println(\" Creando: \" + pelicula);\n\n            em.persist(pelicula);\n            em.flush(); // Forzar INSERT inmediato\n            System.out.println(\"Persistido con ID: \" + pelicula.getIdPeli());\n\n            // 5. Buscar para verificar\n            Peli recuperada = em.find(Peli.class, pelicula.getIdPeli());\n            System.out.println(\" Recuperado: \" + recuperada);\n\n            // 6. Consulta JPQL\n            Long count = em.createQuery(\"SELECT COUNT(p) FROM Peli p\", Long.class).getSingleResult();\n            System.out.println(\" Total de pel\u00edculas en BD: \" + count);\n\n            // 7. Confirmar transacci\u00f3n\n            tx.commit();\n            System.out.println(\" Transacci\u00f3n confirmada\");\n\n            System.out.println(\" HIBERNATE 7.1.2 FUNCIONANDO CORRECTAMENTE!\");\n\n        } catch (Exception e) {\n            System.err.println(\" ERROR: \" + e.getMessage());\n            if (tx != null &amp;&amp; tx.isActive()) {\n                tx.rollback();\n                System.out.println(\" Transacci\u00f3n revertida\");\n            }\n            e.printStackTrace();\n        } finally {\n            if (em != null &amp;&amp; em.isOpen()) {\n                em.close();\n                System.out.println(\" EntityManager cerrado\");\n            }\n            JpaUtil.close();\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/3_Entities_Beans.es/#operaciones-jpa-demostradas","title":"Operaciones JPA Demostradas","text":"Operaci\u00f3n M\u00e9todo Descripci\u00f3n Create <code>em.persist()</code> Inserta nueva entidad Read <code>em.find()</code> Busca por ID JPQL <code>createQuery()</code> Consulta con lenguaje JPA Flush <code>em.flush()</code> Sincroniza con BD inmediatamente <p>Proyecto de ejemplo aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/","title":"4. Mapeando Relaciones","text":"<p>Como mencionamos en la introducci\u00f3n, analizaremos c\u00f3mo mapear los diferentes tipos de relaciones. Antes de empezar a discutir la cardinalidad de las relaciones, debemos considerar el significado de estas relaciones, y revisaremos el concepto de direccionalidad de las relaciones.</p> <ul> <li>Unidireccional \u2192 Diremos que una relaci\u00f3n es unidireccional cuando accedamos al objeto relacionado (componente) desde otro objeto (propietario). Por ejemplo, si montamos un motor en un coche, lo l\u00f3gico es que el propietario sea el coche, y desde \u00e9ste obtendremos el motor. En este caso, dentro del objeto Coche aparecer\u00e1 un objeto Motor, y Motor no tendr\u00e1 una existencia propia.</li> <li>Bidireccional \u2192 Son relaciones en las que los elementos relacionados suelen tener el mismo peso o entidad. Por ejemplo, un Grupo de un instituto y un Tutor. Desde un grupo tiene sentido conocer al tutor, y tambi\u00e9n podemos desde un profesor (el tutor) acceder al grupo que tutoriza. En este caso, dentro del objeto Grupo tenemos una referencia al objeto Tutor y viceversa.</li> </ul> <p>Aviso</p> <p>En este tipo de referencias, como puede deducirse, existe una recursi\u00f3n intr\u00ednseca. Por tanto, cuando gestionamos este tipo de relaciones bidireccionales, tenga mucho cuidado de no causar bucles, ya que incluso algo tan sencillo como imprimir puede hacer que nuestro programa se bloquee y aparezca la conocida <code>StackOverflowException</code>.</p> <p>A partir de ahora podr\u00edamos estudiar todas las representaciones con JPA.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#41-relaciones-uno-a-uno","title":"4.1. Relaciones Uno a Uno","text":"<p>Para la explicaci\u00f3n de los ejemplos, veremos el dise\u00f1o y la implementaci\u00f3n en la base de datos de cada caso y c\u00f3mo se ve en Hibernate. Para este ejemplo representaremos una relaci\u00f3n 1:1 entre Grupo y Profesor, donde puede verse que un Grupo tiene un Tutor, y un Tutor s\u00f3lo puede tutorizar un Grupo.</p> one to one <p>En primer lugar, la clase que es apuntada por la clave for\u00e1nea. Muy f\u00e1cil porque no necesitamos hacer nada.</p> <pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n@Entity\n@Table(name=\"Profesor\")\npublic class Profesor implements Serializable {\n\n    static final long serialVersionUID = 1L;\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private int idProfesor;\n\n    @Column\n    private String nombre;\n\n    public Profesor(String nombre) {\n        this.nombre = nombre;\n    }\n}\n</code></pre> <p>Y ahora, la clase que contiene la clave ajena. Aqu\u00ed debemos marcar que un <code>Grupo</code> necesita un <code>Profesor</code> como tutor. Ve\u00e1moslo:</p> <p><pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Grupo\")\npublic class Grupo implements Serializable {\n\n    static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long idGrupo;\n\n    @Column\n    private String nivel;\n\n    @Column\n    private String curso;\n\n    @Column\n    private int anyo;\n\n    @OneToOne(cascade = CascadeType.ALL)\n    @JoinColumn(\n            name=\"id_tutor\",\n            referencedColumnName = \"idProfesor\",\n            unique=true,\n            foreignKey = @ForeignKey(name = \"FK_GRP_TEACH\"))\n    private Profesor tutor;\n\n    public Grupo(String nivel, String curso, int anyo) {\n        this.nivel = nivel;\n        this.curso = curso;\n        this.anyo = anyo;\n    }\n\n}\n</code></pre> Tenga en cuenta que la clase <code>Grupo</code> contiene un campo llamado <code>tutor</code> de la clase <code>Profesor</code>, y:</p> <ul> <li><code>@OneToOne(cascade = CascadeType.ALL)</code> marcamos esta relaci\u00f3n como 1:1. Adem\u00e1s, especificamos el atributo cascada, que es el m\u00e1s importante. El cascading es la forma de decir que cuando realizamos alguna acci\u00f3n sobre la entidad objetivo (<code>Grupo</code>), la misma acci\u00f3n se aplicar\u00e1 a la entidad asociada (<code>Profesor</code>). Revisamos las opciones m\u00e1s relevantes: </li> <li><code>CascadeType.ALL</code> propaga todas las operaciones. La misma operaci\u00f3n que realizamos en el objetivo se realizar\u00e1 en el asociado. </li> <li><code>CascadeType.PERSIST</code> propaga s\u00f3lo la operaci\u00f3n de persistencia en la base de datos (guardar). </li> <li><code>CascadeType.SAVE_UPDATE</code> es de Hibernate, no de JPA, y propaga el m\u00e9todo <code>saveOrUpdate()</code>. Es muy similar a persisto. </li> <li><code>CascadeType.REMOVE</code> o <code>CascadeType.DELETE</code> propaga la eliminaci\u00f3n de entidades. Tenga mucho cuidado con esta opci\u00f3n para evitar perder datos.</li> <li>En el <code>@JoinColumn</code> establecemos: </li> <li>el nombre de la columna en nuestra base de datos </li> <li>el nombre de la columna referenciada en la entidad objetivo <code>Profesor</code> </li> <li><code>unique=true</code> para asegurar que la relaci\u00f3n es 1:1 (un profesor no puede estar relacionado con ning\u00fan otro grupo) </li> <li>[opcional] para establecer el nombre de la restricci\u00f3n de clave for\u00e1nea, en caso de que desee cambiarlo o eliminarlo en operaciones futuras.</li> </ul> <p>M\u00e1s informaci\u00f3n en la siguiente webbaeldung</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#411-uno-a-uno-bidireccional","title":"4.1.1. Uno a Uno bidireccional","text":"<p>Si queremos almacenar en Profesor los grupos que est\u00e1 tutorizando, necesitamos a\u00f1adir una referencia al Grupo. Como hemos hecho la clave for\u00e1nea en Grupo, ser\u00e1 muy f\u00e1cil:</p> <pre><code>@OneToOne(mappedBy= \"tutor\")\nprivate Grupo elGrupo;\n</code></pre> <p>Con <code>mappedBy=\"tutor\"</code> estamos diciendo que en la clase <code>Grupo</code> existe un campo llamado <code>tutor</code> con toda la informaci\u00f3n sobre la relaci\u00f3n. Tenga en cuenta que no se a\u00f1adir\u00e1n campos aadicionales a <code>Profesor</code>, porque la informaci\u00f3n sobre la relaci\u00f3n se encuentra en la tabla <code>Grupo</code>.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#42-uno-a-muchos","title":"4.2. Uno a Muchos","text":"<p>Para esta explicaci\u00f3n empezaremos con el siguiente modelo, en el que un Libro tiene un Autor que lo ha escrito, y un Autor puede haber escrito varios Libros. En el esquema relacional, la relaci\u00f3n es desde <code>idAutor</code> en Libros, que es clave for\u00e1nea en la tabla Autor (ID).</p> one to many <p>Primero, podemos decidir qui\u00e9n es el propietario de la relaci\u00f3n. Realmente no importa, pero en varios dise\u00f1os es muy claro, por ejemplo entre <code>Estudiante</code> y <code>Email</code>, donde obviamente el propietario es <code>Estudiante</code>. Normalmente deber\u00eda ser la clase con cardinalidad muchos el propietario. Veamos el ejemplo.</p> <p><pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@NoArgsConstructor\n\n@Entity\n@Table(name=\"libro\")\npublic class Libro implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idlibro;\n\n    @Column\n    private String titulo;\n\n    @Column\n    private String tipo;\n\n    @ManyToOne(cascade = CascadeType.PERSIST)\n    @JoinColumn(name = \"idautor\",\n            foreignKey = @ForeignKey(name = \"FK_LIB_AUT\"))\n    private Autor elAutor;\n\n    public Libro(String titulo, String tipo, Autor elAutor) {\n        this.titulo = titulo;\n        this.tipo = tipo;\n        this.elAutor = elAutor;\n    }\n}\n</code></pre> En este ejemplo, un <code>Libro</code> tiene un autor (\u00fanico). Lo implementamos almacenando una referencia a un objeto Autor, llamado <code>elAutor</code> dentro de nuestro Libro. Debemos escribir la informaci\u00f3n de la relaci\u00f3n en este campo:</p> <ul> <li>Debemos marcar este campo como <code>@ManyToOne</code>, porque Libro est\u00e1 al lado de los muchos de la relaci\u00f3n (recuerde que un Autor puede escribir varios Libros)</li> <li>La clave for\u00e1nea ser\u00e1 anotada con la etiqueta <code>@JoinColumn</code>, con varios atributos: </li> <li>Puesto que <code>elAutor</code> es el punto inicial de la clave for\u00e1nea, que apunta a la tabla <code>Autor</code>, necesitamos decir el nombre de la clave primaria en esta clase. Este atributo es opcional pero es una buena opci\u00f3n para mejorar nuestro c\u00f3digo. </li> <li>Opcionalmente, podemos llamar la restricci\u00f3n de la clave for\u00e1nea, con un nombre bien estructurado, con el atributo <code>foreignKey</code></li> </ul> <pre><code>import jakarta.persistence.*;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.util.Set;\n@Data\n@NoArgsConstructor\n@Entity\n@Table(name=\"autor\")\npublic class Autor implements Serializable{\n\n    @Serial\n    private static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private Long idautor;\n\n    @Column\n    private String nombre;\n\n    @Column\n    private String nacionalidad;\n\n    @OneToMany(mappedBy=\"elAutor\",\n            cascade=CascadeType.PERSIST,\n            fetch = FetchType.LAZY)\n    private Set&lt;Libro&gt; losLibros;\n\n    public Autor(String nombre, String nacionalidad, Set&lt;Libro&gt; losLibros) {\n        this.nombre = nombre;\n        this.nacionalidad = nacionalidad;\n        this.losLibros = losLibros;\n    }\n}\n</code></pre> <p>La clase <code>Autor</code> est\u00e1 en el lado un, y esto significa que puede escribir muchos <code>Libros</code>. Por esta raz\u00f3n, almacenamos todos los libros que ha escrito en un 'Set' de libros. Las anotaciones ser\u00e1n:</p> <ul> <li>Puesto que un Autor puede escribir muchos libros, marcamos el Set de libros como <code>@OneToMany</code>. Como hemos escrito la especificaci\u00f3n de la relaci\u00f3n en Libro, podr\u00edamos decir que la relaci\u00f3n est\u00e1 mapeada en el campo <code>elAutor</code> dentro de la clase <code>Libro</code>, con <code>mappedBy=\"elAutor\"</code> f\u00e1cilmente.</li> </ul> <p>Decisi\u00f3n</p> <p>En lugar de almacenar libros en un Set, se pueden almacenar en una Lista. La principal diferencia es responder a esta pregunta: \u00bfes importante el orden?. Si respondes s\u00ed, debes utilizar una Lista. Si la respuesta es no, debes utilizar un Set.</p> <p>Espacio</p> <p>La relaci\u00f3n <code>1:N</code> que hemos explicado es bidireccional. Esto significa que desde un Autor podemos obtener todos los Libros que ha escrito, y desde un Libro podemos obtener el Autor. </p> one to many bidirectional <p>Puede encontrar varias p\u00e1ginas y libros que explican las relaciones unidireccionales <code>1:N</code>. Esto significa que con este tipo de implementaci\u00f3n s\u00f3lo podemos viajar en una direcci\u00f3n. En este caso, debemos almacenar s\u00f3lo dentro de un Libro quien es el autor, porque el Libro es el propietario. Debemos eliminar el conjunto de libros en el autor para obtener una relaci\u00f3n unidireccional.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#421-tipo-de-carga-fetch","title":"4.2.1. Tipo de Carga Fetch","text":"<p>Este atributo suele aparecer cuando tenemos una relaci\u00f3n <code>1:N</code> o <code>N:M</code> en una clase que tiene una colecci\u00f3n de clases relacionadas (tambi\u00e9n puede especificarse con un <code>1:1</code> pero es menos com\u00fan). Cuando Hibernate carga un objeto, cargar\u00e1 sus atributos generales (nombre, nacionalidad, etc...), pero \u00bfqu\u00e9 ocurre con los Libros que ha escrito, los carga o no?</p> <ul> <li><code>FetchType.EAGER</code> \u2192 Literalmente traducido como ansioso. No podemos esperar, y cuando se carga al Autor, Hibernate resolver\u00e1 la relaci\u00f3n y cargar\u00e1 todos los libros con todos los datos internos de cada libro. Tenemos todos los datos en el momento.</li> <li><code>FetchType.LAZY</code> \u2192 Literalmente como perezoso (vago), pero m\u00e1s representativo como carga perezosa. Si cargamos al Autor, Hibernate s\u00f3lo carga los atributos propios del Autor, sin cargar sus Libros. Cuando intentamos acceder a sus libros desde nuestro programa, Hibernate se activa y los carga. Es decir, en modo LAZY, los datos se cargan cuando se necesitan.</li> </ul> <p>\u00bfQu\u00e9 haremos?</p> <p>\u00bfQu\u00e9 es mejor o peor? La respuesta no es sencilla, ya queAmbos tienen ventajas y desventajas:</p> <ul> <li> <p>En <code>EAGER</code> solo se realiza un acceso, mientras que en <code>LAZY</code> se realizan dos o m\u00e1s.</p> </li> <li> <p>En <code>EAGER</code> se cargan todos los datos, incluso los innecesarios; en <code>LAZY</code> solo se carga lo necesario.</p> </li> </ul> <p>El programador debe evaluar y equilibrar la cantidad de informaci\u00f3n requerida en un momento dado y el coste de acceso a la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#43-muchos-a-muchos","title":"4.3. Muchos a Muchos","text":"<p>En esta secci\u00f3n, finalizaremos con el \u00faltimo tipo de relaci\u00f3n que podemos encontrar en el modelo E/R: las relaciones muchos a muchos. Pueden aparecer otras relaciones con cardinalidades m\u00e1s altas, como las relaciones ternarias, pero, como se estudi\u00f3 en el primer a\u00f1o, todas ellas pueden modelarse con transformaciones binarias.</p> <p>Dentro de las relaciones binarias, podemos encontrar dos posibilidades:</p> <ul> <li> <p>Relaciones que simplemente indican la relaci\u00f3n (por ejemplo, que un personaje puede o no portar cierto tipo de arma en un juego de rol) o</p> </li> <li> <p>Relaciones que, adem\u00e1s de indicarla, a\u00f1aden nuevos atributos. Por ejemplo, un actor participa en una pel\u00edcula interpretando un tipo de papel: principal, secundario, etc.</p> </li> </ul> <p>En el modelo relacional, ambos casos se modelan como una nueva tabla (con o sin el atributo). Si nos encontramos en el segundo caso, se debe modelar una nueva tabla con los atributos que posee mediante una clase, por lo que la relaci\u00f3n \u00abN:M\u00bb entre dos tablas se convertir\u00e1 en \u00abdos relaciones uno a muchos 1:N y N:1\u00bb (actor-actuaci\u00f3n y actuaci\u00f3n-pel\u00edcula). Nos centraremos en el primer caso, ya que estamos listos para resolver el segundo.</p> <p>Mejora</p> <p>En la segunda parte, este tutorial explica c\u00f3mo crear N_M con atributos. Se recomienda implementar un ejemplo.</p> <p>Modelemos el caso t\u00edpico de un profesor que imparte varios m\u00f3dulos, que pueden ser impartidos por varios profesores. El esquema es el siguiente:</p> one to many bidirectional"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#431-muchos-a-muchos-con-4-clases","title":"4.3.1 Muchos a Muchos con 4 clases","text":"<p>Como podemos ver, se mantiene la tabla central t\u00edpica de la relaci\u00f3n <code>N:M</code>. Para implementar este caso vamos a necesitar 4 clase que se podr\u00e1n ver ahora:</p> <p>Las clases M\u00f3dulo y Profesor son las siguientes:</p> <p><pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Profesor\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Profesor {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idProfesor\")\n    private Long idProfesor;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @OneToMany(mappedBy = \"profesor\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;Docencia&gt; docencias = new ArrayList&lt;&gt;();\n}\n</code></pre> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Modulo\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Modulo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idModulo\")\n    private Long idModulo;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @OneToMany(mappedBy = \"modulo\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;Docencia&gt; docencias = new ArrayList&lt;&gt;();\n\n}\n</code></pre></p> <p>Esta es la especificaci\u00f3n m\u00e1s compleja, vamos:</p> <ul> <li>En ambas clases, la asignaci\u00f3n es <code>@OneToMany</code></li> <li>En ambos casos, indicamos c\u00f3mo gestionamos las operaciones en cascada (<code>cascade</code>) y la carga de objetos relacionados desde la otra clase (<code>fetch</code>).</li> <li>En la clase propietaria (<code>Profesor</code>), se asignar\u00e1 un <code>List&lt;Docencia&gt;</code> con la relaci\u00f3n que comenzar\u00e1 desde mi clase actual <code>Profesor</code> \u2192 <code>Docencia</code> \u2192 <code>Modulo</code> (el tipo base del Set).</li> </ul> <p>En este apartado como podemos ver s\u00f3lo hemos mapeado 2 entidades, Profesor y M\u00f3dulo. Estas se encuetran relacionadas por la tabla docencia. Puesto que esta tabla docencia no tiene m\u00e1s atributos, podr\u00edamos prescindir de crear una clase llamada <code>Docencia</code> de tal manera que mapearamos directamente. En este apartado vamos a ver con 4 clases y entender el motivo de realizar esta implementaci\u00f3n.</p> <p>Clase <code>DocenciaId</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Embeddable;\nimport java.io.Serializable;\nimport java.util.Objects;\n\n@Embeddable\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class DocenciaId implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @Column(name = \"idProfesor\")\n    private Long idProfesor;\n\n    @Column(name = \"idModulo\")\n    private Long idModulo;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DocenciaId that = (DocenciaId) o;\n        return Objects.equals(idProfesor, that.idProfesor) &amp;&amp;\n                Objects.equals(idModulo, that.idModulo);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(idProfesor, idModulo);\n    }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 necesitamos la clase DocenciaId?</p> <ul> <li>Porque la tabla Docencia tiene dos atributos como clave que son claves ajenas a su vez.</li> <li>JPA requiere que las claves primarias compuestas se representen como una clase separada que implemente Serializable.</li> <li><code>@Embeddable</code>marca una clase cuyas instancias se almacenan como parte de una entidad due\u00f1a, en lugar de tener su propia identidad en la base de datos.</li> </ul> <p>Una vez se dispone de la clase <code>DocenciaId</code>implementaremos la clase <code>Docencia</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\n\nimport jakarta.persistence.*;\n\n@Entity\n@Table(name = \"Docencia\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Docencia {\n\n    @EmbeddedId\n    private DocenciaId id;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @MapsId(\"idProfesor\")\n    @JoinColumn(name = \"idProfesor\")\n    private Profesor profesor;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @MapsId(\"idModulo\")\n    @JoinColumn(name = \"idModulo\")\n    private Modulo modulo;\n}\n</code></pre> <p>Info</p> <ul> <li><code>@EmbeddedId</code> A trav\u00e9s de este decorador indicamos la uniciddad de la clave primaria. Es m\u00e1s apto para consultas con JPL.</li> <li><code>@MapsId</code> se usa para indicar que una relaci\u00f3n JPA comparte la clave primaria con la entidad due\u00f1a. Espec\u00edficamente, mapea una relaci\u00f3n <code>@ManyToOne</code> o <code>@OneToOne</code> para que use la misma columna que forma parte de la clave primaria embebida.</li> </ul> <p>Este ser\u00eda un ejemplo de programa principal</p> <pre><code>import modelo.*;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.EntityTransaction;\nimport jakarta.persistence.Persistence;\nimport java.time.LocalDateTime;\n\npublic class Main{\n\n    public static void main(String[] args) {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"DocenciaConsultasPU\");\n        EntityManager em = emf.createEntityManager();\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n            tx.begin();\n\n            // Crear un nuevo profesor y asignarle m\u00faltiples m\u00f3dulos\n            Profesor nuevoProfesor = new Profesor();\n            nuevoProfesor.setNombre(\"Jose Manuel Romero\");\n            em.persist(nuevoProfesor);\n\n            // Asignar m\u00f3dulos al nuevo profesor\n            Modulo modulo1 = em.find(Modulo.class, 3L); // EIE\n            Modulo modulo2 = em.find(Modulo.class, 6L); // ACD\n\n\n\n            // Primera asignaci\u00f3n\n            Docencia docencia1 = new Docencia();\n            docencia1.setId(new DocenciaId(nuevoProfesor.getIdProfesor(), modulo1.getIdModulo()));\n            docencia1.setProfesor(nuevoProfesor);\n            docencia1.setModulo(modulo1);\n            em.persist(docencia1);\n\n            // Segunda asignaci\u00f3n\n            Docencia docencia2 = new Docencia();\n            docencia2.setId(new DocenciaId(nuevoProfesor.getIdProfesor(), modulo2.getIdModulo()));\n            docencia2.setProfesor(nuevoProfesor);\n            docencia2.setModulo(modulo2);\n            em.persist(docencia2);\n\n//            // Crear un nuevo alumno y agregarle ex\u00e1menes\n//            Alumno nuevoAlumno = new Alumno();\n//            nuevoAlumno.setNombre(\"Marta\");\n//            nuevoAlumno.setApellidos(\"Rodriguez Santos\");\n//            nuevoAlumno.setEdad(23);\n//            nuevoAlumno.setRepetidor(true);\n//            em.persist(nuevoAlumno);\n//\n//            // Agregar ex\u00e1menes al alumno\n//            Examen examen1 = new Examen();\n//            examen1.setFecha(LocalDateTime.of(2024, 1, 15, 10, 0));\n//            examen1.setNota(7.0);\n//            examen1.setAlumno(nuevoAlumno);\n//            examen1.setModulo(modulo1);\n//            em.persist(examen1);\n//\n//            Examen examen2 = new Examen();\n//            examen2.setFecha(LocalDateTime.of(2024, 1, 20, 9, 0));\n//            examen2.setNota(5.5);\n//            examen2.setAlumno(nuevoAlumno);\n//            examen2.setModulo(modulo2);\n//            em.persist(examen2);\n\n            tx.commit();\n            System.out.println(\"Inserci\u00f3n compleja completada:\");\n            System.out.println(\"- Profesor: \" + nuevoProfesor.getNombre() + \" (ID: \" + nuevoProfesor.getIdProfesor() + \")\");\n//            System.out.println(\"- Alumno: \" + nuevoAlumno.getNombre() + \" \" + nuevoAlumno.getApellidos());\n//            System.out.println(\"- M\u00f3dulos asignados: \" + modulo1.getNombre() + \", \" + modulo2.getNombre());\n//            System.out.println(\"- Ex\u00e1menes creados: 2\");\n\n        } catch (Exception e) {\n            if (tx.isActive()) {\n                tx.rollback();\n            }\n            e.printStackTrace();\n        } finally {\n            em.close();\n            emf.close();\n        }\n    }\n}\n</code></pre> <p>Puedes acceder a este proyecto desde aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#432-muchos-a-muchos-con-2-clases","title":"4.3.2 Muchos a Muchos con 2 clases","text":"<p>La diferencia con respecto al m\u00e9todo anterior es a nivel del clases y fichero <code>persistence.xml</code> en el cual se omitir\u00e1n las clases de las que no se hace uso, <code>Docencia</code> y <code>DocenciaId</code></p> <p>Clase <code>Modulo</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Modulo\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Modulo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idModulo\")\n    private Long idModulo;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @ManyToMany(mappedBy = \"modulos\")\n    private List&lt;Profesor&gt; profesores = new ArrayList&lt;&gt;();\n\n    @OneToMany(mappedBy = \"modulo\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;Examen&gt; examenes = new ArrayList&lt;&gt;();\n    @Override\n    public String toString() {\n        return \"Modulo{\" +\n                \"idModulo=\" + idModulo +\n                \", nombre='\" + nombre + '\\'' +\n                \", profesoresCount=\" + (profesores != null ? profesores.size() : 0) +\n                '}';\n    }\n}\n</code></pre> <p>Detalle de la clase Modulo</p> <ul> <li><code>@ManyToMany(mappedBy = \"modulos\")</code> <ul> <li><code>@ManyToMany</code>: Indica una relaci\u00f3n muchos-a-muchos entre <code>Modulo</code> y <code>Profesor</code></li> <li><code>mappedBy = \"modulos\"</code>: Esta entidad es el lado inverso de la relaci\u00f3n<ul> <li>El due\u00f1o de la relaci\u00f3n est\u00e1 en la clase <code>Profesor</code>, campo <code>modulos</code></li> <li>Esta clase es el lado esclavo/pasivo</li> </ul> </li> </ul> </li> <li>Responsabilidades:<ul> <li>NO crea la tabla intermedia (ya la crea el lado due\u00f1o)</li> <li>NO define <code>@JoinTable</code> (eso lo hace el lado due\u00f1o)</li> <li>Solo refleja la relaci\u00f3n que ya existe del otro lado</li> </ul> </li> </ul> <p>Clase <code>Profesor</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Profesor\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Profesor {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"idProfesor\")\n    private Long idProfesor;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n\n    @ManyToMany\n    @JoinTable(\n            name = \"Docencia\",\n            joinColumns = @JoinColumn(name = \"idProfesor\"),\n            inverseJoinColumns = @JoinColumn(name = \"idModulo\")\n    )\n    private List&lt;Modulo&gt; modulos = new ArrayList&lt;&gt;();\n\n    @Override\n    public String toString() {\n        return \"Profesor{\" +\n                \"idProfesor=\" + idProfesor +\n                \", nombre='\" + nombre + '\\'' +\n                \", modulosCount=\" + (modulos != null ? modulos.size() : 0) +\n                '}';\n    }\n}\n</code></pre> <p>Detalle de la clase Profesor</p> <ul> <li><code>@JoinTable</code> en el lado due\u00f1o <ul> <li><code>name = \"Docencia\"</code>: Nombre de la tabla intermedia en la BD</li> <li><code>joinColumns = @JoinColumn(name = \"idProfesor\")</code>:<ul> <li>Columna que referencia al due\u00f1o de la relaci\u00f3n (Profesor)</li> </ul> </li> <li><code>inverseJoinColumns = @JoinColumn(name = \"idModulo\")</code>:<ul> <li>Columna que referencia al otro lado de la relaci\u00f3n (Modulo)</li> </ul> </li> </ul> </li> </ul>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#relaciones-manytomany-lado-dueno-vs-lado-inverso","title":"Relaciones ManyToMany: Lado Due\u00f1o vs Lado Inverso","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#diferencias-entre-lado-dueno-y-lado-inverso","title":"Diferencias entre lado due\u00f1o y lado inverso","text":"Aspecto Lado Due\u00f1o (Profesor) Lado Inverso (Modulo) Anotaci\u00f3n <code>@ManyToMany</code> + <code>@JoinTable</code> <code>@ManyToMany(mappedBy)</code> Responsable Crea/define la tabla intermedia Solo refleja la relaci\u00f3n Persistencia Los cambios se persisten desde aqu\u00ed Los cambios NO se persisten directamente Consultas Puede hacer operaciones de join Opera a trav\u00e9s del lado due\u00f1o"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#estructura-de-la-tabla-docencia","title":"Estructura de la tabla <code>Docencia</code>","text":"<p>La configuraci\u00f3n con <code>@JoinTable</code> crea exactamente esta estructura en la base de datos:</p> <pre><code>CREATE TABLE Docencia (\n    idProfesor BIGINT,  -- FK a Profesor (joinColumns)\n    idModulo   BIGINT,  -- FK a Modulo (inverseJoinColumns)\n    PRIMARY KEY (idProfesor, idModulo)\n);\n</code></pre> <p>\u200b   </p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#ejemplo-practico-de-uso","title":"Ejemplo pr\u00e1ctico de uso","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#persistencia-siempre-desde-el-lado-dueno","title":"Persistencia (siempre desde el lado due\u00f1o)","text":"<pre><code>// CORRECTO - Desde el lado due\u00f1o\nProfesor profesor = new Profesor();\nModulo modulo = new Modulo();\nprofesor.getModulos().add(modulo);  // \u2190 Cambio en el lado due\u00f1o\nem.persist(profesor);\n\n// INCORRECTO - Desde el lado inverso  \nModulo modulo = new Modulo();\nProfesor profesor = new Profesor();\nmodulo.getProfesores().add(profesor);  // \u2190 NO se persistir\u00e1\nem.persist(modulo);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#consultas-funcionan-en-ambos-lados","title":"Consultas (funcionan en ambos lados)","text":"<pre><code>// Desde Profesor (lado due\u00f1o)\nProfesor p = em.find(Profesor.class, 1L);\nList&lt;Modulo&gt; modulos = p.getModulos();  // \u2190 Funciona\n\n// Desde Modulo (lado inverso)  \nModulo m = em.find(Modulo.class, 1L);\nList&lt;Profesor&gt; profesores = m.getProfesores();  // \u2190 Tambi\u00e9n funciona\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#reglas-importantes","title":"Reglas importantes","text":"<ol> <li>Solo un lado puede ser el due\u00f1o en relaciones bidireccionales</li> <li><code>mappedBy</code> siempre va en el lado inverso</li> <li>La persistencia debe hacerse desde el lado due\u00f1o</li> <li>Las consultas funcionan en ambos lados una vez persistido</li> <li>La tabla intermedia se maneja autom\u00e1ticamente por JPA</li> </ol> <p>M\u00e9todo <code>Main</code></p> <p><pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.EntityTransaction;\nimport jakarta.persistence.Persistence;\nimport modelo.Modulo;\nimport modelo.Profesor;\n\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"DocenciaConsultasPU\");\n        EntityManager em = emf.createEntityManager();\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n\n            tx.begin();\n\n            // Crear entidades\n            Profesor profesor = new Profesor();\n            profesor.setNombre(\"Mariano Faus Perez\");\n\n            Modulo modulo = new Modulo();\n            modulo.setNombre(\"BBDD\");\n\n            // Establecer relaci\u00f3n desde el LADO DUE\u00d1O\n            profesor.getModulos().add(modulo);\n\n            // Persistir\n            em.persist(profesor);\n            em.persist(modulo);\n\n            tx.commit();\n\n            // Consultar desde cualquier lado\n            List&lt;Modulo&gt; modulosDelProfesor = profesor.getModulos();  // \u2713 Funciona\n            List&lt;Profesor&gt; profesoresDelModulo = modulo.getProfesores();  // x No funciona porque no se sincroniza\n            System.out.println(\"Los modulos son:\");\n            modulosDelProfesor.forEach(System.out::println);\n            // No mostrara los profesores\n            System.out.println(\"Los profesores son:\");\n            profesoresDelModulo.forEach(System.out::println);\n        } catch (Exception e) {\n            if (tx.isActive()) {\n                tx.rollback();\n            }\n            e.printStackTrace();\n        } finally {\n            em.close();\n            emf.close();\n        }\n    }\n}\n</code></pre> Si lo ejecutamos vamos a ver que no muestra los profesores. El problema es que cuando persistes desde el lado due\u00f1o (Profesor), JPA no actualiza autom\u00e1ticamente el lado inverso (Modulo). Necesitas mantener sincronizadas ambas partes manualmente.</p> <p>Para ello vamos a definir un par de m\u00e9todos en cada una de las clases que nos permitir\u00e1n persistir los datos, de los cuales haremos uso:</p> <p>Clase <code>Modulo</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Modulo\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Modulo {\n\n....\n\n    public void anyadirProfesor(Profesor profesor) {\n        if (profesor != null) {\n            this.profesores.add(profesor);\n            profesor.getModulos().add(this); // Sincroniza el lado due\u00f1o\n        }\n    }\n\n    public void eliminarProfesor(Profesor profesor) {\n        if (profesor != null) {\n            this.profesores.remove(profesor);\n            profesor.getModulos().remove(this); // Sincroniza el lado due\u00f1o\n        }\n    }\n}\n</code></pre> <p>Clase <code>Profesor</code></p> <pre><code>package modelo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport jakarta.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"Profesor\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Profesor {\n\n...\n\n    public void anyadirModulo(Modulo modulo) {\n        if (modulo != null) {\n            this.modulos.add(modulo);\n            modulo.getProfesores().add(this); // Sincroniza el lado inverso\n        }\n    }\n\n    public void eliminarModulo(Modulo modulo) {\n        if (modulo != null) {\n            this.modulos.remove(modulo);\n            modulo.getProfesores().remove(this); // Sincroniza el lado inverso\n        }\n    }\n}\n</code></pre> <p>Ahora vamos a ver cuando usar <code>persist</code>o cuando usar <code>merge</code></p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#ejemplo-completo-de-persist-y-merge-en-main","title":"Ejemplo completo de <code>persist()</code> y <code>merge()</code> en Main","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#codigo-completo-para-tu-proyecto","title":"C\u00f3digo completo para tu proyecto","text":"<pre><code>import jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityManagerFactory;\nimport jakarta.persistence.EntityTransaction;\nimport jakarta.persistence.Persistence;\nimport modelo.Profesor;\nimport modelo.Modulo;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"DocenciaConsultasPU\");\n        EntityManager em = emf.createEntityManager();\n\n        try {\n            System.out.println(\"=== INICIO DEMOSTRACI\u00d3N PERSIST vs MERGE ===\\n\");\n\n            // Primero: mostrar estado actual\n            mostrarEstadoActual(em);\n\n            // Ejemplo 1: Crear nuevas entidades con PERSIST\n            Persist(em);\n\n            // Ejemplo 2: Modificar entidades existentes (evitando duplicados)\n            ModificacionManaged(em);\n\n            // Ejemplo 3: Usar MERGE con entidades detached\n            MergeDetached(em);\n\n            // Ejemplo 4: Consultas finales\n            mostrarEstadoFinal(em);\n\n            System.out.println(\"\\n=== FIN DEMOSTRACI\u00d3N ===\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error durante la demostraci\u00f3n: \" + e.getMessage());\n            e.printStackTrace();\n        } finally {\n            em.close();\n            emf.close();\n        }\n    }\n\n    /**\n     * Mostrar estado actual de las relaciones\n     */\n    private static void mostrarEstadoActual(EntityManager em) {\n        System.out.println(\" ESTADO ACTUAL DE LA BASE DE DATOS\");\n\n        EntityTransaction tx = em.getTransaction();\n        try {\n            tx.begin();\n\n            // Consultar todos los profesores y sus m\u00f3dulos\n            List&lt;Profesor&gt; profesores = em.createQuery(\"SELECT p FROM Profesor p\", Profesor.class).getResultList();\n\n            for (Profesor profesor : profesores) {\n                System.out.println(profesor.getNombre() + \" (ID: \" + profesor.getIdProfesor() + \")\");\n                System.out.println(\"M\u00f3dulos asignados:\");\n                if (profesor.getModulos().isEmpty()) {\n                    System.out.println(\"- Ninguno\");\n                } else {\n                    profesor.getModulos().forEach(modulo -&gt;\n                            System.out.println(\"      - \" + modulo.getNombre() + \" (ID: \" + modulo.getIdModulo() + \")\")\n                    );\n                }\n                System.out.println();\n            }\n\n            tx.commit();\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * EJEMPLO 1: PERSIST - Para entidades NUEVAS que no existen en la BD\n     */\n    private static void Persist(EntityManager em) {\n        System.out.println(\"1. USO DE PERSIST() - CREAR NUEVAS ENTIDADES\");\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n            tx.begin();\n\n            // Crear un nuevo profesor (entidad NUEVA)\n            Profesor nuevoProfesor = new Profesor();\n            nuevoProfesor.setNombre(\"Carlos Mart\u00ednez\");\n\n            // Crear un nuevo m\u00f3dulo (entidad NUEVA)\n            Modulo nuevoModulo = new Modulo();\n            nuevoModulo.setNombre(\"Blockchain\");\n\n            // USO CORRECTO DE PERSIST: para entidades NUEVAS\n            em.persist(nuevoProfesor);\n            em.persist(nuevoModulo);\n\n            // Crear relaci\u00f3n entre ellos\n            nuevoProfesor.anyadirModulo(nuevoModulo);\n\n            tx.commit();\n\n            System.out.println(\"   PERSIST exitoso:\");\n            System.out.println(\"      - Nuevo Profesor: \" + nuevoProfesor.getNombre() + \" (ID: \" + nuevoProfesor.getIdProfesor() + \")\");\n            System.out.println(\"      - Nuevo M\u00f3dulo: \" + nuevoModulo.getNombre() + \" (ID: \" + nuevoModulo.getIdModulo() + \")\");\n            System.out.println(\"      - Relaci\u00f3n establecida correctamente\\n\");\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * EJEMPLO 2: Modificaci\u00f3n de entidades MANAGED (EVITANDO DUPLICADOS)\n     */\n    private static void ModificacionManaged(EntityManager em) {\n        System.out.println(\"2. MODIFICACI\u00d3N DE ENTIDADES MANAGED (SIN DUPLICADOS)\");\n        EntityTransaction tx = em.getTransaction();\n\n        try {\n            tx.begin();\n\n            // Obtener entidades EXISTENTES\n            Profesor profesor = em.find(Profesor.class, 1L); // Mariano Faus\n            // Buscar un m\u00f3dulo que NO est\u00e9 asignado a este profesor\n            Modulo moduloNoAsignado = encontrarModuloNoAsignado(em, profesor);\n\n            if (profesor != null &amp;&amp; moduloNoAsignado != null) {\n                // Modificar propiedades\n                String nombreOriginal = profesor.getNombre();\n                if (!nombreOriginal.contains(\"[Actualizado]\")) {\n                    profesor.setNombre(nombreOriginal + \" [Actualizado]\");\n                }\n\n                // Establecer relaci\u00f3n SOLO si no existe\n                if (!existeRelacion(profesor, moduloNoAsignado)) {\n                    profesor.anyadirModulo(moduloNoAsignado);\n\n                    tx.commit();\n\n                    System.out.println(\"   Modificaci\u00f3n exitosa:\");\n                    System.out.println(\"      - Profesor: \" + profesor.getNombre());\n                    System.out.println(\"      - Nuevo m\u00f3dulo agregado: \" + moduloNoAsignado.getNombre());\n                    System.out.println(\"      - No se necesit\u00f3 merge()\\n\");\n                } else {\n                    tx.rollback();\n                    System.out.println(\"     Relaci\u00f3n ya existe, no se realizaron cambios\\n\");\n                }\n            } else {\n                tx.rollback();\n                System.out.println(\"     No se encontraron entidades para modificar\\n\");\n            }\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * EJEMPLO 3: MERGE - Para entidades DETACHED (evitando duplicados)\n     */\n    private static void MergeDetached(EntityManager em) {\n        System.out.println(\"3.  USO DE MERGE() - ENTIDADES DETACHED\");\n\n        Profesor profesorDetached = null;\n\n        // Paso 1: Obtener entidad y cerrar transacci\u00f3n (se vuelve DETACHED)\n        EntityTransaction tx1 = em.getTransaction();\n        try {\n            tx1.begin();\n            profesorDetached = em.find(Profesor.class, 2L); // Anna Marto\n            tx1.commit();\n        } catch (Exception e) {\n            if (tx1.isActive()) tx1.rollback();\n            throw e;\n        }\n\n        // Ahora profesorDetached est\u00e1 DETACHED\n\n        EntityTransaction tx2 = em.getTransaction();\n        try {\n            tx2.begin();\n\n            // Buscar un m\u00f3dulo que NO est\u00e9 asignado a este profesor\n            Modulo moduloNoAsignado = encontrarModuloNoAsignado(em, profesorDetached);\n\n            if (moduloNoAsignado != null) {\n                // Modificar la entidad DETACHED\n                String nombreOriginal = profesorDetached.getNombre();\n                if (!nombreOriginal.contains(\"[Modificado]\")) {\n                    profesorDetached.setNombre(nombreOriginal + \" [Modificado]\");\n                }\n\n                // Agregar relaci\u00f3n SOLO si no existe\n                if (!existeRelacion(profesorDetached, moduloNoAsignado)) {\n                    profesorDetached.anyadirModulo(moduloNoAsignado);\n                }\n\n                // USO CORRECTO DE MERGE: para entidades DETACHED\n                Profesor profesorReattached = em.merge(profesorDetached);\n\n                tx2.commit();\n\n                System.out.println(\"   MERGE exitoso:\");\n                System.out.println(\"      - Entidad DETACHED modificada y reattached\");\n                System.out.println(\"      - Nuevo nombre: \" + profesorReattached.getNombre());\n                if (moduloNoAsignado != null) {\n                    System.out.println(\"      - Nuevo m\u00f3dulo: \" + moduloNoAsignado.getNombre() + \"\\n\");\n                }\n            } else {\n                tx2.rollback();\n                System.out.println(\"   No hay m\u00f3dulos disponibles para asignar\\n\");\n            }\n\n        } catch (Exception e) {\n            if (tx2.isActive()) tx2.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * Mostrar estado final\n     */\n    private static void mostrarEstadoFinal(EntityManager em) {\n        System.out.println(\"4. ESTADO FINAL DE LA BASE DE DATOS\");\n\n        EntityTransaction tx = em.getTransaction();\n        try {\n            tx.begin();\n\n            // Consultar todos los profesores y sus m\u00f3dulos\n            List&lt;Profesor&gt; profesores = em.createQuery(\"SELECT p FROM Profesor p\", Profesor.class).getResultList();\n\n            for (Profesor profesor : profesores) {\n                System.out.println( profesor.getNombre() + \" (ID: \" + profesor.getIdProfesor() + \")\");\n                System.out.println(\"   M\u00f3dulos asignados (\" + profesor.getModulos().size() + \"):\");\n                profesor.getModulos().forEach(modulo -&gt;\n                        System.out.println(\"      - \" + modulo.getNombre() + \" (ID: \" + modulo.getIdModulo() + \")\")\n                );\n                System.out.println();\n            }\n\n            tx.commit();\n\n        } catch (Exception e) {\n            if (tx.isActive()) tx.rollback();\n            throw e;\n        }\n    }\n\n    /**\n     * M\u00e9todo auxiliar: Encontrar un m\u00f3dulo NO asignado a un profesor\n     */\n    private static Modulo encontrarModuloNoAsignado(EntityManager em, Profesor profesor) {\n        try {\n            // Obtener todos los m\u00f3dulos\n            List&lt;Modulo&gt; todosModulos = em.createQuery(\"SELECT m FROM Modulo m\", Modulo.class).getResultList();\n\n            // Buscar un m\u00f3dulo que NO est\u00e9 en la lista del profesor\n            for (Modulo modulo : todosModulos) {\n                if (!existeRelacion(profesor, modulo)) {\n                    return modulo;\n                }\n            }\n\n            // Si todos est\u00e1n asignados, devolver null\n            return null;\n\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * M\u00e9todo auxiliar: Verificar si existe relaci\u00f3n entre profesor y m\u00f3dulo\n     */\n    private static boolean existeRelacion(Profesor profesor, Modulo modulo) {\n        return profesor.getModulos().stream()\n                .anyMatch(m -&gt; m.getIdModulo().equals(modulo.getIdModulo()));\n    }\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#dependencias-necesarias-en-tus-entidades","title":"Dependencias necesarias en tus entidades","text":"<p>Aseg\u00farate de que tus entidades tengan los m\u00e9todos helper:</p> <p>En Profesor.java:</p> <pre><code>public void anyadirModulo(Modulo modulo) {\n    if (modulo != null &amp;&amp; !this.modulos.contains(modulo)) {\n        this.modulos.add(modulo);\n        modulo.getProfesores().add(this); // Sincronizar lado inverso\n    }\n}\n\n    // M\u00e9todo para verificar si tiene un m\u00f3dulo\n    public boolean tieneModulo(Long idModulo) {\n        return this.modulos.stream()\n                .anyMatch(modulo -&gt; modulo.getIdModulo().equals(idModulo));\n    }\n</code></pre> <p>En Modulo.java:</p> <pre><code>public void anyadirProfesor(Profesor profesor) {\n    if (profesor != null &amp;&amp; !this.profesores.contains(profesor)) {\n        this.profesores.add(profesor);\n        profesor.getModulos().add(this); // Sincronizar lado due\u00f1o\n    }\n}\n</code></pre> <p>Este c\u00f3digo puedes agregarlo directamente a tu proyecto y ejecutarlo. Te mostrar\u00e1 ejemplos pr\u00e1cticos de cu\u00e1ndo usar <code>persist()</code> vs <code>merge()</code> con casos reales de tu base de datos.</p>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#explicacion-persist-vs-merge-en-jpa","title":"Explicaci\u00f3n: <code>persist()</code> vs <code>merge()</code> en JPA","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#conceptos-fundamentales","title":"Conceptos Fundamentales","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#estado-de-las-entidades-jpa","title":"Estado de las Entidades JPA","text":"Estado Descripci\u00f3n Contexto TRANSIENT Entidad nueva, no asociada a la BD Sin ID MANAGED Entidad gestionada por JPA En Persistence Context DETACHED Entidad desconectada Fuera del Persistence Context REMOVED Entidad marcada para eliminar En proceso de borrado"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#persist-para-entidades-nuevas","title":"PERSIST() - Para entidades NUEVAS","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#cuando-usar-persist","title":"\u00bfCu\u00e1ndo usar <code>persist()</code>?","text":"<pre><code>// \u2705 CASOS CORRECTOS para PERSIST:\n\n// 1. Entidad completamente nueva\nProfesor nuevo = new Profesor();\nnuevo.setNombre(\"Nuevo Profesor\");\nem.persist(nuevo); // \u2705\n\n// 2. Primera vez que se guarda en BD\nModulo modulo = new Modulo();\nmodulo.setNombre(\"Nuevo M\u00f3dulo\");\nem.persist(modulo); // \u2705\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#comportamiento-de-persist","title":"Comportamiento de <code>persist()</code>","text":"<ul> <li>Asigna ID autom\u00e1ticamente (si es <code>@GeneratedValue</code>)</li> <li>Convierte entidad TRANSIENT \u2192 MANAGED</li> <li>NO inmediato en BD (hasta commit/flush)</li> <li>Lanza excepci\u00f3n si la entidad ya existe</li> </ul>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#merge-para-entidades-existentes-o-detached","title":"MERGE() - Para entidades EXISTENTES o DETACHED","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#cuando-usar-merge","title":"\u00bfCu\u00e1ndo usar <code>merge()</code>?","text":"<p>java</p> <pre><code>// \u2705 CASOS CORRECTOS para MERGE:\n\n// 1. Entidades DETACHED (fuera del contexto)\nProfesor detached = obtenerProfesorDeServicioExterno();\ndetached.setNombre(\"Modificado\");\nem.merge(detached); // \u2705\n\n// 2. Entidades de otras capas/servicios\nProfesor profesor = servicioExterno.obtenerProfesor(1L);\nem.merge(profesor); // \u2705\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#comportamiento-de-merge","title":"Comportamiento de <code>merge()</code>","text":"<ul> <li>Devuelve copia MANAGED de la entidad</li> <li>Sincroniza cambios con la BD</li> <li>No modifica la entidad original (si es DETACHED)</li> <li>\u00datil en aplicaciones web/multicapa</li> </ul>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#casos-comunes-de-error","title":"CASOS COMUNES DE ERROR","text":""},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#error-1-usar-persist-en-entidades-existentes","title":"Error 1: Usar <code>persist()</code> en entidades existentes","text":"<p>java</p> <pre><code>Profesor existente = em.find(Profesor.class, 1L);\nem.persist(existente); // \u274c Lanza excepci\u00f3n!\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#error-2-usar-merge-innecesariamente","title":"Error 2: Usar <code>merge()</code> innecesariamente","text":"<p>java</p> <pre><code>Profesor managed = em.find(Profesor.class, 1L);\nmanaged.setNombre(\"Nuevo nombre\");\nem.merge(managed); // \u274c INNECESARIO - ya est\u00e1 MANAGED\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#error-3-no-usar-merge-cuando-es-necesario","title":"Error 3: No usar <code>merge()</code> cuando es necesario","text":"<p>java</p> <pre><code>Profesor detached = obtenerProfesorDetached();\ndetached.setNombre(\"Cambio\");\n// em.merge(detached); // \u274c FALT\u00d3 - cambios no se guardan\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#regla-practica-decisoria","title":"REGLA PR\u00c1CTICA DECISORIA","text":"<pre><code>graph TD\n    A[\u00bfTengo una entidad?] --&gt; B{\u00bfExiste en BD?};\n    B --&gt;|NO| C[Usar PERSIST];\n    B --&gt;|S\u00cd| D{\u00bfEst\u00e1 MANAGED?};\n    D --&gt;|S\u00cd| E[Modificar directamente];\n    D --&gt;|NO| F[Usar MERGE];</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#flujo-de-trabajo-recomendado","title":"Flujo de trabajo recomendado","text":"<pre><code>public void guardarProfesor(Profesor profesor) {\n    EntityTransaction tx = em.getTransaction();\n    tx.begin();\n\n    if (profesor.getIdProfesor() == null) {\n        // Entidad NUEVA - usar PERSIST\n        em.persist(profesor);\n    } else {\n        // Entidad EXISTENTE - verificar estado\n        if (!em.contains(profesor)) {\n            // Entidad DETACHED - usar MERGE\n            profesor = em.merge(profesor);\n        }\n        // Si est\u00e1 MANAGED, modificar directamente\n    }\n\n    tx.commit();\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#diferencias-clave-resumen","title":"DIFERENCIAS CLAVE RESUMEN","text":"Aspecto <code>persist()</code> <code>merge()</code> Prop\u00f3sito Insertar nuevo Actualizar existente Entrada Entidad TRANSIENT Entidad DETACHED/MANAGED Salida Entidad MANAGED Copia MANAGED ID Lo genera Ya debe tenerlo BD INSERT UPDATE Rendimiento M\u00e1s r\u00e1pido M\u00e1s overhead"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#mejores-practicas","title":"MEJORES PR\u00c1CTICAS","text":"<ol> <li>Usa <code>persist()</code> solo para entidades nuevas</li> <li>Modifica directamente entidades MANAGED</li> <li>Usa <code>merge()</code> solo para entidades DETACHED</li> <li>Verifica el estado con <code>em.contains()</code></li> <li>Maneja el retorno de <code>merge()</code> (es una copia)</li> </ol>"},{"location":"Unidad%203%20Hibernate/4_Relationships.es/#patron-recomendado","title":"PATR\u00d3N RECOMENDADO","text":"<pre><code>@Entity\npublic class ProfesorService {\n\n    @PersistenceContext\n    private EntityManager em;\n\n    public Profesor guardarOActualizar(Profesor profesor) {\n        if (profesor.getIdProfesor() == null) {\n            em.persist(profesor);\n            return profesor;\n        } else {\n            return em.merge(profesor);\n        }\n    }\n}\n</code></pre> <p>El proyecto de este segundo ejemplo lo tienes aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/","title":"5. Hibernate Query Language (HQL) / JPQL","text":"<p>La documentaci\u00f3n completa se puede encontrar aqu\u00ed:</p> <ul> <li>Documentaci\u00f3n en espa\u00f1ol</li> <li>Documentaci\u00f3n en ingl\u00e9s</li> </ul>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#introduccion-a-jpql","title":"Introducci\u00f3n a JPQL","text":"<p>JPQL (Java Persistence Query Language) es el lenguaje de consulta est\u00e1ndar de JPA, basado en HQL (Hibernate Query Language). JPQL trabaja con entidades y sus propiedades en lugar de tablas y columnas directamente.</p> <p>Las consultas con JPQL se realizan desde el EntityManager mediante la interfaz TypedQuery o Query. JPQL preserva el modelo orientado a objetos mientras permite realizar consultas similares a SQL.</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#creacion-y-ejecucion-de-consultas","title":"Creaci\u00f3n y Ejecuci\u00f3n de Consultas","text":"<p>En JPA, trabajamos con EntityManager en lugar de Session. Las consultas se crean de la siguiente manera:</p> <pre><code>// Consulta tipada (recomendado)\nTypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\"JPQL statement\", Alumno.class);\n\n// Consulta no tipada (alternativa)\nQuery q = entityManager.createQuery(\"JPQL statement\");\n</code></pre> <p>Opciones de ejecuci\u00f3n:</p> <pre><code>1 TypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\"JPQL statement\", Alumno.class);\n\n2.1 List&lt;Alumno&gt; resultsObjects = q.getResultList();\n\n2.2 List&lt;Object[]&gt; mixedResults = q.getResultList();\n\n2.3 Alumno result = q.getSingleResult();\n\n2.4 Object[] result = q.getSingleResult();\n\n// Procesar la informaci\u00f3n obtenida\n</code></pre> <p>Nota</p> <ul> <li><code>entityManager.createQuery()</code> \u2192 permite escribir una consulta JPQL</li> <li><code>getResultList()</code> \u2192 obtiene todos los objetos que satisfacen la consulta</li> <li><code>getSingleResult()</code> \u2192 obtiene un \u00fanico objeto</li> </ul>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#caracteristicas-de-jpql","title":"Caracter\u00edsticas de JPQL","text":"<ul> <li>Las consultas se realizan sobre entidades, no tablas</li> <li>Los nombres de entidades y propiedades son case-sensitive</li> <li>Es recomendable usar alias para las entidades</li> <li>No es necesario usar <code>SELECT *</code> - podemos omitir el SELECT completamente</li> <li>Las constantes de texto se encierran entre comillas simples</li> <li>Podemos consultar colecciones dentro de las entidades</li> </ul>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#51-recuperando-objetos","title":"5.1. Recuperando Objetos","text":"<p>Bas\u00e1ndonos en el esquema de base de datos proporcionado, definamos primero las entidades:</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#entidad-alumno","title":"Entidad Alumno","text":"<pre><code>@Entity\n@Table(name = \"Alumno\")\n@NamedQueries({\n    @NamedQuery(name = \"Alumno.findAll\", query = \"SELECT a FROM Alumno a\"),\n    @NamedQuery(name = \"Alumno.findByEdad\", query = \"SELECT a FROM Alumno a WHERE a.edad = :edad\"),\n    @NamedQuery(name = \"Alumno.findRepetidores\", query = \"SELECT a FROM Alumno a WHERE a.repetidor = true\")\n})\npublic class Alumno implements Serializable {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idAlumno;\n\n    private String nombre;\n    private String apellidos;\n    private Integer edad;\n    private Boolean repetidor;\n\n    @OneToMany(mappedBy = \"alumno\")\n    private List&lt;Examen&gt; examenes = new ArrayList&lt;&gt;();\n\n    // Constructores, getters y setters\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#entidad-examen","title":"Entidad Examen","text":"<pre><code>@Entity\n@Table(name = \"Examen\")\npublic class Examen implements Serializable {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long idExamen;\n\n    private LocalDateTime fecha;\n    private Double nota;\n\n    @ManyToOne\n    @JoinColumn(name = \"idAlumno\")\n    private Alumno alumno;\n\n    @ManyToOne\n    @JoinColumn(name = \"idModul\")\n    private Modulo modulo;\n\n    // Constructores, getters y setters\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#52-consultas-jpql","title":"5.2. Consultas JPQL","text":""},{"location":"Unidad%203%20Hibernate/5_HQL.es/#521-obteniendo-objetos-simples","title":"5.2.1. Obteniendo Objetos Simples","text":"<p>Consultar todos los alumnos:</p> <pre><code>// Forma completa y tipada\nTypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\"SELECT a FROM Alumno a\", Alumno.class);\nList&lt;Alumno&gt; losAlumnos = q.getResultList();\n\n// Forma simplificada\nTypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\"FROM Alumno\", Alumno.class);\nList&lt;Alumno&gt; losAlumnos = q.getResultList();\n\nfor (Alumno alumno : losAlumnos) {\n    System.out.println(alumno);\n}\n</code></pre> <p>Consultar un alumno espec\u00edfico:</p> <pre><code>TypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\"SELECT a FROM Alumno a WHERE a.idAlumno = :id\", Alumno.class);\nq.setParameter(\"id\", 1L);\nAlumno alumno = q.getSingleResult();\nSystem.out.println(alumno);\n</code></pre> <p>Atenci\u00f3n</p> <p>Usar <code>getSingleResult()</code> cuando la consulta puede devolver m\u00faltiples resultados lanzar\u00e1 una excepci\u00f3n <code>NonUniqueResultException</code>.</p> <p>Paginaci\u00f3n de resultados:</p> <pre><code>TypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\"SELECT a FROM Alumno a ORDER BY a.nombre\", Alumno.class);\nq.setFirstResult(0); // \u00cdndice del primer resultado\nq.setMaxResults(10); // M\u00e1ximo n\u00famero de resultados\nList&lt;Alumno&gt; alumnos = q.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#522-obteniendo-objetos-compuestos","title":"5.2.2. Obteniendo Objetos Compuestos","text":"<p>Consultar nombre y edad de los alumnos:</p> <pre><code>TypedQuery&lt;Object[]&gt; q = entityManager.createQuery(\n    \"SELECT a.nombre, a.edad FROM Alumno a\", Object[].class);\nList&lt;Object[]&gt; results = q.getResultList();\n\nfor (Object[] result : results) {\n    String nombre = (String) result[0];\n    Integer edad = (Integer) result[1];\n    System.out.println(\"Alumno: \" + nombre + \", Edad: \" + edad);\n}\n</code></pre> <p>Trabajando con colecciones:</p> <pre><code>TypedQuery&lt;Object[]&gt; q = entityManager.createQuery(\n    \"SELECT a.nombre, SIZE(a.examenes) FROM Alumno a\", Object[].class);\nList&lt;Object[]&gt; results = q.getResultList();\n\nfor (Object[] result : results) {\n    System.out.println(\"Alumno: \" + result[0] + \" ha realizado \" + result[1] + \" ex\u00e1menes.\");\n}\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#53-parametros-en-jpql","title":"5.3. Par\u00e1metros en JPQL","text":""},{"location":"Unidad%203%20Hibernate/5_HQL.es/#531-parametros-posicionales-no-recomendado-en-jpa-20","title":"5.3.1. Par\u00e1metros Posicionales (NO recomendado en JPA 2.0+)","text":"<pre><code>// No recomendado - usar par\u00e1metros nombrados en su lugar\nQuery q = entityManager.createQuery(\"SELECT a FROM Alumno a WHERE a.edad = ?1\");\nq.setParameter(1, 24);\nList&lt;Alumno&gt; alumnos = q.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#532-parametros-nominales-recomendado","title":"5.3.2. Par\u00e1metros Nominales (Recomendado)","text":"<pre><code>TypedQuery&lt;Alumno&gt; q = entityManager.createQuery(\n    \"SELECT a FROM Alumno a WHERE a.edad BETWEEN :minEdad AND :maxEdad\", Alumno.class);\nq.setParameter(\"minEdad\", 20);\nq.setParameter(\"maxEdad\", 25);\nList&lt;Alumno&gt; alumnos = q.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#533-consultas-nombradas-named-queries","title":"5.3.3. Consultas Nombradas (Named Queries)","text":"<p>Definidas en la entidad:</p> <pre><code>@Entity\n@Table(name = \"Alumno\")\n@NamedQueries({\n    @NamedQuery(name = \"Alumno.findRepetidores\", \n                query = \"SELECT a FROM Alumno a WHERE a.repetidor = true\"),\n    @NamedQuery(name = \"Alumno.findByRangoEdad\",\n                query = \"SELECT a FROM Alumno a WHERE a.edad BETWEEN :min AND :max\"),\n    @NamedQuery(name = \"Alumno.findAllOrderByEdadDesc\",\n                query = \"SELECT a FROM Alumno a ORDER BY a.edad DESC\")\n})\npublic class Alumno implements Serializable {\n    // ...\n}\n</code></pre> <p>Uso de consultas nombradas:</p> <pre><code>// Consulta tipada\nTypedQuery&lt;Alumno&gt; q = entityManager.createNamedQuery(\"Alumno.findRepetidores\", Alumno.class);\nList&lt;Alumno&gt; repetidores = q.getResultList();\n\n// Con par\u00e1metros\nTypedQuery&lt;Alumno&gt; q = entityManager.createNamedQuery(\"Alumno.findByRangoEdad\", Alumno.class);\nq.setParameter(\"min\", 20);\nq.setParameter(\"max\", 25);\nList&lt;Alumno&gt; alumnos = q.getResultList();\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#54-operaciones-crud-con-jpa","title":"5.4. Operaciones CRUD con JPA","text":""},{"location":"Unidad%203%20Hibernate/5_HQL.es/#541-crear-insert","title":"5.4.1. Crear (Insert)","text":"<pre><code>Alumno alumno = new Alumno();\nalumno.setNombre(\"Lewis\");\nalumno.setApellidos(\"Hamilton\");\nalumno.setEdad(42);\nalumno.setRepetidor(false);\n\nentityManager.persist(alumno);\n// En un contexto transaccional, usar entityManager.getTransaction().commit()\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#542-actualizar-update","title":"5.4.2. Actualizar (Update)","text":"<p>Actualizar un objeto espec\u00edfico:</p> <pre><code>Alumno alumno = entityManager.find(Alumno.class, 7L);\nalumno.setEdad(44);\nalumno.setRepetidor(true);\n\n// Con merge (para entidades detached)\nentityManager.merge(alumno);\n</code></pre> <p>Actualizaci\u00f3n masiva:</p> <pre><code>Query q = entityManager.createQuery(\n    \"UPDATE Alumno a SET a.edad = a.edad + 1 WHERE a.repetidor = true\");\nint registrosActualizados = q.executeUpdate();\nSystem.out.println(registrosActualizados + \" alumnos actualizados\");\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#543-eliminar-delete","title":"5.4.3. Eliminar (Delete)","text":"<p>Eliminar un objeto espec\u00edfico:</p> <pre><code>Alumno alumno = entityManager.find(Alumno.class, 7L);\nentityManager.remove(alumno);\n</code></pre> <p>Eliminaci\u00f3n masiva:</p> <pre><code>Query q = entityManager.createQuery(\"DELETE FROM Alumno a WHERE a.repetidor = true\");\nint registrosEliminados = q.executeUpdate();\nSystem.out.println(registrosEliminados + \" alumnos eliminados\");\n</code></pre> <p>Consejo</p> <p>- Las operaciones de actualizaci\u00f3n y eliminaci\u00f3n masiva deben usarse con cuidado - Verificar las restricciones de integridad referencial - Considerar el uso de operaciones en cascada cuando sea apropiado</p>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#55-consultas-avanzadas","title":"5.5. Consultas Avanzadas","text":""},{"location":"Unidad%203%20Hibernate/5_HQL.es/#joins-implicitos-y-explicitos","title":"Joins impl\u00edcitos y expl\u00edcitos","text":"<pre><code>// Join impl\u00edcito\nTypedQuery&lt;Object[]&gt; q = entityManager.createQuery(\n    \"SELECT a.nombre, e.nota FROM Alumno a, Examen e WHERE a.idAlumno = e.alumno.idAlumno\", \n    Object[].class);\n\n// Join expl\u00edcito (recomendado)\nTypedQuery&lt;Object[]&gt; q = entityManager.createQuery(\n    \"SELECT a.nombre, e.nota FROM Alumno a JOIN a.examenes e WHERE e.nota &gt; 5\", \n    Object[].class);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#funciones-de-agregacion","title":"Funciones de agregaci\u00f3n","text":"<pre><code>// Promedio de notas por alumno\nTypedQuery&lt;Object[]&gt; q = entityManager.createQuery(\n    \"SELECT a.nombre, AVG(e.nota) FROM Alumno a JOIN a.examenes e GROUP BY a.nombre\", \n    Object[].class);\n\n// Contar ex\u00e1menes por m\u00f3dulo\nTypedQuery&lt;Object[]&gt; q = entityManager.createQuery(\n    \"SELECT m.nombre, COUNT(e) FROM Modulo m LEFT JOIN m.examenes e GROUP BY m.nombre\", \n    Object[].class);\n</code></pre>"},{"location":"Unidad%203%20Hibernate/5_HQL.es/#56-estados-de-las-entidades-en-jpa","title":"5.6. Estados de las Entidades en JPA","text":"<p>En JPA, las entidades pueden tener los siguientes estados:</p> <ul> <li>Transient: El objeto es nuevo y no est\u00e1 asociado con ning\u00fan contexto de persistencia</li> <li>Managed: El objeto est\u00e1 siendo gestionado por el EntityManager</li> <li>Detached: El objeto fue gestionado pero el EntityManager est\u00e1 cerrado</li> <li>Removed: El objeto est\u00e1 marcado para ser eliminado</li> </ul> <pre><code>// Transient\nAlumno alumno = new Alumno();\n\n// Managed (despu\u00e9s de persist)\nentityManager.persist(alumno);\n\n// Detached (despu\u00e9s de close o clear)\nentityManager.detach(alumno);\n// o\nentityManager.close();\n\n// Removed\nentityManager.remove(alumno);\n</code></pre> <p>El proyecto de ejemplo lo tenemos aqu\u00ed</p>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/","title":"6 Ejercicio","text":"<p>Notas sobre el enunciado y pr\u00e1ctica</p> <ul> <li>Esta pr\u00e1ctica es de enunciado abierto. Tienes que crear tu propia tarea, con ciertas limitaciones, como vas a comprender.      Tienes que hacer un programa que haga el mantenimiento de una base de datos a tu elecci\u00f3n: podr\u00e1s crearla de cero o escoger      alguna que conozcas o buscar en Internet.</li> </ul>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#1-la-base-de-datos","title":"1. La base de datos","text":"<p>Las restricciones de la base de datos son:</p> <ul> <li>Debe contener como m\u00ednimo tres entidades.</li> <li>Debe contener como m\u00ednimo tres relaciones, una de cada clase: <code>1-1</code>, <code>1-M</code> y <code>N:M</code>. Si lo deseas, puedes crear una relaci\u00f3n reflexiva.</li> <li>Utiliza MySQL</li> </ul>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#2-el-programa","title":"2. El programa","text":""},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#21-estructura","title":"2.1. Estructura","text":"<p>Crea un programa Hibernate con el objetivo de realizar las operaciones b\u00e1sicas de CRUD en su base de datos (Create, Read, Update y Delete). Mapea todas las entidades y relaciones de la base de datos.</p>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#22-crud","title":"2.2. CRUD","text":"<p>Como todo el trabajo de cada entidad es el mismo (cambiando el nombre de la entidad), s\u00f3lo debes crear un CRUD completo para una entidad. A continuaci\u00f3n, crea m\u00e9todos para insertar, eliminar, actualizar y seleccionar informaci\u00f3n de una entidad.</p>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#23-relaciones","title":"2.3. Relaciones","text":"<p>Imagina que tenemos una relaci\u00f3n <code>1:M</code>, un <code>Autor</code> escribe varios <code>Libros</code>. Con tus propias relaciones, haz lo mismo de la siguiente manera:</p>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#231-tarea-1","title":"2.3.1. Tarea 1","text":"<p>Tienes que mostrar registros de una entidad, por ejemplo <code>muestra Autor</code>. Este pedido mostrar\u00e1 a todos los autores de la base de datos. Pero si el pedido es \"muestra -r Autor\", mostrar\u00e1 para cada autor los libros que ha escrito. (<code>r</code> significa recursivamente)</p>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#232-tarea-2","title":"2.3.2. Tarea 2","text":"<p>Cuando quieras insertar un nuevo Libro, puedes ejecutar <code>a\u00f1adir Libro</code>, y despu\u00e9s, de forma interactiva, el programa pedir\u00e1 los valores del libro y lo crear\u00e1 y almacenar\u00e1, estableciendo el Autor como <code>null</code>. Pero si ejecutas \"a\u00f1adir -r Libro\", el programa mostrar\u00e1 a todos los autores de la base de datos. El usuario seleccionar\u00e1 uno, y este Autor se configurar\u00e1 como autor del libro.</p> <p>En el proceso de selecci\u00f3n del Autor, habr\u00e1 una opci\u00f3n adicional (Autor 0, por ejemplo) cuando el autor del libro no est\u00e9 en la base de datos, y crearemos un nuevo Autor y despu\u00e9s lo asignaremos al Libro. Tanto el Autor como el Libro se guardar\u00e1n.</p>"},{"location":"Unidad%203%20Hibernate/6_Ejercicio/#3-tarea","title":"3. Tarea.","text":"<p>Para subir la tarea a la plataforma, basta con que escribas un enlace a un repositorio privado de GitHub del estudiante. Tienes que a\u00f1adir al usuario de tu profesor como invitado de tu repositorio (<code>ManuEduGVA</code> - jm.romeromartinez@edu.gva.es). La tarea se presentar\u00e1 con los siguientes puntos.</p> <p>En la carpeta de tu trabajo debes tener:</p> <ol> <li>Un script con la creaci\u00f3n de tablas de la base de datos y alg\u00fan dato de ejemplo. Tienes que generarlo con MySQL Workbench sql dump.</li> <li>Una imagen de la estructura de tu base de datos, creada con MySQL Workbench reverse engineering.</li> <li>Un proyecto Maven que implemente los requisitos de este texto.</li> <li>Archivo <code>Readme.md</code> con documentaci\u00f3n sobre tu programa.</li> </ol>"},{"location":"Unidad%204%20BBDDOO/1_Introducci%C3%B3n/","title":"1 Introducci\u00f3n","text":""},{"location":"Unidad%204%20BBDDOO/1_Introducci%C3%B3n/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Las bases de datos relacionales surgen del modelo relacional como un sistema que representa fielmente la realidad, con gran solidez debido a la l\u00f3gica relacional subyacente. Este modelo representa la perspectiva est\u00e1tica de la modelizaci\u00f3n de la aplicaci\u00f3n, y en \u00e9l todos los datos se desglosan a niveles at\u00f3micos, puesto que, como recordamos, no se permiten valores multivaluados ni compuestos.</p> <p>Este modelo ha sufrido la brecha objeto-relacional, en la que los lenguajes de programaci\u00f3n han evolucionado las estructuras adoptando la metodolog\u00eda orientada a objetos. Esto nos lleva a dise\u00f1ar la base de datos por un lado, siguiendo el modelo relacional, y tambi\u00e9n necesitamos dise\u00f1ar las clases de la aplicaci\u00f3n por otro lado. Estos dise\u00f1os, que no suelen coincidir, se pueden ajustar con las herramientas ORM estudiadas en la unidad anterior para mitigar la desconexi\u00f3n objeto-relacional.</p> <p>De esa brecha surge la necesidad de a\u00f1adir un dise\u00f1o m\u00e1s orientado a objetos dentro de la propia base de datos. Si analizamos un esquema orientado a objetos e intentamos aplicar la teor\u00eda de la normalizaci\u00f3n, encontraremos que los objetos se descomponen en varias entidades, provocando la aparici\u00f3n de muchas tablas.</p> <p>Este alto n\u00famero de tablas provoca, como consecuencia, un aumento de las referencias entre ellas, aumentando considerablemente las relaciones entre ellas y, por tanto, un mayor n\u00famero de restricciones a controlar (FOREIGN KEY), lo que supone un aumento del n\u00famero de comprobaciones que debe realizar el SGBD.</p> <p>As\u00ed, en la BD OO (Base de Datos Orientada a Objetos) se permite una definici\u00f3n de tipos de datos complejos en comparaci\u00f3n con los simples que incorpora el SGBD relacional, permitiendo la definici\u00f3n de tipos estructurados e incluso multivaluados. Con todo ello, la BD OO deber\u00eda permitir simplemente el dise\u00f1o a trav\u00e9s de objetos (similar al UML) indicando los objetos que participan en ellos, indicando sus atributos y m\u00e9todos, y las relaciones que les afectan, y obviamente, las herencias.</p> <p>Estas BD OO todav\u00eda no han despegado, y algunas soluciones que implementan soluciones comerciales es proporcionar al sistema de bases de datos relacionales las capacidades sem\u00e1nticas de la orientaci\u00f3n a objetos, apareciendo as\u00ed las BDOR (Bases de Datos Objeto-Relacional).</p>"},{"location":"Unidad%204%20BBDDOO/1_Introducci%C3%B3n/#2-bases-de-datos-objeto-relacional","title":"2. Bases de Datos Objeto-Relacional","text":"<p>El est\u00e1ndar ANSI SQL1999 (SQL99 y posteriormente SQL2003), como continuaci\u00f3n de SQL92 en el que se adaptan las caracter\u00edsticas del modelo relacional, permite a\u00f1adir caracter\u00edsticas orientadas a objetos en las bases de datos relacionales. Esto permite que los SGBD robustos hayan adoptado e implementado aquellas caracter\u00edsticas requeridas. Entre estas caracter\u00edsticas se encuentran:</p> <ul> <li>Definici\u00f3n de nuevos tipos de datos por parte del usuario.</li> <li>Adaptaci\u00f3n para acomodar grandes tipos de datos binarios como im\u00e1genes y documentos.</li> <li>Capacidad para almacenar elementos compuestos como arrays.</li> <li>Almacenar directamente referencias a otras tablas.</li> <li>Definici\u00f3n de objetos y herencia.</li> <li>Definici\u00f3n de funciones que gestionan las estructuras previamente definidas.</li> </ul>"},{"location":"Unidad%204%20BBDDOO/2_ORDB/","title":"2 ORDB","text":""},{"location":"Unidad%204%20BBDDOO/2_ORDB/#1-base-de-datos-objeto-relacional","title":"1. Base de datos Objeto-Relacional","text":"<p>En esta secci\u00f3n trabajaremos con la base de datos PostgreSQL. Como el sistema de gesti\u00f3n de bases de datos objeto-relacional de c\u00f3digo abierto, que ha tenido el mayor impacto, siendo un rival directo del gran Oracle.</p> <p>Nos centraremos en las novedades que ofrece Postgres frente a MySQL, como una extensi\u00f3n de los conceptos del primer a\u00f1o.</p> <p>Importante</p> <p>Ser\u00e1 interesante: </p> <ul> <li>Instalar tu propio servidor PostgreSQL. Se recomienda utilizarlo mediante un contenedor Docker. </li> <li>Instalar un cliente para mostrar su base de datos. Recomendamos DBeaver.</li> </ul> <p>Trabajaremos con este conocido ejemplo:</p> <p></p>"},{"location":"Unidad%204%20BBDDOO/2_ORDB/#2-definicion-de-tipos","title":"2. Definici\u00f3n de tipos","text":"<p>En PostgreSQL existen los tipos habituales que se encuentran en los modernos SGBD. Adem\u00e1s, destacan tipos especiales para almacenar direcciones de Internet (Tipo de Direcci\u00f3n de Red), XML y JSON para guardar y procesar estos formatos, tipos propios y colecciones. Con ello, podemos observar los grandes avances de PostgreSQL, que de forma relajada podr\u00edamos considerar como Objeto-Relacional y Documental.</p>"},{"location":"Unidad%204%20BBDDOO/2_ORDB/#21-enumeracion","title":"2.1. Enumeraci\u00f3n","text":"<p>Los tipos enumerados son tipos que s\u00f3lo permiten valores espec\u00edficos, generalmente tambi\u00e9n conocidos como dominios. En PostgreSQL podemos crearlos de la siguiente manera:</p> <pre><code>CREATE TYPE enum_name AS ENUM \n( [ 'valor' [, ... ] ] );\n</code></pre> <p>por ejemplo:</p> <pre><code>create type basic_colors as enum('#FF0000','#00FF00','#0000FF');\ncreate type street_kind as enum ('Calle','Avenida','Partida');\n</code></pre> <p>Esta forma de definir este tipo evitar\u00e1 las comprobaciones de valores (cl\u00e1usulas CHECK) existentes en algunos SGBD relacionales.</p>"},{"location":"Unidad%204%20BBDDOO/2_ORDB/#22-tipos-estructurados","title":"2.2. Tipos estructurados","text":"<p>Los tipos estructurados son los precursores de los objetos en s\u00ed. Si recordamos, en la programaci\u00f3n estructurada, a partir de los tipos b\u00e1sicos, pod\u00edamos crear estructuras de datos:</p> <ul> <li>Donde todos los elementos son iguales (vectores, arrays y colecciones)</li> <li>Donde sus elementos podr\u00edan ser de distintos tipos. Estas estructuras evolucionaron hacia los objetos actuales a\u00f1adiendo comportamiento y otras caracter\u00edsticas.</li> </ul> <p>En el modelo relacional, al tener que respetar la atomicidad de los datos, no pod\u00edamos generar estas estructuras. En Postgres podemos crear estos nuevos tipos de datos estructurados con la siguiente sintaxis, muy similar a la creaci\u00f3n de una tabla:</p> <pre><code>CREATE TYPE type_name AS( \nattribute_name data_type \n[, ... ]-- one or more\n);\n</code></pre> <p>por ejemplo:</p> <pre><code>create type Punto as( \nx integer, \nY integer\n);\n</code></pre> <p>o, utilizando uno una enumeraci\u00f3n, de las vistas antes:</p> <pre><code>create type Address as( \nType street_kind, \nstreet varchar, \nnumber int\n);\n</code></pre> <p>y finalmente crear\u00edamos la siguiente tabla:</p> <pre><code>create table person( \nidPerson serial primary key, \nname varchar, \ndirection Address\n);\n\ninsert into person(name) values \u200b\u200b('manu');\ninsert into person(name,address) values('manu',null);\ninsert into person(name,address) values('manu',('Street','Vinalesa  ',1));\n\nselect direction from person;\nselect (address).street from person;\n</code></pre> <p>Recordatorio</p> <ul> <li>No se pueden aplicar restricciones NOT NULL, DEFAULT o CHECK en los campos que pertenecen a los tipos creados. </li> <li>La tipificaci\u00f3n tiene sentido en datos que no existen por s\u00ed mismos, que necesitan ser incrustados en otras estructuras o tablas. </li> <li>Cuando se utiliza dentro de una tabla y se manipula la inserci\u00f3n, se realizar\u00e1 en un bloque, entre par\u00e9ntesis, ya que determina una estructura. </li> <li>Para seleccionar un subtipo, debemos rodear el tipo general entre par\u00e9ntesis, de lo contrario Postgres lo confunde con una tabla y genera un error.</li> </ul>"},{"location":"Unidad%204%20BBDDOO/2_ORDB/#3-clases-o-realmente-tablas","title":"3. Clases (\u00bfo realmente tablas?)","text":"<p>Vamos a crear una clase <code>Figura</code>, que ser\u00e1 el punto de partida de una herencia del modelo presentado en el inicio de la unidad. Veamos qu\u00e9 incorpora respecto a las implementaciones del modelo relacional. Figura contiene una clave primaria, y contendr\u00e1 un Punto para localizarla en el plano. Adem\u00e1s contiene una colecci\u00f3n de colores, para hacer posibles degradados, guardados como un array. Guardar colecciones es tambi\u00e9n una capacidad a\u00f1adida que no soporta el modelo relacional, dada la ausencia de valores multivaluados.</p> <p>Se crea una clase con la misma sintaxis que una tabla, puesto que, a efectos pr\u00e1cticos, desde un punto de vista estructural es lo mismo. Posteriormente, la herencia distingue que una tabla \"hereda\" de otra.</p> <pre><code>create table Figura ( \nfID serial primary key, -- identifier \nPunto position, -- position he occupies \ncolor TEXTO[ ] -- color(s) of the figure\n);\n</code></pre> <p>Para insertar nuevos registros, ten en cuenta que:</p> <ul> <li>Los elementos de tipo <code>Punto</code> deben almacenarse utilizando un constructor que crea una <code>fila</code> abstracta, llamada <code>ROW</code> o entre par\u00e9ntesis.</li> <li>Para los arrays, tambi\u00e9n necesitamos un constructor llamado <code>ARRAY</code>, con una lista de elementos.</li> </ul> <pre><code>insert into Figura(position,color) \nvalues(ROW(0,0),ARRAY['#FFFFFF','#00CC00']);\n</code></pre> <p>A partir de aqu\u00ed, crearemos nuevas clases para representar a los c\u00edrculos, cuadrados y rect\u00e1ngulos de <code>Figura</code> utilizando la herencia. La sintaxis es la siguiente:</p> <pre><code>create table sub_table( \n-- definition of table attributes\n) inherits (super_table);\n</code></pre> <p>Como podemos ver, simplemente a\u00f1adimos <code>inherits</code> para crear la relaci\u00f3n de herencia. Por el dise\u00f1o que ten\u00edamos anteriormente:</p> <pre><code>create table Rect\u00e1ngulo( \nheight int, \nwidth int\n) inherits (Figure);\n\ncreate table Cuadrado( \nside int\n) inherits (Figure);\n\ncreate table C\u00edrculo( \nradio int\n) inherits (Figure);\n</code></pre> <p>Insertamos algunas filas, teniendo en cuenta que tambi\u00e9n debemos incluir los atributos de la superclase.</p> <pre><code>insert into Cuadrado(position,color,side) values \u200b\u200b(ROW(10,10),ARRAY['#00BBCC','#BBCC00'],40);\ninsert into Cuadrado(position,color,side) values(ROW(10,fifteen),ARRAY['#AA6633','#CCFF00'],27);\ninsert into C\u00edrculo(position,color,radius) values(ROW(30,25),ARRAY['#BBCC','#CCCC00'],20);\ninsert into C\u00edrculo(position,color,radius) values(ROW(10,-10),ARRAY['#00BBCC','#CCCC00'],20);\ninsert into Rectangle(position,color,height,width) values(ROW(10,5),ARRAY['#00BBCC','#CCCC00'],20,50);\ninsert into Rectangle(position,color,height,width) values(ROW(30,-10),ARRAY['#00BBCC','#CCCC00'],20,50);\n</code></pre> <p>Si ejecutamos varios <code>Select * from</code>, obtenemos a DBeaver:</p> <p></p> <p></p> <p></p> <p></p> <p>Como es l\u00f3gico, es posible pensar que cuando seleccionemos datos de la tabla general (<code>Select * from Figura</code>) aparecer\u00e1n todos los elementos de las subclases. Si quisi\u00e9ramos seleccionar s\u00f3lo aquellos que son Figura, podr\u00edamos hacerlo con (<code>Select * from ONLY Figura</code>).</p> <p>Vamos a completar el ejemplo creando un dibujo con todas las figuras almacenadas. Guardaremos el dibujo en una nueva clase que contiene la identificaci\u00f3n del dibujo, y guardaremos una colecci\u00f3n con los identificadores de las figuras que componen el dibujo.</p> <pre><code>drop table if exists Dibujo;\ncreate table Dibujo(\n    idDibujo serial primary key,\n    elementos int[]\n);\n\n\ninsert into Dibujo (elementos) values(ARRAY[2,4,5,6]); \ninsert into Dibujo (elementos) values(array(select fid from figura)); \n</code></pre> <p>Comentar que la selecci\u00f3n de los identificadores de <code>Figura</code> puede ser directa, o seleccionando aqu\u00e9llos que queremos, mediante una consulta incrustada dentro del constructor ARRAY. Esto puede hacerse cuando el select devuelve una sola columna.</p> <p>Obtenemos los dibujos que tenemos, esta colecci\u00f3n de figuras se muestra. Pero si queremos descomponer el vector, para acceder a cada una de las figuras existentes, podemos hacerlo con la funci\u00f3n <code>unnest</code>.</p> <p>Fichero de configuraci\u00f3n de PostGres Fichero de base de datos de Figuras</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/","title":"3 OODB","text":""},{"location":"Unidad%204%20BBDDOO/3_OODB/#1-base-de-datos-orientadas-a-objetos-objectdb","title":"1. Base de datos Orientadas a Objetos. ObjectDB","text":"<p>En esta secci\u00f3n, como SGBD, se ha escogido ObjectDB, puesto que es muy vers\u00e1til, gratuito e incluso permite incrustarlo dentro de nuestros proyectos Java, lo que permite una gran simplicidad para el desarrollo de peque\u00f1as aplicaciones, gracias a la eliminaci\u00f3n de un servidor.</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#2-instalacion","title":"2. Instalaci\u00f3n","text":"<p>ObjectDB no requiere instalaci\u00f3n como tal, ya que todo su c\u00f3digo est\u00e1 integrado en una API para acceder a la base de datos empaquetada en un archivo jar. Desde el sitio web oficial podemos descargar el Kit de Desarrollo de ObjectDB. En el momento de escribir esta documentaci\u00f3n, la versi\u00f3n es la 2.9.4. Este kit contiene, entre otros:</p> <ul> <li>Dependencias para proyectos Java</li> <li>Utilidades para visualizar y consultar la base de datos</li> <li>Servidor para aplicaciones distribuidas</li> <li>Documentaci\u00f3n</li> </ul> <p>Una vez descomprimido, s\u00f3lo necesitaremos la m\u00e1quina virtual Java instalada en nuestro sistema para ejecutar todos los elementos. Para utilizar ObjectDB en nuestro proyecto debemos a\u00f1adir el archivo <code>objectdb.jar</code> a las dependencias de nuestro proyecto o hacerlo utilizando el gestor de dependencias maven o gradle.</p> <p>Nosotros vamos a optar por generar un proyecto de jakarta y a\u00f1adiremos las dependencias de hibernate y persistencia.</p> <p>Una vez arrancado el proyecto, en el pom.xml a\u00f1adiremos la dependencia correspondiente a objectdb:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.cipfpcheste.dam2&lt;/groupId&gt;\n    &lt;artifactId&gt;BBDDOO&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;BBDDOO&lt;/name&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;\n        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;\n        &lt;junit.version&gt;5.11.0&lt;/junit.version&gt;\n    &lt;/properties&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;objectdb&lt;/id&gt;\n            &lt;name&gt;ObjectDB Repository&lt;/name&gt;\n            &lt;url&gt;https://m2.objectdb.com&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n            &lt;version&gt;3.2.0-M2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.objectdb&lt;/groupId&gt;\n            &lt;artifactId&gt;objectdb-jk&lt;/artifactId&gt;\n            &lt;version&gt;2.9.4&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.42&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <p>Puesto que vamos a incluir el paquete de objectDB, debemos configurar el fichero persistence.xml:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence\n                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\"\n             version=\"2.1\"&gt;\n\n    &lt;persistence-unit name=\"objectdb-unit\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n        &lt;provider&gt;com.objectdb.jpa.Provider&lt;/provider&gt;\n\n        &lt;class&gt;Product&lt;/class&gt;\n\n        &lt;properties&gt;\n\n            &lt;property name=\"jakarta.persistence.jdbc.url\"\n                      value=\"/home/manu/temp/BBDDOO/bd/testdb.odb\"/&gt;\n\n            &lt;property name=\"jakarta.persistence.jdbc.user\" value=\"admin\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.password\" value=\"admin\"/&gt;\n\n            &lt;property name=\"jakarta.persistence.schema-generation.database.action\"\n                      value=\"create\"/&gt;\n\n            &lt;property name=\"eclipselink.logging.level\" value=\"FINE\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> Warning <ul> <li>Indicamos d\u00f3nde almacenar la base de datos: property name=\"jakarta.persistence.jdbc.url\" value=\"/home/manu/temp/BBDDOO/bd/testdb.odb\"</li> <li>Establecemos el usuario: property name=\"jakarta.persistence.jdbc.user\" value=\"admin\"</li> <li>Establecemos la contrase\u00f1a: property name=\"jakarta.persistence.jdbc.password\" value=\"admin\"</li> <li>Pol\u00edtica de creaci\u00f3n de la BD: property name=\"jakarta.persistence.schema-generation.database.action\" value=\"create\"</li> </ul> <p>En este momento podemos conectarnos a la base de datos, la centralizaci\u00f3n de la conexi\u00f3n a la base de datos se realiza a trav\u00e9s de una instancia de un objeto <code>EntityManagerFactory</code>, del que podemos obtener varias instancias de un <code>EntityManager</code>.</p> <p>Desde el <code>EntityManager</code> podremos llevar a cabo las operaciones t\u00edpicas de CRUD, teniendo en cuenta que siempre que haya modificaciones en \u00e9l. Debemos llevar a cabo la operaci\u00f3n dentro de una transacci\u00f3n para evitar situaciones inconsistentes en ella. Aqu\u00ed vemos una posible clase con el establecimiento de la conexi\u00f3n y la obtenci\u00f3n de un <code>EntityManager</code>. Ten en cuenta que las importaciones son de <code>jakarta.persistence</code>.</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#3-persistencia-de-clases","title":"3. Persistencia de clases","text":"<p>Para persistir un objeto, necesitaremos (similar a Hibernate):</p> <ul> <li>Anotar tu clase y marcarla como <code>@Entity</code></li> <li>Definir un campo como <code>@Id</code> y opcionalmente auto-incrementar con <code>@GeneratedValue</code>.</li> <li>El resto de los atributos de la entidad, por defecto, se persisten autom\u00e1ticamente sin ning\u00fan tipo de anotaci\u00f3n. En caso de no querer persistir, podemos indicarlo con <code>@Transient</code>. Aprovechamos Lombok para que nos genere todo getters, setters, toString, etc. F\u00edjate que creo un constructor sin el par\u00e1metro del id porque interesa de cara a que sea ObjectDB quien genere esa clave:</li> </ul> <pre><code>import jakarta.persistence.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Entity\n@Table(name = \"productos\")\npublic class Producto {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(name = \"nombre\", nullable = false, length = 100)\n    private String nombre;\n\n    @Column(name = \"precio\", nullable = false)\n    private double precio;\n\n    @Column(name = \"descripcion\", length = 500)\n    private String descripcion;\n\n    public Producto(String nombre, double precio, String descripcion) {\n        this.nombre = nombre;\n        this.precio = precio;\n        this.descripcion = descripcion;\n    }\n}\n</code></pre> <p>Para almacenar un Producto, bastar\u00e1 con crear un Producto y persistirlo en la base de datos, como se ve a continuaci\u00f3n:</p> <pre><code>        EntityManagerFactory emf = null;\n        EntityManager em = null;\n        try {\n\n            emf = Persistence.createEntityManagerFactory(\"objectdb-unit\");\n            em = emf.createEntityManager();\n\n            // Crear productos\n            Producto portatil = new Producto(\"Asus TUF\", 1299.99, \"Portatil para gamers\");\n            Producto raton = new Producto(\"Rat\u00f3n Inal\u00e1mbrico\", 49.99, \"Rat\u00f3n de baja calidad\");\n            Producto teclado = new Producto(\"Teclado Mec\u00e1nico\", 89.99, \"Teclado mec\u00e1nico RGB\");\n\n            // Persistir (CREATE)\n            EntityTransaction transaction = em.getTransaction();\n            transaction.begin();\n\n            em.persist(portatil);\n            em.persist(raton);\n            em.persist(teclado);\n\n            transaction.commit();\n            System.out.println(\"Productos persistidos: \" + portatil.getId() + \", \" + raton.getId() + \", \" + teclado.getId());\n</code></pre> <p>Clases incrustadas o Componentes</p> <p>En Java, en ocasiones hay clases que no tienen existencia propia, a menos que existan dentro de otra clase como podr\u00eda ser Fabricante. No tiene sentido crear un objeto Fabricante ad-hoc, en cambio, s\u00ed tiene sentido crearlo para que una Fabricante exista, por ejemplo, dentro de un Producto.</p> <p>Para estos casos (d\u00e9biles) que existen incrustados dentro de otras clases, debemos declararlos como incrustables utilizando la anotaci\u00f3n <code>@Embeddable</code> y marcarlos como incrustados (<code>@Embedded</code>) dentro de la clase en la que existen.</p> <pre><code>@Embeddable\npublic class Fabricante{ \n...\n}\n\n@Entity\npublic clases Producto{ \n... \n@Embedded \nprivate Producto producto;\n}\n\n// En el main\nProducto  pro= new Producto(\"Lenovo Carbon\", 1400, \"Portatil pofesional\");\nFrabricante fa = new Fabricante(\"Lenovo Spain SL\",\"Calle Puerto De Somport 9\",28050,\"Madrid\");\npro.setFabricante(fa);\nem.persist(pro);\n</code></pre> <p>Una entidad <code>Producto</code> se guardar\u00e1 en la base de datos, pero el <code>Fabricante</code> no existe como objeto por s\u00ed mismo.</p> <p>Para los puntos de las relaciones, vamos a utilizar como ejemplos las clases Alumno, Profesor, Clase, etc.</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#4-relaciones","title":"4. Relaciones","text":""},{"location":"Unidad%204%20BBDDOO/3_OODB/#41-relacion-uno-a-uno","title":"4.1. Relaci\u00f3n uno a uno","text":"<p>La relaci\u00f3nm\u00e1s sencilla es uno a uno, en la que un objeto contiene otro objeto. La marcaremos como ya hicimos en Hibernate con el modificador <code>@OneToOne</code> indicando que el guardado es en cascada (<code>cascade=CascadeType.PERSIST</code>).</p> <p>A partir de ahora, cuando guardes una instancia de un objeto, tu propia instancia del objeto relacionado se guardar\u00e1 y enlazar\u00e1. El objeto enlazado tendr\u00e1 existencia por s\u00ed mismo (si est\u00e1 marcado como <code>@Entity</code>). Un ejemplo b\u00e1sico en el que una clase tiene un \u00fanico <code>Tutor</code>:</p> <p>Basado en un ejemplo en el que una <code>Clase</code> (de un instituto) tiene un <code>Tutor</code> asociado, el ejemplo ser\u00e1 el siguiente:</p> <pre><code>@Entity\npublic class Profesor{ \n...\n}\n\n@Entity\npublic class Clase{ \n... \n@OneToOne(cascade=CascadeType.PERSIST) \nprivate Profesor tutor;\n}\n\n\nProfesor p=new Profesor(\"Pepe\");\nClase c= new Clase(\"2DAM\");\nc.setTutor(p);\num.persist(c); // Cuando guardamos clase, tutor es almacenado.\n</code></pre> <p>Atenci\u00f3n</p> <ul> <li>Recuerda que, al igual que en Hibernate, esta relaci\u00f3n es unidireccional, pero puede hacerse bidireccional.</li> </ul>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#42-relacion-una-a-muchos","title":"4.2. Relaci\u00f3n Una a muchos","text":"<p>Ahora nos referiremos a una relaci\u00f3n cl\u00e1sica en la que un Profesor es el tutor de varios Alumno. Estas relaciones pueden ser unidireccionales o bidireccionales. En este ejemplo lo veremos de forma bidireccional, de tal modo que dado un alumno podemos saber qui\u00e9n es su tutor y dado un profesor podemos obtener a los alumnos que tutoriza.</p> <pre><code>@Entity\npublic class Alumno{ \n... \n@ManyToOne(cascade=CascadeType.PERSIST) \nprivate Profesor tutor;\n\n}\n\n@Entity\npublic class Profesor{ \n... \n@OneToMany(cascade=CascadeType.PERSIST, \nfetch=FetchType.EAGER) \nprivate List&lt;Alumno&gt; losEstudiantes;\n}\n</code></pre> <p>Atenci\u00f3n</p> <ul> <li>Recuerda que, al igual que en Hibernate, la carga de las colecciones se puede realizar de inmediato, con un modo <code>EAGER</code> o cuando sea necesario en modo <code>LAZY</code>.</li> </ul>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#43-muchos-a-muchos","title":"4.3. Muchos a muchos","text":"<p>En las relaciones de muchos a muchos, podemos abordarlas de distintas formas. Damos el ejemplo de la ense\u00f1anza entre Profesor y Alumno. Si simplemente queremos indicar qui\u00e9n ense\u00f1a a quien, ser\u00eda suficiente almacenar una colecci\u00f3n de profesores en cada alumno (los profesores que ense\u00f1an a ese alumno), y sim\u00e9tricamente, en cada profesor una colecci\u00f3n de alumnos (los alumnos a quienes ense\u00f1an). En este caso, ser\u00eda bidireccional, ya que desde una clase podemos navegar a otra, quedando as\u00ed:</p> <pre><code>@Entity\npublic class Alumno{ \n... \n@ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY) \nprivate Set&lt;Profesor&gt; profesores=new Hash Set&lt;&gt;();\n}\n\n@Entity\npublic class Profesor{ \n... \n@ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY) \nprivate Set&lt;Alumno&gt; estudiantes=new Hash Set&lt;&gt;();;\n}\n</code></pre> <p>Atenci\u00f3n</p> <p>Si necesitamos guardar cualquier informaci\u00f3n dentro de esta relaci\u00f3n, como la nota recibida, el estudiante, o los incidentes publicados, etc., entonces debemos crear una nueva clase, que incorporar\u00e1 los atributos de la relaci\u00f3n, y establecer relaciones uno a muchos desde cada entidad (Estudiante/Profesor) hasta la nueva entidad (Ense\u00f1anza). Esta suposici\u00f3n es la famosa Las relaciones N-M generan una tabla con los atributos que poseen del modelo relacional.</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#5-consultas","title":"5. Consultas","text":"<p>Revisaremos c\u00f3mo cargar los datos que hemos guardado previamente en la base de datos. Supongamos que tenemos una clase Estudiante, mapada con una entidad y con un identificador (idStudent). La manera m\u00e1s sencilla de cargar a un Estudiante, conociendo su id, es el m\u00e9todo <code>find(class,id)</code>, como hicimos en Hibernate:</p> <pre><code>Estudiante a=em.find(Estudiante.class,2);\n</code></pre> <p>El resto de las cargas deben llevarse a cabo mediante consultas, en un lenguaje JPQL (Java Persistence Query Language), nuevamente similar al HQL de Hibernate.</p> <p>Hay dos clases: <code>Query</code> y <code>TypedQuery</code> (la segunda hereda de la primera), que se utilizan normalmente en el primer caso cuando no conocemos el resultado de la consulta, y en el segundo cuando conocemos el resultado.</p> <p>La primera es polim\u00f3rfica, por lo que enlazar\u00e1 din\u00e1micamente los resultados, y la segunda verifica el resultado con la clase actual. La documentaci\u00f3n oficial recomienda el uso de la segunda, <code>TypedQuery</code> para consultas y <code>Query</code> para actualizaciones y eliminaciones.</p> <pre><code>// creation of Query (q) or TypedQuery (tq)\n\n// \u00fanico resultado\n\n//returno a generic object, and we must cast it.\nObject q.getSingleResult();\n\n// returna un objeto espec\u00edfico\nT tq.getSingleResult();\n\n// un conjunto de resultados\n\n//retorna un List de objetos gen\u00e9ricos que deberemos castear.\nList q.getResultList();\n\n// etorna un List de objetos concretos\nList&lt;T&gt; tq.getResultList();\n\n// para actualizar o eliminar\nq.executeUpdate();\n</code></pre> <p>De forma similar a Hibernate, podemos consultar la base de datos de la siguiente manera:</p> <pre><code>TypedQuery&lt;Alumno&gt; tq=em.createQuery(\"Select from Alumno en where a.ampa=true\", Alumno.class);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre> <p>o con par\u00e1metros:</p> <pre><code>TypedQuery&lt;Alumno&gt; tq=em.createQuery(\"Select a from Alumno a where a.ampa= :ampa\", Alumno.class);\ntq.setParameter(\"ampa\", true);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#51-borrados-y-actualizaciones","title":"5.1. Borrados y Actualizaciones","text":"<p>Por \u00faltimo, revisaremos las \u00faltimas operaciones CRUD que nos quedan. Las actualizaciones son totalmente transparentes para el usuario, ya que cualquier modificaci\u00f3n que se realice dentro del contexto de una transacci\u00f3n se guardar\u00e1 autom\u00e1ticamente cuando se cierre con un <code>commit()</code>. Alternativamente, se pueden realizar consultas de actualizaci\u00f3n.</p> <p>Para las eliminaciones, si el objeto se ha recuperado de la base de datos, y por tanto est\u00e1 en la transacci\u00f3n actual, se puede eliminar con <code>em.remove(object)</code>. Se eliminar\u00e1 de la base de datos cuando se realice el commit.</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#6-ejemplo-con-producto","title":"6. Ejemplo con Producto","text":"<p>No voy a extenderme puesto que casi todos los conceptos son de Hibernate, JPA y JPQL.</p>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#61-pomxml","title":"6.1. pom.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.cipfpcheste.dam2&lt;/groupId&gt;\n    &lt;artifactId&gt;BBDDOO&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;BBDDOO&lt;/name&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;\n        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;\n        &lt;junit.version&gt;5.11.0&lt;/junit.version&gt;\n    &lt;/properties&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;objectdb&lt;/id&gt;\n            &lt;name&gt;ObjectDB Repository&lt;/name&gt;\n            &lt;url&gt;https://m2.objectdb.com&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n            &lt;version&gt;3.2.0-M2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.objectdb&lt;/groupId&gt;\n            &lt;artifactId&gt;objectdb-jk&lt;/artifactId&gt;\n            &lt;version&gt;2.9.4&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.42&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#62-persistencexml","title":"6.2. persistence.xml","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence\n                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\"\n             version=\"2.1\"&gt;\n\n    &lt;persistence-unit name=\"objectdb-unit\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n        &lt;provider&gt;com.objectdb.jpa.Provider&lt;/provider&gt;\n\n        &lt;class&gt;Producto&lt;/class&gt;\n\n        &lt;properties&gt;\n\n            &lt;property name=\"jakarta.persistence.jdbc.url\"\n                      value=\"/home/manu/temp/BBDDOO/bd/testdb.odb\"/&gt;\n\n            &lt;property name=\"jakarta.persistence.jdbc.user\" value=\"admin\"/&gt;\n            &lt;property name=\"jakarta.persistence.jdbc.password\" value=\"admin\"/&gt;\n\n            &lt;property name=\"jakarta.persistence.schema-generation.database.action\"\n                      value=\"create\"/&gt;\n\n            &lt;property name=\"eclipselink.logging.level\" value=\"FINE\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#63-clase-producto","title":"6.3. Clase Producto","text":"<pre><code>import jakarta.persistence.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Entity\n@Table(name = \"productos\")\npublic class Producto {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(name = \"nombre\", nullable = false, length = 100)\n    private String nombre;\n\n    @Column(name = \"precio\", nullable = false)\n    private double precio;\n\n    @Column(name = \"descripcion\", length = 500)\n    private String descripcion;\n\n    public Producto(String nombre, double precio, String descripcion) {\n        this.nombre = nombre;\n        this.precio = precio;\n        this.descripcion = descripcion;\n    }\n}\n</code></pre>"},{"location":"Unidad%204%20BBDDOO/3_OODB/#64-main","title":"6.4. Main","text":"<pre><code>import jakarta.persistence.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Ejemplo de BBDDOO con ObjectDB\");\n        EntityManagerFactory emf = null;\n        EntityManager em = null;\n        try {\n\n            emf = Persistence.createEntityManagerFactory(\"objectdb-unit\");\n            em = emf.createEntityManager();\n\n            // Crear productos\n            Producto portatil = new Producto(\"Asus TUF\", 1299.99, \"Portatil para gamers\");\n            Producto raton = new Producto(\"Rat\u00f3n Inal\u00e1mbrico\", 49.99, \"Rat\u00f3n de baja calidad\");\n            Producto teclado = new Producto(\"Teclado Mec\u00e1nico\", 89.99, \"Teclado mec\u00e1nico RGB\");\n\n            // Persistir (CREATE)\n            EntityTransaction transaction = em.getTransaction();\n            transaction.begin();\n\n            em.persist(portatil);\n            em.persist(raton);\n            em.persist(teclado);\n\n            transaction.commit();\n            System.out.println(\"Productos persistidos: \" + portatil.getId() + \", \" + raton.getId() + \", \" + teclado.getId());\n\n            // Lectura del port\u00e1til\n             Producto busquedaProducto = em.find(Producto.class, portatil.getId());\n            System.out.println(\"Productos: \" + busquedaProducto);\n\n            // Actualizar\n            transaction.begin();\n            busquedaProducto.setPrecio(1199.99);\n            em.merge(busquedaProducto);\n            transaction.commit();\n            System.out.println(\"Producto actualizado: \" + busquedaProducto);\n\n            // Verificar actualizaci\u00f3n\n            Producto productoActualizado = em.find(Producto.class, portatil.getId());\n            System.out.println(\"Precio actualizado verificado: \" + productoActualizado.getPrecio());\n\n            // Realizaci\u00f3n de consultas con JPQL\n\n            System.out.println(\"*\".repeat(100));\n            System.out.println(\"\\n                            --- Prueba de consultas JPQL ---\");\n            System.out.println(\"*\".repeat(100));\n\n            // Consulta todos los productos\n            TypedQuery&lt;Producto&gt; todoslosProductosQuery =\n                    em.createQuery(\"SELECT p FROM Producto p ORDER BY p.precio DESC\", Producto.class);\n            List&lt;Producto&gt; todoslosProductos = todoslosProductosQuery.getResultList();\n\n            System.out.println(\"Todos los productos (\" + todoslosProductos.size() + \"):\");\n            for (Producto producto : todoslosProductos) {\n                System.out.println(\"   - \" + producto);\n            }\n\n            // Consulta con filtro\n            TypedQuery&lt;Producto&gt; productosCarosQuery =\n                    em.createQuery(\"SELECT p FROM Producto p WHERE p.precio &gt; 100\", Producto.class);\n            List&lt;Producto&gt; productosCaros = productosCarosQuery.getResultList();\n\n            System.out.println(\"Productos caros (&gt;100\u20ac): \" + productosCaros.size());\n\n            // Consulta con par\u00e1metros\n            TypedQuery&lt;Producto&gt; QueryParametros =\n                    em.createQuery(\"SELECT p FROM Producto p WHERE p.nombre LIKE :nombre\", Producto.class);\n            QueryParametros.setParameter(\"nombre\", \"%Rat\u00f3n%\");\n            List&lt;Producto&gt; ProductoRaton = QueryParametros.getResultList();\n\n            System.out.println(\"Productos con 'Rat\u00f3n' en el nombre: \" + ProductoRaton.size());\n\n            System.out.println(\"*\".repeat(100));\n\n        } catch (Exception e) {\n            System.err.println(\"Error de ejecuci\u00f3n:\");\n            e.printStackTrace();\n        } finally {\n            // 5. Cerrar recursos\n            if (em != null &amp;&amp; em.isOpen()) {\n                em.close();\n                System.out.println(\"EntityManager cerrado\");\n            }\n            if (emf != null &amp;&amp; emf.isOpen()) {\n                emf.close();\n                System.out.println(\"EntityManagerFactory cerrado\");\n            }\n        }\n    }\n\n}\n</code></pre> <p>Proyecto ejemplo de Producto</p>"},{"location":"Unidad%205%20Spring%20Boot/1_Servicios%20de%20Acceso%20a%20Datos/","title":"1 Servicios de Acceso a Datos","text":""},{"location":"Unidad%205%20Spring%20Boot/1_Servicios%20de%20Acceso%20a%20Datos/#1-introduccion-servicios-de-acceso-a-datos","title":"1. Introducci\u00f3n. Servicios de Acceso a Datos","text":"<p>Un servlet es una aplicaci\u00f3n que se ejecuta en un servidor, preparada para responder a solicitudes http. M\u00e1s tarde tenemos JSP (Java Server Pages), que permiten combinar elementos HTML/XML con fragmentos de c\u00f3digo Java para generar contenido din\u00e1micamente. Debemos lanzar un servidor de aplicaciones y a\u00f1adir la aplicaci\u00f3n para ejecutarla y servirla como otra p\u00e1gina.</p> <p>Podemos utilizar Servlets para escribir una aplicaci\u00f3n web, pero existen muchos detalles intr\u00ednsecos a controlar: validaci\u00f3n, REST, cuerpo de la solicitud/respuesta para JSON, vinculaci\u00f3n de formularios, etc. Esto implica que gran parte de nuestro c\u00f3digo se dedica a controlar las capas inferiores de comunicaci\u00f3n.</p> <p>Con el framework Spring, realmente utilizamos servlets, pero libera al programador de esta tarea pesada, gestion\u00e1ndola autom\u00e1ticamente. Esto permite al programador centrarse en la l\u00f3gica de la aplicaci\u00f3n, sin tener que manejar los niveles inferiores de comunicaciones. Adem\u00e1s, Spring Boot se define como un acelerador de Spring, permiti\u00e9ndonos indicar una serie de convenciones (comportamientos) que realizan tareas pesadas de configuraci\u00f3n de archivos para nosotros. Por \u00faltimo, Spring Boot incorpora un servidor web integrado (normalmente <code>Tomcat</code>).</p> <p>El t\u00e9rmino framework o si intentamos forzar su traducci\u00f3n al Espa\u00f1ol es marco de trabajo  y nos proporciona un conjunto de reglas y herramientas dise\u00f1adas para aumentar la velocidad de desarrollo de aplicaciones.</p>"},{"location":"Unidad%205%20Spring%20Boot/1_Servicios%20de%20Acceso%20a%20Datos/#2-mvc","title":"2. MVC","text":"<p>El Modelo Vista Controlador (MVC) es una arquitectura para el desarrollo de aplicaciones que separa los datos, la interfaz y la l\u00f3gica de control en capas.</p> <p></p> <p>El funcionamiento es el siguiente:</p> <ol> <li>El usuario est\u00e1 utilizando la aplicaci\u00f3n cliente (normalmente un navegador o cliente), y realiza una solicitud a trav\u00e9s del protocolo http, tambi\u00e9n conocida como una HTTP_REQUEST. Estas solicitudes son recibidas por el m\u00f3dulo controlador. El controlador gestiona una lista de operaciones o eventos que puede procesar, determinados por su propio protocolo.</li> <li>En el caso de una solicitud que solicita una consulta o modificaci\u00f3n de los datos, pasamos los par\u00e1metros proporcionados en la solicitud a la capa del modelo. Esta capa accede a los datos, realizando los pasos 3 y 4 a trav\u00e9s de operaciones del SGBD. El Modelo est\u00e1 ahora en condiciones de dar una respuesta.</li> <li>Consultar la base de datos.</li> <li>Recuperaci\u00f3n de la consulta de la base de datos.</li> <li>El modelo transfiere el conjunto de resultados obtenidos a la vista.</li> <li>La vista es responsable de recibir los datos y presentarlos o formatearlos adecuadamente.</li> <li>El controlador devuelve la presentaci\u00f3n generada por la vista (que normalmente ser\u00e1 HTML din\u00e1mico) a la aplicaci\u00f3n cliente, a trav\u00e9s de la solicitud HTTP_RESPONSE.</li> </ol>"},{"location":"Unidad%205%20Spring%20Boot/1_Servicios%20de%20Acceso%20a%20Datos/#3-rest","title":"3. REST","text":"<p>El modelo REST (Representational State Transfer) nos permite proporcionar a nuestro servidor un servicio para recuperar y manipular datos f\u00e1cilmente en el servidor. En este modelo, la parte de la vista se delega al cliente, dejando el controlador y el modelo en el servidor. En este modelo, destacaremos entre otros:</p> <ul> <li>El protocolo sigue el modelo cliente/servidor sin estado, al igual que http, una solicitud s\u00f3lo responder\u00e1 seg\u00fan la informaci\u00f3n recibida en la misma solicitud, sin tener en cuenta todas las anteriores.</li> <li>Soporte de operaciones CRUD, a trav\u00e9s de las especificaciones http equivalentes: GET (consulta), POST (crear), PUT (modificar) y DELETE (eliminar).</li> <li>Disposici\u00f3n del modelo HATEOAS (Hypermedia As Engine Of The Application State). Este principio permite incluir hiperv\u00ednculos como recursos en las respuestas.</li> </ul> <p>En MVC, y de forma simplificada, ser\u00eda eliminar la capa de la vista y devolver los datos procesados \u200b\u200bpor el modelo. Normalmente los servidores REST devuelven datos en formato JSON.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/","title":"2 Spring Spring Boot","text":""},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#1-spring-y-spring-boot","title":"1. Spring y Spring Boot","text":"<p>Spring Framework simplifica el desarrollo de aplicaciones Java, independientemente de si son aplicaciones web ordinarias o aplicaciones web fuera de l\u00ednea. Sus mayores ventajas son un c\u00f3digo fuente m\u00e1s simplificado y menos dificultad en los ajustes. Para ofrecer estas comodidades al programador, el framework se basa en los siguientes principios:</p> <ul> <li> <p>Inyecci\u00f3n de dependencias (DI): t\u00e9cnica o patr\u00f3n de dise\u00f1o utilizado como una de las formas de inversi\u00f3n de control (IOC) para promover un acoplamiento d\u00e9bil. Es decir, cuando una clase necesita otra clase (dependencia), en lugar de crear el objeto dentro de la propia clase, Spring lo suministra o lo inyecta. Esta forma de IOC sigue el principio de Hollywood (no nos llames, ya te llamaremos) en el que la aplicaci\u00f3n toma el control en lugar del c\u00f3digo, proporcionando los siguientes beneficios: </p> </li> <li> <p>Proporciona modularidad. </p> </li> <li>Escalabilidad de la aplicaci\u00f3n sin necesidad de modificar las clases. </li> <li> <p>Evita la dependencia entre clases.</p> </li> <li> <p>Desarrollo sencillo con POJOs (Plain Old Java Objects).</p> </li> <li>Minimiza el c\u00f3digo boilerplate.</li> <li>Simplifica el acceso a los datos gracias a la ORM (Object Relational Mapping).</li> <li>Programaci\u00f3n Orientada a Aspectos (AOP): Permite una modularizaci\u00f3n mucho m\u00e1s alta para hacer una separaci\u00f3n muy clara de las diferentes tareas que cada clase debe realizar en nuestra aplicaci\u00f3n.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#11-modulos-principales-del-spring-framework","title":"1.1. M\u00f3dulos principales del Spring Framework","text":"<p>Gracias a su estructura modular para el desarrollo de las aplicaciones m\u00e1s diversas en Java, Spring es la elecci\u00f3n perfecta, ya que puedes elegir libremente cu\u00e1les de los componentes necesitas utilizar para tus aplicaciones y cu\u00e1les no. En la arquitectura est\u00e1ndar, los distintos m\u00f3dulos se dividen en seis categor\u00edas principales:</p> <p></p> <ul> <li> <p>Core Container: El contenedor principal proporciona los m\u00f3dulos b\u00e1sicos: </p> </li> <li> <p>Core y Beans forman el esqueleto del framework, conteniendo la funci\u00f3n de inyecci\u00f3n de dependencias y apoyando los objetos POJO. Hay que aclarar que un Bean es un POJO, aunque tiene algunas caracter\u00edsticas adicionales. </p> </li> <li>Context hereda sus caracter\u00edsticas del m\u00f3dulo Beans y se puede complementar con funciones para la internacionalizaci\u00f3n o la carga de recursos. Adem\u00e1s, apoya caracter\u00edsticas de Java Enterprise como EJB y JMX (Java Management Extensions). Context-support facilita la integraci\u00f3n de bibliotecas de otros proveedores en Spring. </li> <li> <p>Spring-expression contiene Spring Expression Language (SPeL), una extensi\u00f3n del Unified Expression Language de la especificaci\u00f3n JSP-2.1 (Java Server Pages).</p> </li> <li> <p>AOP e instrumentaci\u00f3n: Para permitir la programaci\u00f3n orientada a aspectos, el Spring Framework contiene el m\u00f3dulo spring-aop. El componente spring-instrument proporciona soporte para la implementaci\u00f3n de carga de objetos y clases de manipulaci\u00f3n para su uso en algunos servidores.</p> </li> <li>Mensajer\u00eda: Para servir como base para aplicaciones basadas en mensajes, Spring Framework se basa en algunas de las funciones de encriptaci\u00f3n del proyecto Spring Integration, como Message, MessageChannel o MessageHandler. Este m\u00f3dulo tiene el nombre de spring-messaging.</li> <li> <p>Acceso a Datos/Integraci\u00f3n: Los m\u00f3dulos de esta categor\u00eda est\u00e1n dise\u00f1ados para dar a las aplicaciones Java las herramientas para interactuar con otras aplicaciones, as\u00ed como controlar el acceso a los datos. </p> </li> <li> <p>spring-jdbc proporciona una capa de abstracci\u00f3n que define la forma en que un cliente accede a la base de datos y ahorra la codificaci\u00f3n complicada t\u00edpica de JDBC. </p> </li> <li>spring-orm ofrece capas de integraci\u00f3n para acceder a bases de datos relacionales en interfaces ORM populares. </li> <li>spring-tx (apoya la gesti\u00f3n de transacciones program\u00e1ticas para todas las clases y POJOs). </li> <li>spring-oxm (capa de abstracci\u00f3n para el mapeo de objetos o XML). </li> <li> <p>spring-jms, un m\u00f3dulo con funciones para la producci\u00f3n y procesamiento de mensajes.</p> </li> <li> <p>Web: en esta categor\u00eda se encuentran los m\u00f3dulos espec\u00edficos para aplicaciones web: spring-web, spring-webmvc y spring-websocket. Adem\u00e1s, esta aplicaci\u00f3n Java ha a\u00f1adido funciones de integraci\u00f3n t\u00edpicas orientadas a la web como una funci\u00f3n de carga multiparte o un cliente HTTP. El m\u00f3dulo spring-webmvc tambi\u00e9n es conocido como web servlet y es el que contiene las implementaciones de Spring para la ejecuci\u00f3n del patr\u00f3n de arquitectura modelo-vista-controlador (MVC) y servicios web REST.</p> </li> <li>Test: el m\u00f3dulo spring-test permite comprobar la funcionalidad de los componentes de tu aplicaci\u00f3n Java. As\u00ed, con ayuda de frameworks adicionales como JUnit o TestNG, puedes realizar pruebas unitarias (centradas en un solo componente) as\u00ed como pruebas de integraci\u00f3n.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#2-spring-vs-spring-boot","title":"2. Spring vs Spring Boot","text":"<p>Spring Boot apareci\u00f3 hace unos a\u00f1os con la idea de complementar a Spring, es decir, a\u00f1adir a Spring, no con la idea de sustituirlo. Como se puede interpretar en la siguiente imagen, Spring Boot realmente funciona con Spring por debajo, pero de una manera m\u00e1s f\u00e1cil.</p> <p></p> <p>Podr\u00edamos definir Spring Boot como un acelerador para la creaci\u00f3n de proyectos Spring, basado principalmente en el concepto de convenci\u00f3n antes de la configuraci\u00f3n. Otra forma de definir Spring Boot podr\u00eda ser como un acelerador de creaci\u00f3n de proyectos Spring. Por tanto, el objetivo es crear proyectos Spring, pero de una manera m\u00e1s \u00e1gil, a trav\u00e9s de una serie de convenciones que prevalecen sobre la configuraci\u00f3n. Ahorr\u00e1ndonos tener que perder tiempo haciendo configuraciones pesadas en archivos.</p> <p>Cabe destacar que Spring Boot no se considera un Framework como tal, sin embargo, Spring s\u00ed tiene el privilegio de categorizarse como tal. Con Spring Boot, podemos hacer lo mismo que con Spring. Pero de una forma m\u00e1s r\u00e1pida que si desarrollamos exclusivamente con Spring s\u00f3lo. Pero con ambos, podr\u00edamos tener el mismo desarrollo, aunque la diferencia entre ambos ser\u00eda el tiempo invertido.</p> <p></p> <p>Para explicar las diferencias entre ambos, es esencial introducir el concepto de convenci\u00f3n de configuraci\u00f3n, que juega un papel tan importante en el campo de la ingenier\u00eda de software.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#21-que-es-la-convencion-de-configuracion","title":"2.1. \u00bfQu\u00e9 es la convenci\u00f3n de configuraci\u00f3n?","text":"<p>Este principio especifica/detalla una serie de convenciones (conjunto de reglas) que estar\u00e1n por encima de la configuraci\u00f3n, a menos que se especifique lo contrario. Es decir, se aplicar\u00e1n por defecto si no especificamos lo contrario.</p> <p>Un ejemplo de una convenci\u00f3n antes de la configuraci\u00f3n podr\u00eda ser cuando creamos una aplicaci\u00f3n MVC con Spring, debemos llevar a cabo muchas configuraciones, incluido el puerto. Por otro lado, si creamos la aplicaci\u00f3n utilizando Spring Boot, gracias a la convenci\u00f3n de configuraci\u00f3n, el puerto por defecto de la aplicaci\u00f3n al iniciarla ser\u00e1 8080. Pero si queremos cambiarlo, s\u00f3lo tenemos que modificar un archivo y a\u00f1adir una sola instrucci\u00f3n donde detallaremos el puerto, por ejemplo, 8888. De esta forma, realizaremos un desarrollo m\u00e1s queramos modificar la configuraci\u00f3n de alguna convenci\u00f3n.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#3-requisitos-e-instalacion","title":"3. Requisitos e Instalaci\u00f3n","text":"<p>Spring funciona con muchas tecnolog\u00edas integradas (a continuaci\u00f3n), as\u00ed que aconsejamos tener lo siguiente para asegurarnos de que todo funcione correctamente. Los requisitos son:</p> <ul> <li>Java instalado, es aconsejable tener la versi\u00f3n 8, debido a su estabilidad. Y que Spring no soporta algunas de las versiones m\u00e1s novedosas de Java.</li> <li>Apache Maven instalado.</li> <li>Un IDE compatible (en este caso ser\u00e1 Spring Tool Suite).</li> </ul> <p>Spring Tool Suite 4, que es el proporcionado desde el sitio web de Pivotal (p\u00e1gina oficial de los creadores y mantenedores de Spring). Se puede descargar desde https://spring.io/tools.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#4-primer-proyecto-y-ejecucion","title":"4. Primer proyecto y ejecuci\u00f3n","text":"<p>Para crear un proyecto Spring, podemos hacerlo de dos maneras:</p> <ul> <li>Crear un proyecto desde Spring Boot Initializer, la herramienta web proporcionada por Pivotal aqu\u00ed https://start.spring.io. Este asistente genera un archivo zip con la estructura del proyecto maven. Necesitamos importar este archivo zip a nuestro IDE para empezar a programar.</li> <li>Crear el proyecto desde el IDE utilizando la herramienta de l\u00ednea de pedidos (CLI), en nuestro caso el IDE escogido ser\u00e1 Spring Tool Suite 4. No necesitamos pasos adicionales para empezar a programar.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#41-inicializar","title":"4.1. Inicializar","text":"<p>Visitamos https://start.spring.io y rellenamos el formulario:</p> <p></p> <p>En la parte de dependencias, deber\u00edamos a\u00f1adir los aspectos de nuestro programa. Inicialmente aplicaci\u00f3n web, pero podr\u00edamos a\u00f1adir Lombok, Thymeleaf y otros aspectos.</p> <p>Aqu\u00ed encontrar\u00e1 varias capturas de pantalla con el proceso. Desde STS, crea un nuevo proyecto: File/New/Spring Starter Project:</p> <p></p> <p>Seleccione un proyecto maven, la versi\u00f3n de Java instalada y escriba informaci\u00f3n sobre la versi\u00f3n del artifact y otros datos:</p> <p></p> <p>Y finalmente seleccione las dependencias. En nuestro proyecto inicial, seleccione Spring web.</p> <p></p> <p>Y cuando el proceso termine, encontrar\u00e1 una estructura de proyecto con un pom.xml configurado.</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#42-primera-ejecucion","title":"4.2. Primera ejecuci\u00f3n","text":"<p>Veamos qu\u00e9 archivos se han creado en nuestro proyecto. Como puede ver, s\u00f3lo una clase con una funci\u00f3n principal:</p> <pre><code>importe org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloSpringApplication { \n\npublic static void main(String[] args) { \nSpringApplication.run(HelloSpringApplication.class, args); \n}\n\n}\n</code></pre> <p>Se ejecutar\u00e1 una <code>SpringApplication</code>, al igual que se ejecuta un <code>Thread</code>. Esta clase inicializa y lanza la aplicaci\u00f3n Spring, con argumentos, si los hubiere.</p> <p>Consejo</p> <p>Spring como aplicaci\u00f3n web, no interact\u00faa con el usuario, y esperar\u00e1 y servir\u00e1 a muchos clientes. Por esta raz\u00f3n, no es una buena idea realizar programas interactivos con usuarios.</p> <p>Para ejecutar nuestra aplicaci\u00f3n Spring:</p> <p></p> <p>Y aparecer\u00e1 en la consola un registro similar a:</p> <p></p> <p>Lo primero que debe ver es el puerto en el que el servidor Tomcat est\u00e1 escuchando. Por defecto es el puerto 8080:</p> <pre><code>... Tomcat started on port(s): 8080 (http) with context path ''\n</code></pre> <p>Y cuando detenemos nuestro programa:</p> <p></p> <p>Consejo</p> <p>Recuerde que es muy \u00fatil leer todos estos mensajes, especialmente cuando algo no funciona como se espera</p> <p>Para mostrar que nuestro programa funciona correctamente, necesitamos probar el puerto espec\u00edfico, y despu\u00e9s ir a nuestro navegador y escribir <code>http://localhost:8080</code>.</p> <p></p> <p>El mensaje de error que obtenemos <code>Whitelabel Error Page</code>, no es un error en absoluto, puesto que no hemos programado ning\u00fan controlador, es decir, el servidor est\u00e1 funcionando, pero no est\u00e1 sirviendo nada.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#43-el-archivo-applicationproperties","title":"4.3. El archivo <code>application.properties</code>","text":"<p>Este archivo contiene muchas configuraciones \u00fatiles que estableceremos a lo largo de nuestro ciclo de desarrollo. Las estudiaremos a medida que aparezcan, pero todas las configuraciones que establecimos en el archivo <code>hibernate.cfg.xml</code> en la unidad 3 se configurar\u00e1n en este archivo.</p> <p></p> <p>Este archivo, como todos los archivos de propiedades, tiene una estructura de pareja atributo-valor. El primer valor importante es cambiar el puerto que escucha nuestro servidor. Este archivo se encuentra en la carpeta <code>src/main/resources</code>. Debemos a\u00f1adir, por ejemplo:</p> <pre><code># puerto de escucha\nserver.port = 8090\n</code></pre> <p>Si volvemos a ejecutar nuestra aplicaci\u00f3n, debemos cambiar el puerto en el navegador para acceder a nuestro servidor.</p> <p>Consejo</p> <p>Puede ver (casi) todas las propiedades visitante esta p\u00e1gina web</p> <p>Podr\u00edamos a\u00f1adir cualquier valor que queramos utilizar, como constantes a utilizar en nuestros programas. Luego podemos cargarlo en nuestros programas. Por ejemplo:</p> <pre><code># App name\nspring.application.name=demo\n</code></pre> <p>para cargarlo en nuestros programas, necesitamos utilizar la anotaci\u00f3n <code>@Value</code>:</p> <pre><code>@Value(\"${app.name}\")\nprivate String appName;\n\n@Value(\"${developer.name}\")\nprivate String devName;\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#44-anotacion-springbootapplication","title":"4.4. Anotaci\u00f3n <code>@SpringBootApplication</code>","text":"<p>En Spring Boot, es muy com\u00fan aplicar m\u00faltiples decoradores a la clase principal. Pero com\u00fanmente, la mayor\u00eda de los desarrolladores principalmente aplican 3 decoradores.</p> <ul> <li><code>@Configuration</code>: Disponible desde la versi\u00f3n 3 de Spring, nos ofrece la posibilidad de realizar una anotaci\u00f3n que se encargar\u00e1 de definir la clase que la posee como una clase de configuraci\u00f3n. Esta configuraci\u00f3n para el framework Spring se basar\u00e1 en apuntes. Y no como en sus or\u00edgenes, que se basaba en XML, lo que lo hac\u00eda m\u00e1s complejo. Otro prop\u00f3sito de esa anotaci\u00f3n ser\u00e1 permitir la inyecci\u00f3n de dependencias.</li> <li><code>@EnableAutoConfiguration</code>: La configuraci\u00f3n autom\u00e1tica de Spring Boot intenta configurar autom\u00e1ticamente tu aplicaci\u00f3n Spring en funci\u00f3n de cualquier dependencia jar que hayas a\u00f1adido. Si, por ejemplo, si pones un HSQLDB (sistema de gesti\u00f3n de bases de datos) en tu classpath, y no has configurado manualmente ning\u00fan bean de conexi\u00f3n a la base de datos, Spring Boot configura autom\u00e1ticamente una base de datos en memoria.</li> <li><code>@ComponentScan</code>: Se utiliza junto con <code>@Configuration</code> para decir a Spring d\u00f3nde buscar los componentes, y ser\u00e1 dentro del paquete que hemos anotado. S\u00f3lo debiendo escribirlo una vez, pudiendo hacer que todos los paquetes sean hijos del paquete de la clase padre (la que contiene el main). B\u00e1sicamente, esto dice en Spring donde debe buscar todos los componentes.</li> </ul> <p>Para poder utilizar este paquete de tres anotaciones, Spring Boot nos ofrece <code>@SpringBootApplication</code> como la uni\u00f3n de las tres anotaciones explicadas anteriormente.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#5-mvc-con-spring","title":"5. MVC con Spring","text":""},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#51-controladores","title":"5.1. Controladores","text":"<p>Un controlador es responsable de responder a eventos. Normalmente, estos eventos son acciones (m\u00e1s t\u00e9cnicamente conocidas como solicitudes) que suelen ser realizadas por el usuario, aunque tambi\u00e9n pueden ser solicitudes m\u00e1s automatizadas como API, p\u00e1ginas frontales Ajax, etc.</p> <p>En un contexto de la vida real, un controlador es como un camarero; \u00c9l o ella est\u00e1 esperando detr\u00e1s de la barra hasta que llegue un cliente. El cliente pide una coca-cola, y el camarero, si la tiene, la servir\u00e1. Luego llega otro cliente, y pide un caf\u00e9, y entonces el camarero le sirve. Otro cliente llega, y pide un t\u00e9 verde, y el camarero dice que no puede servirlo, porque no tiene. Una y otra vez... El camarero servir\u00e1 todo lo que el cliente quiera, si puede.</p> <p></p> <p>Volviendo a Spring debemos a\u00f1adir a nuestro programa un m\u00f3dulo que funcione como un controlador, escuchando todas las solicitudes de los clientes, y respondiendo (si puede) con los datos que el cliente solicita.</p> <p></p> <p>Recuerde el error en la primera ejecuci\u00f3n de Spring: la aplicaci\u00f3n Spring funciona bien, pero todav\u00eda no tenemos un controlador. Vamos.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#52-paquete-controllers","title":"5.2. Paquete <code>controllers</code>","text":"<p>Vamos a crear un controlador, pero primero, debemos crear un paquete que contenga ese controlador. Antes habl\u00e1bamos de la anotaci\u00f3n <code>@SpringBootApplication</code> que dijimos que era equivalente a tener 3 anotaciones. Una de ellas era <code>@ComponentScan</code>. Si no queremos tener que decirle que escanee varios paquetes (que normalmente es la mejor idea), normalmente ponemos toda la estructura de paquetes dentro del paquete <code>padre</code>, que ser\u00e1 el paquete donde tenemos el main.</p> <p>Para ello, haga clic derecho sobre el paquete que contiene el main. De esta forma, cuando vamos a poner el nombre directamente nos aparecer\u00e1 el com.example y s\u00f3lo deberemos a\u00f1adir un <code>.</code> y el nombre del paquete hijo. Si no, deber\u00edamos escribir el nombre completo del paquete. Como puede ver, el paquete blanco nos indica que es un paquete vac\u00edo en lugar del paquete marr\u00f3n.</p> <p></p> <p>Vamos a crear una clase sencilla que controle el \u00edndice de nuestra aplicaci\u00f3n. Por esta raz\u00f3n, debemos nombrar a nuestra clase como <code>indexController.java</code>. Recuerde que \u00edndice se refiere al dominio principal de nuestro servidor/app.</p> <p>Consejo</p> <p>Es una buena pr\u00e1ctica establecer nombres de clase siguiendo reglas sencillas para entender el comportamiento de la clase. As\u00ed, una clase llamada <code>clientController</code> es el controlador que mapeo informaci\u00f3n sobre <code>Client</code>, y <code>filmController.java</code> trata sobre <code>Films</code>.</p> <p>Una vez nuestra clase ha sido creada, dentro del paquete controlador, debemos configurarla. Veamos un ejemplo de <code>indexController.java</code>:</p> <pre><code>package com.example.demo.controllers;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class indexController { \n\n@GetMapping(\"/\") \n@ResponseBody \npublic String helloWorld() { \n    return \"Hello from Spring\"; \n}\n\n}\n</code></pre> <p>Vea nuestras anotaciones: </p> <ul> <li><code>@Controller</code> \u2192 dice a Spring que esta clase es un controlador. Es una especializaci\u00f3n de <code>@Component</code>, y dado que Spring explora todo el classpath, se detecta autom\u00e1ticamente. </li> <li><code>@GetMapping(\"/\")</code> \u2192 es el controlador. Definimos un camino (<code>\"/\"</code>) en nuestro servidor, y escuchamos el m\u00e9todo <code>GET</code>. Hablaremos m\u00e1s adelante. </li> <li><code>@ResponseBody</code> \u2192 dice al controlador que serialice el valor de retorno (una cadena en nuestro ejemplo) a JSON y lo env\u00ede a trav\u00e9s de <code>http_response</code> al cliente que llama al controlador.</li> </ul> <p>Ahora, si intentamos recargar la p\u00e1gina en el navegador, en lugar de un mensaje de error, obtendremos el valor devuelto por el controlador:</p> Antes del controlador <p></p> Despu\u00e9s del controlador <p></p> <p>Otra forma de obtener el mismo resultado ser\u00eda:</p> <pre><code>package com.example.demo.controllers;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class indexController { \n\n@GetMapping(\"/\") \npublic String helloWorld() { \nreturn \"Hello from Spring\"; \n}\n\n}\n</code></pre> <p>d\u00f3nde: </p> <ul> <li><code>@RestController</code> \u2192 indica que en esta clase todos los m\u00e9todos incluyen la anotaci\u00f3n <code>@ResponseBody</code>. Ten cuidado, ya que todos los m\u00e9todos devolver\u00e1n un objeto JSON, y en algunos casos (cuando enviamos datos a vistas en otro formato), puede ser una mala idea.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#53-solicitudes-y-parametros","title":"5.3. Solicitudes y Par\u00e1metros","text":"<p>Atenci\u00f3n</p> <p>Para probar nuestra solicitud, a partir de ahora utilizaremos POSTMAN https://www.postman.com/downloads/. Existe un ap\u00e9ndice sobre el uso de postman.</p> <p>A\u00f1adimos un poco de inteligencia a una ruta del controlador, d\u00e1ndole algo de dinamismo a trav\u00e9s del paso de par\u00e1metros. Estos par\u00e1metros ser\u00e1n aceptados gracias a la anotaci\u00f3n <code>@RequestParam</code>.</p> <p>El n\u00famero de par\u00e1metros que recibiremos ser\u00e1 igual al n\u00famero de par\u00e1metros que hemos definido dentro de la anotaci\u00f3n <code>@RequestParam</code> del m\u00e9todo de la ruta del controlador, de la siguiente forma:</p> <pre><code>package com.example.demo.controllers;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class indexController { \n    @GetMapping(\"/hola\") \n    @ResponseBody \n    public String hola(@RequestParam String name) { \n        return \"Hola \"+ name +\" desde Spring !!!\"; \n    }\n}\n</code></pre> <p>Esto significa que una solicitud de <code>GET /hola</code> necesitar\u00e1 un par\u00e1metro (<code>name</code>) con su valor. Por ejemplo <code>http://localhost:9090/hola?name=Manu</code>.</p> <p>Tenga en cuenta que si no a\u00f1adimos el par\u00e1metro, la solicitud ser\u00e1 incorrecta. Podr\u00edamos solucionarlo, estableciendo este par\u00e1metro como no requerido y un valor por defecto, de la siguiente forma:</p> <pre><code>@GetMapping(\"/hola\")\n@ResponseBody\npublic String hola(@RequestParam(required = false,defaultValue = \"desconocido\") String name) { \nreturn \"Hola \"+ name +\" desde Spring !!!\";\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#54-logger","title":"5.4. Logger","text":"<p>Una buena idea tambi\u00e9n es utilizar <code>Logger</code> para mostrar qu\u00e9 est\u00e1 pasando en nuestro servidor. Podemos utilizarlo como sugerimos:</p> <pre><code>package com.example.demo.controllers;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n@Controller\npublic class indexController { \n    private static final Logger myLog=LoggerFactory.getLogger(indexController.class);\n    @GetMapping(\"/hola\") \n    @ResponseBody \n    public String hola(@RequestParam(required = false,defaultValue = \"desconocido\") String name) { \n        // check specific situations\n        if (name==null) { \n        myLog.warn(\"Name parameter dos not exists\");\n        }\n        else { \n        myLog.info(name + \" is here\");\n        }\n\n        return \"Hola \"+ name +\" desde Spring !!!\"; \n    }\n}\n</code></pre> <p><code>Logger</code> nos ofrece mostrar cada tipo de mensaje:</p> <ul> <li><code>void error(String msg)</code></li> <li><code>void warn(String msg)</code></li> <li><code>void info(String msg)</code></li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#55-parametros-multiples","title":"5.5. Par\u00e1metros m\u00faltiples","text":"<p>Vamos a estudiar c\u00f3mo obtener varios par\u00e1metros, aunque no se recomienda m\u00e1s de tres o cuatro, porque los psth aumentan mucho, y existen mejores m\u00e9todos para pasar datos al servidor, como objetos en la solicitud BODY desde formularios o datos dentro de los path. Un ejemplo cl\u00e1sico es el siguiente:</p> <pre><code>package com.example.demo.controllers;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport jakarta.servlet.http.HttpServletRequest;\n\nimport java.util.Calendar;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n@Controller\npublic class indexController {\n    private static final Logger myLog=LoggerFactory.getLogger(indexController.class);\n\n    @Autowired\n    private HttpServletRequest context;\n\n    @GetMapping(\"/born\")\n    @ResponseBody\n    public String born( \n            @RequestParam(required=true,defaultValue = \"unknown\") String name, \n            @RequestParam(required=true,defaultValue = \"1970\") int year \n            ) { \n        int currentYear = Calendar.getInstance().get(Calendar.YEAR); \n        myLog.info(\"Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort()); \n        return \"\" + name + \" you have \" + (currentYear-year);\n    }\n\n}\n</code></pre> <p>ten en cuenta que:</p> <ul> <li>Aunque los valores por defecto podr\u00edan ser enteros o reales, debemos definirlos como cadenas.</li> <li>La variable <code>HttpServletRequest</code> definida se utiliza para obtener informaci\u00f3n adicional sobre la solicitud http recibida.</li> </ul> <p>Importante</p> <p><code>@Autowired</code> es una de las anotaciones m\u00e1s utilizadas. Esta anotaci\u00f3n permite realizar la inyecci\u00f3n de dependencias. Esto significa que Spring buscar\u00e1 una clase dentro del contexto de la aplicaci\u00f3n que coincida con el bean deseado, crear\u00e1 una nueva instancia y la inyectar\u00e1 dentro del bean que posee la inyecci\u00f3n.</p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#56-solicitud-post","title":"5.6. Solicitud POST","text":"<p>Aparte de GET, podemos hacer solicitudes POST, PUT, DELETE y m\u00e1s en nuestro servidor. Simplemente debemos sustituir <code>@GetMapping</code> por <code>@PostMapping</code>, con la correspondiente importaci\u00f3n. De hecho, como son rutas diferentes, incluso si se llaman igual, podr\u00edan estar en el mismo archivo sin ning\u00fan problema.</p> <pre><code>@PostMapping(\"/born\")\n@ResponseBody\npublic String post( \n@RequestParam(required=true,defaultValue = \"unknown\") String name, \n@RequestParam(required=true,defaultValue = \"1970\") int year \n) {\n</code></pre> <p>Dado que las solicitudes POST suelen ser llamadas dentro de un formulario, es una buena idea establecer el par\u00e1metro en la secci\u00f3n del cuerpo de la solicitud. Para ello, debemos configurar la secci\u00f3n BODY de POSTMAN, seleccionar <code>www-form-urlencoded</code> y establecer los par\u00e1metros.</p> <p>Si queremos un n\u00famero ilimitado de par\u00e1metros, podemos crear una matriz y crear m\u00faltiples par\u00e1metros en POSTMAN con el mismo nombre:</p> <pre><code>    @PostMapping(\"/lotes\")\n    @ResponseBody\n    public String lotes(@RequestParam String [] params) {\n      String res=\"\";\n      myLog.info(\"POST Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n      if(params==null || params.length==0)\n        res= \"A POST request without params.\";\n      else {\n        res=\"The list of params is:\\n\";\n        for (String param : params) {\n          res+=param+\"\\n\";\n        }\n        res=res.substring(0, res.length()-1);\n      }\n\n      return res;\n    }\n</code></pre> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/2_Spring_Spring%20Boot/#57-variables-en-el-path","title":"5.7. Variables en el path","text":"<p>Si queremos obtener un valor espec\u00edfico, en forma de valor en el camino, por ejemplo <code>GET films/1</code> en lugar de <code>GET films?idFilm=1</code>, la forma es la siguiente:</p> <pre><code>@GetMapping(\"/who/{idWho}\")\n@ResponseBody\npublic String who(@PathVariable String idWho) { \n    myLog.info(\"GET Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort()); \n    return \"You are looking for \" + idWho;\n}\n</code></pre> <p>La petici\u00f3n responde:</p> <p></p> <p>C\u00f3mo podemos ver:</p> <ul> <li>En la aplicaci\u00f3n establecemos en el camino el par\u00e1metro <code>idWho</code>.</li> <li>En el controlador definimos el par\u00e1metro como String para poder acceder desde nuestro m\u00e9todo.</li> <li>Al realizar la petici\u00f3n, el valor se asigna desde la petici\u00f3n al par\u00e1metro de la funci\u00f3n.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/","title":"3 API Rest","text":""},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#1-niveles-capas-de-spring","title":"1. Niveles (capas) de Spring","text":"<p>Estamos aprendiendo sobre algunos patrones de dise\u00f1o que vamos a utilizar en nuestra aplicaci\u00f3n, y que son necesarios para definir una arquitectura correcta en una aplicaci\u00f3n Spring. Por tanto, lo primero que haremos es definir las capas de la estructura de nuestra aplicaci\u00f3n, y una vez las definimos, definiremos nuevos patrones de dise\u00f1o que integraremos en nuestra aplicaci\u00f3n.</p> <p>La idea es crear una estructura de paquetes que agrupe a las clases en 6 paquetes principales: paquete que contiene la clase principal, capa web que contiene los controladores, capa de acceso a datos que contiene el repositorio, capa de servicio, capa de modelo de datos y capa dto. Todos ellos est\u00e1n incluidos, b\u00e1sicamente en 3: web, servicio y repositorio.</p> <p>El objetivo es que, con una arquitectura bien definida y ensamblada, sea posible utilizar la Inyecci\u00f3n de Dependencias, ya que facilitar\u00e1 la comunicaci\u00f3n y el acceso entre las diferentes capas.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#11-clase-main","title":"1.1. Clase Main","text":"<p>Cada aplicaci\u00f3n Java debe contener una clase principal con un m\u00e9todo main. Este m\u00e9todo, en caso de implementar una aplicaci\u00f3n con Spring, debe llamar al m\u00e9todo run de la clase <code>SpringApplication</code>. Dejaremos esta clase en la ra\u00edz por defecto, de modo que siempre la tendremos en el mismo sitio.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#12-capa-web-capa-de-controladores","title":"1.2. Capa Web. Capa de Controladores","text":"<p>Ahora vamos a definir el comportamiento de la aplicaci\u00f3n implementando el resto de las clases. Comenzaremos con la capa de m\u00e1s alto nivel, la capa de controladores, donde expondremos los servicios de la aplicaci\u00f3n. En nuestra aplicaci\u00f3n se llamar\u00e1 <code>Controller</code>.</p> <p>Esta capa b\u00e1sicamente contendr\u00e1 3 partes:</p> <ul> <li>Servicios web consumidos por aplicaciones (servicio REST o SOAP).</li> <li>Vistas implementadas con JSP, JSF, Thymeleaf, etc. \u00c9ste es nuestro caso principal, aunque tambi\u00e9n crearemos servicios REST.</li> <li>Vistas con frameworks como Vaadin, Wicket, ZK, etc.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#13-capa-de-servicios","title":"1.3. Capa de Servicios","text":"<p>Capa que se encarga de implementar la l\u00f3gica de negocio, esto es, todas las tareas que nuestro sistema es capaz de realizar. Es la elaboraci\u00f3n de lo que ofrece el controlador.</p> <p>\u00c9sta es una de las capas m\u00e1s importantes ya que aqu\u00ed se llevar\u00e1n a cabo todas las operaciones de validaci\u00f3n de datos que hacen referencia a la l\u00f3gica de negocio (por ejemplo, comprobar que una cuenta corriente tiene saldo al realizar un pago) y la seguridad. Se llamar\u00e1 <code>service</code>.</p> <p>Normalmente, acceden a los datos almacenados en la base de datos de la aplicaci\u00f3n a trav\u00e9s de los repositor\u00edas, realizan una serie de operaciones y env\u00edan los datos al controlador. Podemos encontrar los siguientes tipos de servicio:</p> <ul> <li>Servicios de Integridad de Repositorios: se encargan de consumir informaci\u00f3n del repositorio. Son servicios f\u00e1ciles de implementar (por ejemplo, solicitar una lista de clientes).</li> <li>Servicios de Operabilidad de Negocio: realizan operaciones espec\u00edficas para el flujo de negocio (realizan operaciones complejas para completar una transacci\u00f3n, como una venta, almacenar un pedido, etc.).</li> <li>Servicios de Seguridad: dedicados a realizar operaciones de seguridad.</li> <li>Servicios de Gesti\u00f3n: dedicados a generar informes y/o estad\u00edsticas.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#14-capa-de-repositorio","title":"1.4. Capa de Repositorio","text":"<p>Los repositorios son las clases encargadas de gestionar el acceso a los datos. Normalmente contienen clases que realizan operaciones CRUD utilizando s\u00f3lo una clase de entidad de un modelo de dominio. Se llamar\u00e1 <code>repository</code>. Pueden contener operaciones de dos modelos.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#15-capa-de-modelo","title":"1.5. Capa de Modelo","text":"<p>Contendr\u00e1 los mapeos de las tablas de la base de datos en clases que representan entidades. La capa se llamar\u00e1 <code>modelo</code>.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#16-capa-dto","title":"1.6. Capa DTO","text":"<p>Los controladores normalmente gestionan <code>DTO</code> en lugar de pojos o beans, debido a la estructura de la API o la representaci\u00f3n en vistas. Por tanto, necesitaremos implementar una conversi\u00f3n bidireccional entre un pojo y un modelo DTO. M\u00e1s adelante definiremos, en los patrones de dise\u00f1o, qu\u00e9 es un DTO y veremos la conversi\u00f3n bidireccional, llamada mapeo. Adem\u00e1s, estos DTO estar\u00e1n en una capa separada llamada <code>dto</code>.</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#2-patrones-de-diseno","title":"2. Patrones de Dise\u00f1o","text":"<p>Un patr\u00f3n de dise\u00f1o es una soluci\u00f3n probada que resuelve un tipo espec\u00edfico de problema de dise\u00f1o en el desarrollo de software. Existen muchos patrones de dise\u00f1o que se dividen en categor\u00edas, por ejemplo: creaci\u00f3n, estructural, comportamental, interacci\u00f3n, etc.</p> <p>\u00bfPor qu\u00e9 utilizar patrones de dise\u00f1o?: Permiten tener el c\u00f3digo bien organizado, legible y mantenible, tambi\u00e9n permiten reutilizar c\u00f3digo y aumentan la escalabilidad en tu proyecto.</p> <p>En s\u00ed mismos proporcionan una terminolog\u00eda est\u00e1ndar y un conjunto de buenas pr\u00e1cticas en lo que respecta a la soluci\u00f3n de problemas de desarrollo de software.</p> <p>Vamos a explicar varios para empezar a entender qu\u00e9 son los patrones de dise\u00f1o.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#21-patron-mvc","title":"2.1. Patr\u00f3n MVC.","text":"<p>Ya hemos explicado este patr\u00f3n en el tema anterior, pero le realizaremos una peque\u00f1a revisi\u00f3n.</p> <p>Permite separar una aplicaci\u00f3n en 3 capas, una forma de organizar y hacer un proyecto escalable. Las capas que podemos encontrar son:</p> <ul> <li>Modelo: Esta capa representa todo lo que tiene en ver con el acceso a datos: guardar, actualizar, obtener datos, as\u00ed como todo el c\u00f3digo de la l\u00f3gica de negocio, b\u00e1sicamente las clases Java y parte de la l\u00f3gica de negocio.</li> <li>Vista: La vista tiene que ver con la presentaci\u00f3n de datos del modelo y lo que el usuario ve, normalmente una vista es la representaci\u00f3n visual de un modelo (POJO o clase Java). Por ejemplo, el modelo de usuario, que es una clase en Java y cuyas propiedades son nombre y apellido, debe pertenecer a una vista en la que el usuario final ve estas propiedades.</li> <li>Controlador: El controlador se encarga de conectar el modelo con las vistas, funciona como un puente entre la vista y el modelo, el controlador recibe eventos generados por el usuario desde las vistas y se encarga de dirigir la solicitud respectiva al modelo. Por ejemplo, el usuario quiere ver a los clientes con el apellido \u00c1lvarez, la solicitud va al controlador y \u00e9ste se encarga de utilizar el modelo adecuado y devolver ese modelo a la vista.</li> </ul> <p>En ning\u00fan momento la vista interactuar\u00e1 directamente con el modelo, lo que tambi\u00e9n mantiene la seguridad en una aplicaci\u00f3n.</p> <p>Lo importante de este patr\u00f3n es que permite dividirlo en partes, que son de alg\u00fan modo independientes, as\u00ed que si, por ejemplo, se hace un cambio en el modelo, no afectar\u00eda a la vista o si hay un cambio, ser\u00eda m\u00ednimo.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#22-patron-dto","title":"2.2. Patr\u00f3n DTO.","text":"<p>Con este patr\u00f3n se dise\u00f1a una de las capas transversales de la arquitectura. Soluciona el problema de c\u00f3mo permitir a un cliente intercambiar datos con el servidor sin realizar m\u00faltiples llamadas pidiendo cada pieza de dato. Por ejemplo, si tenemos una entidad llamada Persona y una entidad llamada Direcciones, cuando pedimos las personas y sus direcciones debemos realizar m\u00faltiples llamadas al servidor para pedir las personas y las direcciones de cada persona, construyendo la vista con esta informaci\u00f3n.</p> <p>El DTO lo soluciona pasando un objeto ligero al cliente con todos los datos necesarios, juntos. El cliente puede entonces hacer peticiones locales en el objeto que ha recibido.</p> <p>Para ello, se crean clases Java que encapsulan los datos en un paquete que se puede transportar por la red (pueden implementar <code>java.io.Serializable</code>, aunque no es obligatorio), es decir, con el ejemplo anterior, crear\u00edamos una clase Java que llevar\u00eda a la persona y sus direcciones, junto con el mismo objeto.</p> <p>Estos objetos se utilizan en todas las capas de la aplicaci\u00f3n, por lo que la informaci\u00f3n se lleva por todas las capas de la aplicaci\u00f3n. Se recomienda llenar siempre todos los campos del DTO para evitar errores de <code>NullPointerException</code> (una cadena vac\u00eda puede ser mejor), hacer que los DTO sean autodescriptivos, utilizar arrays o colecciones de DTO cuando sea necesario, y considerar m\u00e9todos que sobreescriban <code>equals()</code>.</p> <p>Hay dos variantes de DTO's:</p> <ul> <li>DTOs personalizados que representan parte de un bean o agrupan m\u00faltiples beans.</li> <li>DTOs de dominio llamados \"entidades\". Una clase de dominio no es directamente accesible por el cliente, ya que debido a la separaci\u00f3n del patr\u00f3n MVC de la vista, las entidades que mapean la base de datos (que son las entidades) no pueden ser accedidas. Por esta raz\u00f3n, se realizan copias DTO de los objetos de dominio del servidor (entidades). Los clientes pueden operar sobre copias locales mejorando el rendimiento de lectura y actualizaci\u00f3n.</li> </ul> <p>Con todo ello, podemos resumir que el DTO es un patr\u00f3n muy efectivo para transmitir informaci\u00f3n entre un cliente y un servidor, puesto que nos permite crear estructuras de datos independientes de nuestro modelo de datos (Entidades), lo que nos permite crear tantas \"vistas\" como sea necesario. A partir de un conjunto de tablas o fuentes de datos. Adem\u00e1s, nos permite controlar el formato, nombre y tipos de datos con los que transmitimos los datos para ajustarnos a un determinado requisito. Por \u00faltimo, si por alguna raz\u00f3n el modelo de datos cambia (y con \u00e9l las entidades) el cliente no se ver\u00e1 afectado, ya que seguir\u00e1 recibiendo el propio DTO.</p> <p>A continuaci\u00f3n veremos c\u00f3mo implementar el patr\u00f3n DTO.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#23-patron-dao","title":"2.3. Patr\u00f3n DAO","text":"<p>El patr\u00f3n Data Access Object (DAO), que permite separar la l\u00f3gica de acceso a datos de los Objetos de Negocio, de modo que el DAO encapsula toda la l\u00f3gica de acceso a datos para el resto de la aplicaci\u00f3n. Esta propuesta propone separar completamente la l\u00f3gica de negocio de la l\u00f3gica de acceso a datos, de esta forma, el DAO proporcionar\u00e1 los m\u00e9todos necesarios para insertar, actualizar, eliminar y consultar la informaci\u00f3n; por otra parte, la capa de negocio s\u00f3lo se preocupa por la l\u00f3gica de negocio y utiliza el DAO para interactuar con la fuente de datos. En el ejemplo que dise\u00f1aremos a continuaci\u00f3n, veremos c\u00f3mo implementar el patr\u00f3n DAO.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#24-patron-facade-fachada","title":"2.4. Patr\u00f3n FACADE (fachada)","text":"<p>El patr\u00f3n de dise\u00f1o Facade simplifica la complejidad de un sistema mediante una interfaz m\u00e1s sencilla. Mejora el acceso a nuestro sistema permitiendo que otros sistemas o subsistemas utilicen un punto de acceso com\u00fan que reduce la complejidad, minimizando las interacciones y dependencias. Es decir, crearemos una interfaz Java que tendr\u00e1 los encabezados de los m\u00e9todos como punto de acceso com\u00fan , mientras que habr\u00e1 clases Java que implementar\u00e1n esta interfaz.</p> <p>A lo largo de este ejemplo utilizaremos este patr\u00f3n.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#3-creacion-del-proyecto-y-configuracion-de-hibernate","title":"3. Creaci\u00f3n del proyecto y configuraci\u00f3n de Hibernate","text":"<p>En esta secci\u00f3n crearemos un programa sencillo de Hibernate con Spring, para aplicar todo lo estudiado en unidades anteriores con Spring. S\u00f3lo debemos crear un nuevo proyecto, seleccionando las dependencias que normalmente utilizamos:</p> <p></p> <p>Esto generar\u00e1 un <code>pom.xml</code> con todo lo que necesitamos.</p> <p>Necesitamos establecer los par\u00e1metros que establecimos en <code>hibernate.cfg.xml</code> en el archivo <code>application.properties</code>:</p> <pre><code>app.name = AD.UD5.REST\ndeveloper.name = Manu\nserver.port = 8090\n\n# Conexi\u00f3n con la BBDD\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# Datos del SGBD. REVISAR!!!!\nspring.datasource.url = jdbc:mysql://localhost:3308/AD_UD5_Clientes\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n# configuraci\u00f3n hibernate (simple)\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQLDialect\n\n# hbm2DDL. values= none, validate, update, create, and create-drop\nspring.jpa.hibernate.ddl-auto=validate\n\n# import.sql file under src/main/resources/\n# or data.sql or schema.sql\n\n# respetar may\u00fasculas y min\u00fasculas\nspring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n</code></pre> <p>Importante</p> <p>Todas las opciones de inicializaci\u00f3n de la base de datos se pueden encontrar en inicializaci\u00f3n de la base de datos.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#31-el-modelo","title":"3.1. El modelo.","text":"<p>Vamos a utilizar este modelo para nuestra pr\u00e1ctica:</p> <p></p> <p>Advertencia</p> <p>Tienes un script para crear la base de datos completa enlazado aqu\u00ed. En esta unidad no implementamos sobre <code>Movimientos</code>.</p> <p>Para crear el modelo debemos crear los Beans que creamos en la unidad 3. Podemos utilizar Lombok para mejorar nuestro tiempo de desarrollo.</p> <p>Consejo</p> <p>Puedes marcar un atributo con la anotaci\u00f3n de Lombok <code>@ToString.Exclude</code> para evitar que participe en el m\u00e9todo <code>toString</code>, por ejemplo, para evitar la recursi\u00f3n.</p> <p><code>Cliente</code> DAO en el paquete <code>modelo</code>:</p> <pre><code>package com.manu.model;\n\nimport java.util.List;\n\nimport jakarta.persistence.CascadeType;\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.FetchType;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.OneToOne;\nimport jakarta.persistence.Table;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"clientes\")\npublic class Cliente {\n\n    @Id\n    @GeneratedValue( strategy=GenerationType.IDENTITY)\n    private Integer id;\n\n    @Column(name = \"nif\")\n    private String nif;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n    private String apellidos;\n\n    @Column(name = \"claveseguridad\")\n    private String claveSeguridad;\n    private String email;\n\n    @OneToOne(fetch = FetchType.LAZY, \n            cascade =  CascadeType.ALL, \n            mappedBy = \"cliente\")\n    @ToString.Exclude\n    private Recomendacion recomendacion;\n\n    @OneToMany(fetch = FetchType.LAZY, \n            cascade = CascadeType.ALL, \n            mappedBy = \"cliente\")\n    @ToString.Exclude\n    private List&lt;Cuenta&gt; listaCuentas;\n\n  @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.ALL})\n  @JoinTable(name=\"clientesdirecciones\", \n              joinColumns=@JoinColumn(name=\"idcliente\"),\n              inverseJoinColumns=@JoinColumn(name=\"iddireccion\"))\n  @ToString.Exclude\n  private List&lt;Direccion&gt; listaDirecciones;\n\n\n\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#32-el-dto","title":"3.2. El DTO","text":"<p>Los DTO's (Data Transfer Object) sirven para transferir datos en nuestro sistema a trav\u00e9s de transacciones realizadas por nuestras entidades de una operaci\u00f3n a otra sin perder la integridad entre los datos.</p> <p>Por esta raz\u00f3n, es importante definir que el acceso a los datos se realiza s\u00f3lo a trav\u00e9s de DAO (Data Access Object) de nuestro <code>modelo</code>, obteniendo as\u00ed una abstracci\u00f3n del modelo de datos. Los datos s\u00f3lo se acceden a trav\u00e9s de m\u00e9todos definidos en el <code>DAO</code>. Los DAOs incluyen otro concepto que es el DTO (Data Transfer Object). Los DTO son una clase de objetos que sirven \u00fanicamente para transportar datos. El DTO contiene las propiedades del objeto. Datos que pueden originarse a partir de una o m\u00e1s entidades de informaci\u00f3n.</p> <p>Otra buena pr\u00e1ctica es marcar las clases con el sufijo DTO para recordar su significado, as\u00ed la clase <code>Cliente</code> se convertir\u00eda en <code>ClienteDTO</code>.</p> <p>Una de las caracter\u00edsticas de los DTO's es que deben ser objetos <code>Serializable</code> para poder viajar a trav\u00e9s de la red. Necesitamos indicar esta caracter\u00edstica en los DTO, as\u00ed que a\u00f1adiremos que implementen la interfaz Serializable, y con ello, la propiedad <code>UID</code> que identifica la versi\u00f3n de cada objeto transportado.</p> <p>Para crear un DTO vamos a crear una clase con los atributos que queremos que contenga el DTO. Puede ser m\u00e1s o menos que la clase DAO. Luego es importante crear m\u00e9todos para convertir tanto de DAO a DTO como de DTO a DAO. Estos m\u00e9todos se pueden crear de forma est\u00e1tica.</p> <pre><code>package com.manu.dto;\n\nimport com.manu.model.Cliente;\nimport com.manu.model.Cuenta;\nimport com.manu.model.Direccion;\nimport com.manu.model.Recomendacion;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.util.List;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class ClienteDTO {\n\n    private Integer idCliente;  // &lt;- corregido\n\n    private String nif;\n    private String nombre;\n    private String apellidos;\n    private String claveSeguridad;\n    private String email;\n    private Recomendacion recomendacion;\n    private List&lt;Cuenta&gt; listaCuentas;\n    private List&lt;Direccion&gt; direcciones;\n\n    public static ClienteDTO convertToDTO(Cliente cliente) {\n        ClienteDTO clienteDTO = new ClienteDTO();\n        clienteDTO.setIdCliente(cliente.getId());\n        clienteDTO.setNif(cliente.getNif());\n        clienteDTO.setNombre(cliente.getNombre());\n        clienteDTO.setApellidos(cliente.getApellidos());\n        clienteDTO.setClaveSeguridad(cliente.getClaveSeguridad());\n        clienteDTO.setEmail(cliente.getEmail());\n        clienteDTO.setRecomendacion(cliente.getRecomendacion());\n        clienteDTO.setListaCuentas(cliente.getListaCuentas());\n        clienteDTO.setDirecciones(cliente.getListaDirecciones());\n        return clienteDTO;\n    }\n\n    public static Cliente convertToEntity(ClienteDTO clientedto) {\n        Cliente cliente = new Cliente();\n        cliente.setId(clientedto.getIdCliente());\n        cliente.setNif(clientedto.getNif());\n        cliente.setNombre(clientedto.getNombre());\n        cliente.setApellidos(clientedto.getApellidos());\n        cliente.setClaveSeguridad(clientedto.getClaveSeguridad());\n        cliente.setEmail(clientedto.getEmail());\n        cliente.setRecomendacion(clientedto.getRecomendacion());\n        cliente.setListaCuentas(clientedto.getListaCuentas());\n        cliente.setRecomendacion(clientedto.getRecomendacion());\n        return cliente;\n    }\n}\n</code></pre> <p>Como hemos dicho, evitamos acceder a las entidades desde capas superiores.</p> <p>Ampliaci\u00f3n</p> <p>Puedes buscar en internet informaci\u00f3n sobre <code>ModelMapper</code> para gestionar los DTO</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#321-convirtiendo-dto-a-json","title":"3.2.1. Convirtiendo DTO a JSON","text":"<p>Como hemos dicho, estos objetos (DTO's) se convierten a JSON autom\u00e1ticamente, pero \u00bfc\u00f3mo? Spring utiliza Jackson object mapper para transformar objetos a objetos JSON. En este tutorial puedes entender mejor c\u00f3mo funciona.</p> <p>Convertir objetos a JSON puede llevarnos a otro problema de recursi\u00f3n infinita, cuando el objeto contiene referencias cruzadas, como los m\u00e9todos <code>toString()</code>. Hemos aprendido c\u00f3mo evitar la excepci\u00f3n <code>StackOverflowException</code> en los m\u00e9todos <code>toString()</code>, utilizando la anotaci\u00f3n <code>@ToString.Exclude</code> de Lombok, pero c\u00f3mo evitarlo cuando se convierte a JSON. La soluci\u00f3n se ofrece con nuevas anotaciones, como sigue:</p> <ul> <li><code>@JsonIgnore</code> \u2192 este campo no se convertir\u00e1.</li> <li> <p><code>@JsonManagedReference</code> \u2192 indica que mostraremos la informaci\u00f3n de este objeto hacia delante, pero no hacia atr\u00e1s. Esta anotaci\u00f3n se complementar\u00e1 con: </p> </li> <li> <p><code>@JsonBackReference</code> \u2192 muestra s\u00f3lo la informaci\u00f3n referenciada, similar a <code>@JsonIgnore</code>. </p> </li> <li><code>@JsonIgnoreProperties(\"property\")</code> \u2192 omite esta propiedad en el campo anotado.</li> </ul> <p>Si marcamos:</p> <pre><code>class Director{ \n// own attributes \n\n@JsonManagedReference \nSet&lt;Film&gt;\n}\n\nclass Film{ \n// own attributes \n\n@JsonBackReference \nDirector;\n}\n</code></pre> <p>Vamos a mostrar la informaci\u00f3n de la pel\u00edcula de un director sin recursi\u00f3n (s\u00f3lo los atributos propios).</p> <p>Puede encontrar m\u00e1s informaci\u00f3n aqu\u00ed.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#33-el-repositorio","title":"3.3. El repositorio","text":"<p>La capa de repositorio es responsable de gestionar el acceso a los datos. Esto hace posible separar la l\u00f3gica de negocio del acceso a los datos, permitiendo, por ejemplo, poder modificar la base de datos del sistema sin afectar a la l\u00f3gica.</p> <p>En esta capa debemos distinguir dos tipos de acceso:</p> <ul> <li>Acceso a datos del modelo de datos propio del sistema que se realizar\u00e1 a trav\u00e9s del acceso DAO (Data Access Object). Para este tipo de acceso, utilizaremos el framework JPA (Java Persistence API) a trav\u00e9s de Spring Data.</li> <li>Acceso a sistemas externos a trav\u00e9s de conectores (webservices, APIs, etc.)</li> </ul> <p>Por esta raz\u00f3n, crearemos una interfaz en la que tendremos las operaciones que vamos a exponer. Esta interfaz ser\u00e1 <code>ClientRepository.java</code> y se crear\u00e1 en el paquete <code>repository</code>.</p> <p>Con Spring, ahorraremos mucho trabajo, ya que simplemente definiremos una interfaz de trabajo, en la que indicaremos el tipo de repositorio que queremos crear, la clase sobre la que trabajar\u00e1 y el tipo de datos que funciona como identificador de esta clase:</p> <p>Spring proporciona la Repository Interface, de la que hereda <code>CrudRepository</code>, que incluye la definici\u00f3n de las operaciones b\u00e1sicas CRUD. De este \u00faltimo hereda <code>PagingAndSortingRepository</code>, que a\u00f1ade funciones de paginaci\u00f3n y ordenaci\u00f3n, y finalmente tenemos <code>JPARepository</code>, que incluye operaciones espec\u00edficas para JPA.</p> <p>La importancia de la definici\u00f3n gen\u00e9rica de <code>Repository&lt;Class,Type&gt;</code> es que todos los objetos que va a recuperar son de esta clase, y el tipo indica el tipo de la clave primaria de esta clase. Siguiendo nuestro ejemplo, la definici\u00f3n del repositorio ser\u00eda:</p> <pre><code>package com.manu.repository;\n\nimport com.manu.model.Cliente;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Repository\n@Transactional\npublic interface ClienteRepository extends JpaRepository&lt;Cliente, Long&gt; {\n\n}\n</code></pre> <p>Con esto Spring ya nos permite acceder a la base de datos y realizar operaciones b\u00e1sicas. Los siguientes m\u00e9todos est\u00e1n implementados por defecto, y no necesitaremos implementarlos, s\u00f3lo definirlos:</p> <ul> <li>Recuperar datos: </li> <li><code>findAll()</code>, <code>findById(Id)</code>, <code>findById(Iterable&lt;Id&gt;)</code>: recupera una o todas las ocurrencias de un identificador o una colecci\u00f3n de identificadores.</li> <li>Eliminar datos: </li> <li><code>delete(Object)</code>, <code>deleteAll()</code>, <code>deleteById(Id)</code>, <code>deleteAllById(Iterable&lt;Id&gt;)</code>: elimina por objeto, identificador o todos.</li> <li>contar y comprobar: </li> <li><code>count()</code>, <code>existsById()</code></li> <li>guardar objetos: </li> <li><code>save(Object)</code>, <code>save(Iterable&lt;Object&gt;)</code>: guarda el objeto(s)</li> </ul> <p>Consejo</p> <pre><code>Si necesitamos otro m\u00e9todo, debemos definirlo, y despu\u00e9s crear una nueva clase para implementar esta interfaz e implementar el m\u00e9todo.\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#34-el-servicio","title":"3.4. El servicio","text":"<p>La capa de servicio gestiona la l\u00f3gica de negocio de nuestra aplicaci\u00f3n. Esta l\u00f3gica de negocio est\u00e1 separada de la l\u00f3gica web, que se encuentra en el controlador.</p> <p>Cuando definimos clases que implementan servicios para la l\u00f3gica de negocio, deben seguirse las siguientes reglas:</p> <ol> <li>Definir una interfaz que tendr\u00e1 los encabezados de los m\u00e9todos que se desean publicar. De este modo hacemos uso del patr\u00f3n Facade y exponemos los m\u00e9todos del servicio para ser utilizados.</li> <li>Definimos una clase (ten en cuenta que una interfaz puede tener varias clases que la implementen) que implemente la interfaz, de modo que podamos implementar todos los m\u00e9todos del servicio siguiendo la l\u00f3gica de negocio requerida.</li> <li>La anotaci\u00f3n <code>@Service</code> indica en Spring que reconozca a la clase como un servicio (similar a la anotaci\u00f3n <code>@Controller</code> que hemos estudiado en la secci\u00f3n anterior).</li> <li>Utilizaremos <code>@Autowired</code> para inyectar el servicio en el controlador (lo veremos m\u00e1s adelante).</li> <li>Utilizaremos <code>@Autowired</code> para inyectar el DAO con el que trabajaremos en el servicio.</li> <li>Ten en cuenta que un m\u00e9todo de servicio definir\u00e1 una operaci\u00f3n a nivel de negocio, por ejemplo, dar un mensaje de bienvenida. Los m\u00e9todos de servicio estar\u00e1n compuestos por otras operaciones m\u00e1s peque\u00f1as, que se definir\u00e1n en la capa de repositorio.</li> </ol> <p>Con todo esto, empezaremos a definir la capa de servicio. As\u00ed que empezamos creando una interfaz llamada <code>ClientService.java</code> en el paquete <code>service</code>.</p> <pre><code>package com.manu.service;\n\nimport com.manu.dto.ClienteDTO;\n\nimport java.util.List;\n\npublic interface ClienteService {\n\n    ClienteDTO saveCliente(ClienteDTO clienteDTO);\n    ClienteDTO getClienteById(Integer id);\n    List&lt;ClienteDTO&gt; listAllClientes();\n    void deleteCliente(Integer id);\n\n}\n</code></pre> <p>Notemos que en este caso definimos 4 operaciones b\u00e1sicas con <code>ClienteDTO</code>, puesto que son los objetos que gestionar\u00e1 el controlador.</p> <p>Una vez que tenemos la interfaz, creamos una nueva clase llamada <code>ClientServiceImpl.java</code>, que se encargar\u00e1 de implementar los m\u00e9todos que se declaran en la interfaz. Despu\u00e9s, hacemos que la nueva clase implemente la interfaz creada y despu\u00e9s hagamos que implemente todos los m\u00e9todos de la interfaz por defecto. Tambi\u00e9n indicamos la anotaci\u00f3n <code>@Service</code> en clase. Ser\u00e1 como sigue:</p> <pre><code>package com.manu.service;\n\nimport com.manu.dto.ClienteDTO;\nimport com.manu.model.Cliente;\nimport com.manu.repository.ClienteRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class ClienteServiceImpl implements ClienteService{\n\n    @Autowired\n    private ClienteRepository clienteRepository;\n\n    @Override\n    public ClienteDTO saveCliente(ClienteDTO clienteDTO) {\n        Cliente cliente = ClienteDTO.convertToEntity(clienteDTO);\n        clienteRepository.save(cliente);\n        return clienteDTO;\n    }\n\n    @Override\n    public ClienteDTO getClienteById(Integer id) {\n        Optional&lt;Cliente&gt; cliente = clienteRepository.findById(Long.valueOf(id));\n        if(cliente.isPresent()) {\n            return ClienteDTO.convertToDTO(cliente.get());\n        }else  {\n            return null;\n        }\n    }\n\n    @Override\n    public List&lt;ClienteDTO&gt; listAllClientes() {\n        List&lt;Cliente&gt; lista = clienteRepository.findAll();\n        List&lt;ClienteDTO&gt; listaResultado = new ArrayList&lt;ClienteDTO&gt;();\n        for (int i = 0; i &lt; lista.size(); ++i) {\n            listaResultado.add(ClienteDTO.convertToDTO(lista.get(i)));\n        }\n        return listaResultado;\n    }\n\n    @Override\n    public void deleteCliente(Integer id) {\n        Optional&lt;Cliente&gt; opt = clienteRepository.findById(Long.valueOf(id));\n        clienteRepository.deleteById(id.longValue());\n    }\n}\n</code></pre> <p>Como puede ver, el servicio se encarga de invocar los m\u00e9todos del repositorio y de realizar algunas comprobaciones si es necesario. Adem\u00e1s obtenemos objetos <code>Cliente</code> y los transformamos en <code>ClienteDTO</code> para utilizarlos para devolver al controlador.</p> <p>Importante</p> <p>\u200b   El m\u00e9todo <code>findClienteById()</code> devuelve una nueva clase envoltorio (wrapper &lt;&gt;) <code>Optional&lt;Cliente&gt;</code>. Esta clase encapsula un Objeto que existir\u00e1 o no, proporcionando m\u00e9todos para comprobarlo y actuar en consecuencia: </p> <ul> <li><code>isPresent()</code> \u2192 devuelve un booleano. </li> <li><code>orElse(anotherObject)</code> \u2192 si no existe, devuelve otro Objeto en lugar de Optional. </li> <li><code>get()</code> \u2192 devuelve el objeto existente. </li> </ul> <p>El objetivo principal es evitar la famosa NullPointerException. Puede encontrar m\u00e1s informaci\u00f3n aqu\u00ed</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#35-el-controlador","title":"3.5. El controlador","text":"<p>Ahora vamos a definir la capa de m\u00e1s alto nivel, la capa de controladores, donde expondremos los servicios de la aplicaci\u00f3n.</p> <p>El controlador ser\u00e1 el encargado de responder a las solicitudes de los usuarios con su aplicaci\u00f3n. Incluir\u00e1 los servicios, y en caso de crear una aplicaci\u00f3n MVC, podr\u00e1 invocar a motores de plantillas, como Thymeleaf. Como hemos comentado aqu\u00ed, lo implementaremos en una sola clase (sin seguir el patr\u00f3n anterior).</p> <p>El controlador invocar\u00e1 el servicio asociado a esta solicitud y devolver\u00e1 los datos obtenidos o la respuesta al propio cliente. Debemos marcar la clase con el estereotipo <code>@Controller</code>. En el caso de los servicios REST, tambi\u00e9n debemos indicar que los retornos de los m\u00e9todos de la clase se serializan a JSON, y lo conseguimos con <code>@ResponseBody</code>. Desde Spring 4, ambas anotaciones se han fusionado en una, mediante <code>@RestController</code>. S\u00f3lo dejaremos <code>@Controller</code> para proyectos donde devolvemos una vista (HTML + CSS + JS).</p> <p>El servicio que crearemos tendr\u00e1 un comportamiento completo en cuanto al mantenimiento de <code>Cliente</code>, as\u00ed como su recomendaci\u00f3n, por lo que podremos listar clientes, ver su informaci\u00f3n, registrar clientes, actualizar datos de clientes y eliminar clientes, o ser las operaciones CRUD que se conocen.</p> <p>As\u00ed que empezaremos creando un controlador llamado <code>ClienteController.java</code>. Este controlador implementar\u00e1 las 4 operaciones correspondientes a CRUD: crear, leer, actualizar y eliminar. Aparte de estas 4, vamos a crear una operaci\u00f3n que mostrar\u00e1 la p\u00e1gina inicial de la aplicaci\u00f3n, con un enlace al mantenimiento de clientes.</p> <pre><code>package com.manu.controller;\n\nimport com.manu.service.ClienteService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClienteController {\n\n    @Autowired\n    private ClienteService clienteService;\n\n// mapping the requests. One method por route/request\n\n}\n</code></pre> <p>El controlador normalmente define cuatro operaciones CRUD pero podemos a\u00f1adir todas las que necesitamos. Ve\u00e1moslo.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#351-indice","title":"3.5.1. \u00cdndice","text":"<p>Este m\u00e9todo mapeo el \u00edndice ra\u00edz de nuestra aplicaci\u00f3n web. Por ejemplo, podemos enviar el nombre de la aplicaci\u00f3n y el m\u00f3dulo. Estas variables se pueden definir en nuestro <code>application.properties</code> y se pueden cargar con la anotaci\u00f3n <code>@Value</code> y una cadena <code>${property_name}</code> dentro. Adem\u00e1s haremos uso de Logger para obtener informaci\u00f3n:</p> <pre><code>package com.manu.controller;\n\nimport com.manu.service.ClienteService;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class ClienteController {\n\n    private static final Logger myLog = Logger.getLogger(ClienteController.class.getName());\n\n    @Autowired\n    private ClienteService clienteService;\n\n    @Autowired\n    private HttpServletRequest context;\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Value(\"${developer.name}\")\n    private String devName;\n\n}\n</code></pre> <p>El controlador de \u00edndice normalmente muestra informaci\u00f3n general sobre la p\u00e1gina principal, como sigue:</p> <pre><code>@GetMapping(\"/\")\npublic String index() {\n    String res = \"Hola desde Spring\\n\";\n    res += \"Estas ejecutando \" + appName + \"\\n\";\n    res += \". Estando desarrollado por \" + devName + \"\\n\";\n    return res;\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#4-operaciones-de-lectura-get","title":"4. Operaciones de lectura (GET)","text":"<p>Es hora de recuperar datos de nuestro servidor, y normalmente las operaciones <code>GET</code> son los m\u00e9todos m\u00e1s demandados. Implementaremos varios m\u00e9todos que podr\u00edan devolver uno o muchos objetos de la clase deseada, en nuestras notas, la clase Cliente.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#41-obtener-todos","title":"4.1. Obtener todos","text":"<p>No se necesita ninguna opci\u00f3n de filtro, porque queremos obtener a todos los clientes. Cuando recibamos esta solicitud get, debemos llamar al m\u00e9todo <code>listAll</code> en nuestro servicio, que llama, de hecho, a <code>findAll</code> en nuestro repositorio.</p> <pre><code>@GetMapping(\"/clientes\")\npublic List&lt;ClienteDTO&gt; listClientes() {\n    myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n    return clienteService.listAllClientes();\n}\n</code></pre> <p>Aparte del mensaje de registro, simplemente recuperamos los datos del servicio y los devolvemos a la respuesta.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#42-obtener-uno","title":"4.2. Obtener Uno","text":"<p>\u00c9sta es la versi\u00f3n m\u00e1s espec\u00edfica, y normalmente en la solicitud buscamos un objeto a partir de su ID. Entonces, debemos obtener un par\u00e1metro en nuestra solicitud, y utilizaremos el ID en el camino, utilizando la anotaci\u00f3n <code>@PathVariable</code>.</p> <pre><code>@GetMapping(\"/clientes\")\npublic List&lt;ClienteDTO&gt; listClientes() {\n    myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n        return clienteService.listAllClientes();\n    }\n</code></pre> <p>La solicitud ser\u00e1 <code>/clientes/7</code>, por ejemplo, y entonces, en nuestro m\u00e9todo del controlador, el par\u00e1metro <code>idCliente</code> se configurar\u00e1 con el valor 7. Llamamos <code>getClienteById(7)</code> y, obviamente, obtenemos el <code>ClienteDTO</code> encapsulando el <code>Cliente</code> solicitado, si existe.</p> <p>Podemos mejorar los m\u00e9todos para que no haya resultados (<code>Cliente</code> no existe) o se haya producido un error, devolviendo y encapsulando los resultados en un <code>ResponseEntity&lt;Cliente&gt;</code>. Esta clase de envoltorio devuelve el resultado a la solicitud, pero permite a\u00f1adir un argumento que ser\u00e1 el c\u00f3digo de estado http. Este c\u00f3digo puede ser capturado en la aplicaci\u00f3n cliente para el manejo de errores. El algoritmo ser\u00e1 algo as\u00ed:</p> <pre><code>public ResponseEntity&lt;results&gt;controllerMethod(){ \n// collect the data from the service/repository \nif(!mistake) { \n    return new ResponseEntity&lt;&gt;(Results,HttpStatus.OK); // ALL GOOD \n    } \nreturn new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); // SOMETHING IS WRONG \n}\n</code></pre> <p>aplicado a nuestra aplicaci\u00f3n de ejemplo, y fusionando los dos \u00faltimos ejemplos de c\u00f3digo, obtendremos lo siguiente:</p> <pre><code>@GetMapping(\"/clientes/{idCliente}\")\npublic ResponseEntity&lt;ClienteDTO&gt; showClienteById(@PathVariable Integer idCliente) {\n    myLog.info(context.getMethod() + context.getRequestURI() + \" from \" + context.getRemoteHost());\n    ClienteDTO elCliente = clienteService.getClienteById(idCliente);\n    if (elCliente == null) {\n        return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n    } else {\n        return new ResponseEntity&lt;&gt;(elCliente, HttpStatus.OK);\n    }\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#43-gestion-de-excepciones","title":"4.3. Gesti\u00f3n de excepciones","text":"<p>El controlador gestiona varias excepciones, y el programa sigue ejecut\u00e1ndose a menos que se produzca un gran error. Ahora presentamos un m\u00e9todo que dar\u00e1 respuesta cuando se produzca una excepci\u00f3n. Anotaremos este m\u00e9todo con <code>@ExceptionHandler</code>, pasando la clase de excepci\u00f3n que debemos capturar.</p> <pre><code>@ExceptionHandler(MethodArgumentTypeMismatchException.class)\npublic ResponseEntity&lt;String&gt; handleError(MethodArgumentTypeMismatchException e) { \nmyLog.warn(\"Method Argumento Type Mismatch\", e); \nString message = String.format(\"Method Argumento Type Mismatch: %s\", e.getName()); \nreturn new ResponseEntity&lt;&gt;(message,HttpStatus.BAD_REQUEST);\n}\n</code></pre> <p>Podemos manejar varias excepciones en un \u00fanico m\u00e9todo, marc\u00e1ndolo con una colecci\u00f3n de excepciones, por ejemplo como:</p> <pre><code>@ExceptionHandler({ \nMissingServletRequestParameterException.class, \nMethodArgumentTypeMismatchException.class, \nInvalidStreamDefinitionException.class\n})\npublic ResponseEntity&lt;String&gt; handleError(Exception e) { \n// method body\n}\n\n// y \u00e9ste cuando no se encuentra una entrada en el controlador\n@ExceptionHandler(NoHandlerFoundException.class)\npublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleNotFoundError(NoHandlerFoundException ex) { \nMap&lt;String, Object&gt; response = new HashMap&lt;&gt;(); \nresponse.put(\"error\", \"404 Not Found\"); \nresponse.put(\"message\", \"El recurso solicitado no existe.\"); \nresponse.put(\"path\", ej.getRequestURL()); \n\nreturn new ResponseEntity&lt;&gt;(response, HttpStatus.NOT_FOUND);\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#5-operaciones-de-guardado-post","title":"5. Operaciones de guardado (POST)","text":"<p>La primera operaci\u00f3n que necesitamos realizar es guardar un nuevo <code>Cliente</code> en nuestra base de datos. Vamos a contarlo con un ejemplo. El controlador recibir\u00e1 un nuevo objeto DTO enviado por la aplicaci\u00f3n cliente (utilizaremos Postman, como puede verse en el Ap\u00e9ndice 1_):</p> <pre><code>    //@PostMapping(value=\"/clientes\",consumes={\"application/json\"})\n    @PostMapping(\"/clientes\")\n    public ResponseEntity&lt;ClienteDTO&gt; addDirector(@RequestBody ClienteDTO newCliente) {\n        myLog.info(context.getMethod() + context.getRequestURI());\n        ClienteDTO elCliente= clienteService.saveCliente(newCliente);\n        if (elCliente==null)\n            return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);\n        else\n            return new ResponseEntity&lt;&gt;(elCliente,HttpStatus.OK);\n    }\n</code></pre> <p>ten en cuenta que:</p> <ul> <li>La solicitud est\u00e1 mapeada con <code>@PostMapping</code>. Aqu\u00ed tienes un comentario con opciones adicionales.</li> <li>El objeto recibido por la aplicaci\u00f3n est\u00e1 dentro de un objeto JSON en el cuerpo de la solicitud, marcado como <code>@RequestBody</code>. En esta unidad supondremos que los datos lleguen bien formateados.</li> <li>Los datos recibidos se pasan al servicio y se devuelve un nuevo <code>Cliente</code> (almacenado).</li> <li>Este cliente se devuelve al cliente.</li> </ul> <p>En esta imagen puedes ver los datos enviados a la API y el valor devuelto. Ten en cuenta que <code>Cuentas</code> y <code>Direcciones</code> no est\u00e1n presentes en estos datos. Veremos m\u00e1s adelante c\u00f3mo a\u00f1adir estos datos adicionales.</p> <p></p> <p>Advertencia</p> <p>Hay muchas validaciones a realizar para verificar la integridad de los datos. Aqu\u00ed puedes encontrar un art\u00edculo sobre c\u00f3mo validar los datos recibidos de las aplicaciones cliente.</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#6-operaciones-de-actualizacion-put","title":"6. Operaciones de actualizaci\u00f3n (PUT)","text":"<p>Para actualizar un objeto de la base de datos, necesitamos recibir el objeto actualizado (y completo) en la solicitud. No podemos guardarlo de inmediato, porque podr\u00eda no existir. Por esta raz\u00f3n, debemos comprobar la existencia, y si \u00e9sta es positiva, entonces guardamos el objeto recibido, que actualizar\u00e1 la versi\u00f3n anterior en la base de datos. Veamos el ejemplo:</p> <pre><code>@PutMapping(\"/clientes\")\npublic ResponseEntity&lt;ClienteDTO&gt; updateCliente(@RequestBody ClienteDTO updCliente) { \nmyLog.info(context.getMethod() + context.getRequestURI()); \n// buscamos si existe previamente \nClienteDTO elCliente= clienteService.getClienteById(updCliente.getIdCliente()); \nif (elCliente==null) \nreturn new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); \nelse { \n// como ya sabemos que existe, save actualiza \nClienteDTO elClienteUPD= clienteService.saveCliente(updCliente); \nreturn new ResponseEntity&lt;&gt;(ClienteUPD,HttpStatus.OK); \n}\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#7-operaciones-de-eliminacion-delete","title":"7. Operaciones de eliminaci\u00f3n (DELETE)","text":"<p>Eliminar es una operaci\u00f3n muy sencilla, porque s\u00f3lo necesitamos el identificador del objeto que queremos eliminar, y despu\u00e9s podemos obtenerlo del camino, dentro de la variable de camino. Entonces, debemos llamar la operaci\u00f3n de eliminaci\u00f3n del servicio.</p> <pre><code>@DeleteMapping(\"/clientes/{idCliente}\")\npublic ResponseEntity&lt;String&gt; deleteCliente(@PathVariable Long idCliente){ \nclienteService.deleteCliente(idCliente); \nreturn new ResponseEntity&lt;&gt;(\"Cliente borrado satisfactoriamente\", HttpStatus.OK);\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#8-controlador-del-cliente-completo","title":"8. Controlador del Cliente Completo","text":"<pre><code>package com.manu.controller;\n\nimport com.manu.dto.ClienteDTO;\nimport com.manu.service.ClienteService;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.logging.Logger;\n\n@RestController\npublic class ClienteController {\n\n    private static final Logger myLog = Logger.getLogger(ClienteController.class.getName());\n\n    @Autowired\n    private ClienteService clienteService;\n\n    @Autowired\n    private HttpServletRequest context;\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Value(\"${developer.name}\")\n    private String devName;\n\n\n    @GetMapping(\"/\")\n    public String index() {\n        String res = \"Hola desde Spring\\n\";\n        res += \"Estas ejecutando \" + appName + \"\\n\";\n        res += \". Estando desarrollado por \" + devName + \"\\n\";\n        return res;\n    }\n\n        @GetMapping(\"/clientes\")\n        public List&lt;ClienteDTO&gt; listClientes() {\n            myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n            return clienteService.listAllClientes();\n        }\n\n    @GetMapping(\"/clientes/{idCliente}\")\n    public ResponseEntity&lt;ClienteDTO&gt; showClienteById(@PathVariable Integer idCliente) {\n        myLog.info(context.getMethod() + context.getRequestURI() + \" from \" + context.getRemoteHost());\n        ClienteDTO elCliente = clienteService.getClienteById(idCliente);\n        if (elCliente == null) {\n            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n        } else {\n            return new ResponseEntity&lt;&gt;(elCliente, HttpStatus.OK);\n        }\n    }\n\n    @PostMapping(\"/clientes\")\n    public ResponseEntity&lt;ClienteDTO&gt; addDirector(@RequestBody ClienteDTO newCliente) {\n        myLog.info(context.getMethod() + context.getRequestURI());\n        ClienteDTO elCliente = clienteService.saveCliente(newCliente);\n        if (elCliente == null) {\n            return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);\n        } else {\n            return new ResponseEntity&lt;&gt;(elCliente, HttpStatus.OK);\n        }\n    }\n\n    @PutMapping(\"/clientes\")\n    public ResponseEntity&lt;ClienteDTO&gt; updateCliente(@RequestBody ClienteDTO updCliente) {\n        myLog.info(context.getMethod() + context.getRequestURI());\n        ClienteDTO elCliente = clienteService.getClienteById(updCliente.getIdCliente());\n        if (elCliente == null) {\n            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n        } else {\n            ClienteDTO elClienteUPD = clienteService.saveCliente(updCliente);\n            return new ResponseEntity&lt;&gt;(elClienteUPD, HttpStatus.OK);\n        }\n    }\n\n    @DeleteMapping(\"/clientes/{idCliente}\")\n    public ResponseEntity&lt;String&gt; deleteCliente(@PathVariable Integer idCliente) {\n        myLog.info(context.getMethod() + context.getRequestURI() + \" from \" + context.getRemoteHost());\n        clienteService.deleteCliente(idCliente);\n        return new ResponseEntity&lt;&gt;(\"Cliente borrado satisfactoriamente\", HttpStatus.OK);\n    }\n}\n</code></pre> <p>Fichero de la base de datos aqui</p>"},{"location":"Unidad%205%20Spring%20Boot/3_API_Rest/#9-ejercicio-completa-el-servidor","title":"9. Ejercicio. Completa el servidor","text":"<p>Hemos terminado de crear nuestro controlador sobre la clase <code>Cliente</code>, pero podemos mejorar nuestra aplicaci\u00f3n a\u00f1adiendo m\u00e1s servicios y configuraciones en el servidor. Estos conceptos se estudiar\u00e1n en las siguientes secciones.</p> <p>Recomendamos completar el controlador, servicios y repositorios de <code>Cuenta</code> , <code>Direccion</code> y <code>Recomendacion</code> con operaciones por defecto.</p> <p>Antenci\u00f3n</p> <p>Para evitar la recursi\u00f3n y que no se devuelva recursivamente un json en el DAO de Cliente (modelo) en las referencias, relaciones, del resto de modelo que debes implementar, recurda indicar con el decorador <code>@JsonIgnore</code> el atributo que implementa la relaci\u00f3n. Este lo que hace es no generar ese atributo en el json que se env\u00eda.</p> <p>Adem\u00e1s, puedes a\u00f1adir opciones para a\u00f1adir una <code>Cuenta</code> a un <code>Cliente</code> o eliminarla, y lo mismo con <code>Direccion</code>.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/","title":"4 Spring Security","text":""},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#1-https","title":"1. HTTPS","text":"<p>Hoy en d\u00eda, necesitamos a\u00f1adir todo lo que podamos para asegurar nuestras aplicaciones. Estudiaremos el concepto de tokens para autorizar y autenticar nuestras solicitudes, pero necesitamos una capa extra, https.</p> <p>En esta p\u00e1gina web https://tiptopsecurity.com/how-does-https-work-rsa-encryption-explained/ puede encontrar c\u00f3mo funciona https.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#11-certificado","title":"1.1. Certificado","text":"<p>En primer lugar, necesitamos generar certificados, o comprarlos. Utilizaremos la herramienta <code>keytool</code> incluida con el kit de desarrollo de Java para generarlos. Este comando genera un par de certificados (p\u00fablico y privado).</p> <pre><code>keytool -genkeypair -alias manu -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore manuro.p12 -validity 3650\n</code></pre> <p>Despu\u00e9s de ejecutar este comando, debemos responder sobre qui\u00e9nes somos, de la siguiente manera:</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#12-configurar-spring","title":"1.2. Configurar Spring","text":"<p>Una vez finalizado el proceso, debemos a\u00f1adir el certificado dentro de nuestro proyecto. Por ejemplo, dentro de <code>/resources/keystore</code>. Por \u00faltimo, debemos cargar el certificado y habilitar SSL, simplemente a\u00f1adiendo estas l\u00edneas a <code>application.properties</code>:</p> <pre><code>spring.application.name=HTTPS\nserver.port=9091\n# The formato used for the keystore.\nserver.ssl.key-store-type=PKCS12\n# The path to the keystore containing the certificate\nserver.ssl.key-store=classpath:keystore/manuro.p12\n# The password used to generate the certificate\nserver.ssl.key-store-password=manuca\n# The alias mapped to the certificate\nserver.ssl.key-alias=manu\n# Use HTTPS instead of HTTP\nserver.ssl.enabled=true\n</code></pre> <p></p> <p>Y esto es todo, cuando Spring comience veremos que est\u00e1 funcionando con el protocolo <code>https</code>:</p> <pre><code>2025-12-04T17:09:56.856+01:00  INFO 21868 --- [HTTPS] [  restartedMain] o.s.boot.tomcat.TomcatWebServer          : Tomcat initialized with port 9091 (https)\n</code></pre> <p></p> <p>y en la solicitud probablemente los navegadores no confiar\u00e1n en nuestro certificado (deberemos a\u00f1adir una excepci\u00f3n de confianza):</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#2-spring-security","title":"2. Spring Security","text":"<p>Spring Security es un proyecto paraguas que agrupa a todos los mecanismos referentes a la seguridad. Necesitamos a\u00f1adir:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>y autom\u00e1ticamente:</p> <ul> <li>La configuraci\u00f3n por defecto est\u00e1 habilitada, a trav\u00e9s de un filtro, llamado <code>SpringSecurityFilterChain</code>.</li> <li>Se crea un bean tipo <code>UserDetailsService</code> con un usuario llamado <code>user</code> y una contrase\u00f1a aleatoria que se muestra por la consola.</li> <li>El filtro se registra en el contenedor de servlets para todas las solicitudes.</li> </ul> <p>Aunque no has configurado demasiado, tiene muchas consecuencias:</p> <ul> <li>Requiere autenticaci\u00f3n para interactuar con nuestra aplicaci\u00f3n</li> <li>Genera un formulario de login por defecto.</li> <li>Genera un mecanismo de logout</li> <li>Protege el almacenamiento de contrase\u00f1as con <code>BCrypt</code>.</li> <li>Proporciona protecci\u00f3n contra ataques CSRF, Fijaci\u00f3n de Sesi\u00f3n, Clickjacking...</li> </ul> <p></p> <p></p> <p>Podemos crear el paquete security y dentro del mismo podemos crear una clase de configuraci\u00f3n, con este contenido:</p> <pre><code>package org.cipfpcheste.dam2.https.security;\n\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class SecurityConfig {\n\n}\n</code></pre> <p>Atenci\u00f3n</p> <p>Volveremos a esta clase para a\u00f1adir m\u00e1s configuraciones. Lo m\u00e1s interesante es el m\u00e9todo <code>configure</code> y la creaci\u00f3n de varios beans utilizados por otras clases.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#21-datos-de-usuarios-para-autenticacion-y-autorizacion-modelos","title":"2.1. Datos de Usuarios para Autenticaci\u00f3n y Autorizaci\u00f3n (Modelos)","text":"<p>Importante</p> <p>\u200b   A partir de ahora, este ejemplo se basa en una p\u00e1gina web famosa https://www.bezkoder.com. Explicamos todo lo necesario del ejemplo que puede ver aqu\u00ed.</p> <p>\u200b   En esta secci\u00f3n prepararemos nuestra aplicaci\u00f3n para identificar a usuarios con diversos roles. Con estos roles, podremos conceder o no acceso a varios recursos.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#22-usuarios-roles","title":"2.2. Usuarios &amp; Roles","text":"<p>Para ello necesitamos crear una clase <code>User</code>, para almacenar esta informaci\u00f3n en nuestra base de datos. Este usuario podr\u00eda tener una colecci\u00f3n de rols. Podemos hacerlo con una relaci\u00f3n de muchos a muchos.</p> <pre><code>public enum ERole { \nROLE_USER, \nROLE_MODERATOR, \nROLE_ADMIN\n}\n</code></pre> <p>basado en esta enumeraci\u00f3n, haremos una clase <code>Role</code> para almacenar los roles que nuestra aplicaci\u00f3n soportar\u00e1:</p> <pre><code>package org.cipfpcheste.dam2.https.models;\n\nimport jakarta.persistence.*;\nimport lombok.Data;\n\n@Data\n@Entity\n@Table(name = \"roles\")\npublic class Role {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Integer id;\n\n    @Enumerated(EnumType.STRING)\n    @Column(length = 20)\n    private ERole name;\n}\n</code></pre> <p>por \u00faltimo, una clase <code>User</code> como la siguiente. A\u00f1adimos nuevas anotaciones de validaci\u00f3n:</p> <pre><code>package org.cipfpcheste.dam2.https.models;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport jakarta.persistence.*;\nimport jakarta.validation.constraints.Email;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.Size;\n\n\n@Entity\n@Table(name = \"users\",\n        uniqueConstraints = {\n                @UniqueConstraint(columnNames = \"username\"),\n                @UniqueConstraint(columnNames = \"email\")\n        })\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @NotBlank\n    @Size(max = 20)\n    private String username;\n\n    @NotBlank\n    @Size(max = 50)\n    @Email\n    private String email;\n\n    @NotBlank\n    @Size(max = 120)\n    private String password;\n\n    @ManyToMany(fetch = FetchType.LAZY)\n    @JoinTable( name = \"user_roles\",joinColumns = @JoinColumn(name = \"user_id\"),\n            inverseJoinColumns = @JoinColumn(name = \"role_id\"))\n    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();\n\n    public User() {\n    }\n\n    public User(String username, String email, String password) {\n        this.username = username;\n        this.email = email;\n        this.password = password;\n    }\n\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#23-repositorio-de-usuarios-y-roles","title":"2.3. Repositorio de Usuarios y Roles","text":"<p>Necesitamos crear nuestros repositorios para las \u00faltimas entidades, creando interfaces como normalmente hacemos.</p> <pre><code>package org.cipfpcheste.dam2.https.repository;\n\nimport org.cipfpcheste.dam2.https.models.ERole;\nimport org.cipfpcheste.dam2.https.models.Role;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.Optional;\n\n@Repository\npublic interface RoleRepository extends JpaRepository&lt;Role, Long&gt; {\n    Optional&lt;Role&gt; findByName(ERole name);\n}\n</code></pre> <pre><code>package org.cipfpcheste.dam2.https.repository;\n\nimport java.util.Optional;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\nimport org.cipfpcheste.dam2.https.models.User;\n\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    Optional&lt;User&gt; findByUsername(String username);\n\n    Boolean existsByUsername(String username);\n\n    Boolean existsByEmail(String email);\n}\n</code></pre> <p>Tambi\u00e9n a\u00f1adimos m\u00e9todos para comprobar la existencia del usuario por nombre y correo electr\u00f3nico, y m\u00e9todos para encontrar por nombre, tanto <code>User</code> como <code>Role</code>.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#24-userdetails","title":"2.4. UserDetails","text":"<p>Spring necesita que alguien implemente la interfaz <code>UserDetails</code>, muy importante porque Spring Security utilizar\u00e1 un <code>UserDetails</code>. <code>UserDetails</code> contiene la informaci\u00f3n necesaria para construir un objeto <code>Authentication</code> a partir de DAOs u otras fuentes de datos de seguridad. Creamos una clase, llamada <code>UserDetailsImpl</code>, que:</p> <ul> <li>Debe tener los campos <code>username</code> y <code>password</code>, y los getters. Debe respetar los nombres, cualquier cambio est\u00e1 prohibido. Estos m\u00e9todos ser\u00e1n utilizados por las clases de autenticaci\u00f3n.</li> <li>Sobreescribir m\u00e9todos de <code>UserDetails</code>, por ejemplo <code>getAuthorities()</code> y varios m\u00e9todos para controlar si el usuario est\u00e1 bloqueado, caducado, etc.</li> </ul> <p>Clase completa:</p> <pre><code>package org.cipfpcheste.dam2.https.services;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport org.cipfpcheste.dam2.https.models.User;\nimport org.jspecify.annotations.Nullable;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.io.Serial;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class UserDetailsImpl implements UserDetails {\n    @Serial\n    private static final long serialVersionUID = 1L;\n\n    private Long id;\n    private String username;\n    private String email;\n\n    @JsonIgnore\n    private String password;\n\n    private Collection&lt;? extends GrantedAuthority&gt; authorities;\n\n    public UserDetailsImpl(Long id, String username, String email, String password,\n                           Collection&lt;? extends GrantedAuthority&gt; authorities) {\n        this.id = id;\n        this.username = username;\n        this.email = email;\n        this.password = password;\n        this.authorities = authorities;\n    }\n\n    public static UserDetailsImpl build(User user) {\n        List&lt;GrantedAuthority&gt; authorities = user.getRoles().stream()\n                .map(role -&gt; new SimpleGrantedAuthority(role.getName().name()))\n                .collect(Collectors.toList());\n\n        return new UserDetailsImpl(\n                user.getId(),\n                user.getUsername(),\n                user.getEmail(),\n                user.getPassword(),\n                authorities);\n    }\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n        return authorities;\n    }\n\n    @Override\n    public @Nullable String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n\n}\n</code></pre> <p>Ten en cuenta que:</p> <ul> <li>\u00bfUtilizamos <code>private Collection&lt;? extends GrantedAuthority&gt; authorities;</code> para almacenar las autoridades (es decir, roles) en un formato que es entendido por Spring Security.</li> <li>En lugar de crear un constructor, creamos un <code>builder()</code>, que recibe un <code>User</code>, extrae la informaci\u00f3n de \u00e9ste y transforma la <code>List&lt;Role&gt;</code> en autoridades, y despu\u00e9s, el builder llama al constructor.</li> </ul> <p>En lugar de crear un <code>User</code> y <code>Role</code> <code>Service</code>, crearemos un <code>UserDetailSeriveImpl</code> (que implementa <code>UserDetailService</code> de Spring), para recuperar un <code>User</code> del repositorio, y despu\u00e9s devuelve un <code>UserDetailImpl</code>, de la siguiente manera:</p> <pre><code>package org.cipfpcheste.dam2.https.services;\n\nimport org.cipfpcheste.dam2.https.models.User;\nimport org.cipfpcheste.dam2.https.repository.UserRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n    @Autowired\n    UserRepository userRepository;\n\n    @Override\n    @Transactional\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        User user = userRepository.findByUsername(username)\n                .orElseThrow(() -&gt; new UsernameNotFoundException(\"User Not Found with username: \" + username));\n\n        return UserDetailsImpl.build(user);\n    }\n\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#25-cargas-de-dtos","title":"2.5. Cargas de DTO's","text":"<p>En esta secci\u00f3n veremos las clases necesarias que almacenan informaci\u00f3n para:</p> <ul> <li>Registrar a un nuevo usuario, para recibir informaci\u00f3n del cliente y almacenar un nuevo usuario. Esta clase es <code>SignupRequest</code>.</li> <li>Iniciar sesi\u00f3n de un usuario, para acceder a nuestro sistema. Esta clase es <code>LoginRequest</code>. </li> <li><code>JwtResponse</code>, relacionada como respuesta a la solicitud de inicio de sesi\u00f3n. Esta respuesta contendr\u00e1 un Token JWT, utilizado para autorizar solicitudes posteriores. Esta clase es <code>JwtResponse</code>.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#26-signuprequest","title":"2.6. SignupRequest","text":"<p>Esta clase contiene informaci\u00f3n para registrar a un nuevo usuario. Contiene anotaciones de validaci\u00f3n.</p> <p><pre><code>package org.cipfpcheste.dam2.https.payload.request;\n\nimport jakarta.validation.constraints.Email;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.Size;\nimport lombok.Data;\n\nimport java.util.Set;\n\n@Data\npublic class SignupRequest {\n    @NotBlank\n    @Size(min = 3, max = 20)\n    private String username;\n\n    @NotBlank\n    @Size(max = 50)\n    @Email\n    private String email;\n\n    private Set&lt;String&gt; role;\n\n    @NotBlank\n    @Size(min = 6, max = 40)\n    private String password;\n}\n</code></pre> Para enviar esta informaci\u00f3n, el objeto json recibido ser\u00e1 similar a:</p> <pre><code>{ \n\"username\":\"manuro\", \n\"email\":\"jm.romeromartinez@edu.gva.es\", \n\"password\":\"123456\", \n\"role\":[\"admin\",\"user\"]\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#27-loginrequest","title":"2.7. LoginRequest","text":"<p>Muy sencilla:</p> <pre><code>package org.cipfpcheste.dam2.https.payload.request;\n\nimport jakarta.validation.constraints.NotBlank;\nimport lombok.Data;\n\n@Data\npublic class LoginRequest {\n    @NotBlank\n    private String username;\n\n    @NotBlank\n    private String password;\n}\n</code></pre> <p>y el objeto json asociado ser\u00e1:</p> <pre><code>{ \n\"username\":\"manuro\", \n\"password\":\"123456\"\n}\n</code></pre> <p>Atenci\u00f3n</p> <p>En esta clase podemos marcar los campos como obligatorios, con la anotaci\u00f3n <code>@NotBlank</code> de <code>javax.validation.constraints.NotBlank</code>. Tienes que a\u00f1adir: </p> <pre><code>&lt;dependency&gt; \n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; \n&lt;/dependency&gt; \n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#28-jwtresponse","title":"2.8. JwtResponse","text":"<p>Esta clase DTO es la clase que se devuelve como solicitud de login. Debe contener poca informaci\u00f3n sobre nuestro usuario y lo m\u00e1s importante, un token JWT. Este token se utilizar\u00e1 para autorizarnos, como estudiaremos en la siguiente secci\u00f3n.</p> <pre><code>package org.cipfpcheste.dam2.https.payload.response;\n\nimport lombok.Data;\n\nimport java.util.List;\n\n@Data\npublic class JwtResponse {\n    private String token;\n    private String type = \"Bearer\";\n    private Long id;\n    private String username;\n    private String email;\n    private List&lt;String&gt; roles;\n}\n</code></pre> <p>Ten en cuenta que:</p> <ul> <li>Los campos de esta clase se poblar\u00e1n a partir de la clase <code>User</code>, como un DTO.</li> <li>Hemos cambiado el formato del rol, de la clase <code>Role</code> a <code>String</code>, con una mejor gesti\u00f3n en los clientes.</li> <li>El <code>String token</code> es donde se almacena el token JWT. De hecho, un token es una cadena de texto, como mostraremos ahora.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#3-tokens-jwt","title":"3. Tokens JWT","text":""},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#31-que-es-un-token","title":"3.1. \u00bfQu\u00e9 es un token?","text":"<p>JSON Web Tokens (JWT) se han introducido como un m\u00e9todo de securizar la comunicaci\u00f3n segura entre dos partes. Se introdujo con la especificaci\u00f3n RFC 7519 por el Internet Engineering Task Force (IETF). Aunque podemos utilizar <code>JWT</code> con cualquier tipo de m\u00e9todo de comunicaci\u00f3n, hoy en d\u00eda, JWT es muy popular para gestionar la autenticaci\u00f3n y la autorizaci\u00f3n sobre HTTP.</p> <p>Primero, necesitar\u00e1s conocer algunas caracter\u00edsticas de HTTP:</p> <ul> <li>HTTP es un protocolo sin estado, lo que significa que una solicitud HTTP no mantiene el estado. El servidor no es consciente de ninguna solicitud anterior enviada por el propio cliente.</li> <li>Las solicitudes HTTP deber\u00edan ser aut\u00f3nomas. Deben incluir informaci\u00f3n sobre solicitudes anteriores que el usuario ha realizado en la misma solicitud.</li> </ul> <p>Hay algunas formas de hacer esto, pero la manera m\u00e1s popular es establecer un session_id, que es una referencia a la informaci\u00f3n del usuario:</p> <ul> <li>El servidor almacenar\u00e1 este ID de sesi\u00f3n en memoria o en una base de datos. El cliente enviar\u00e1 cada solicitud con ese ID de sesi\u00f3n.</li> <li>El servidor puede obtener informaci\u00f3n sobre el cliente utilizando esta referencia.</li> <li>Normalmente, este ID de sesi\u00f3n se env\u00eda al usuario como una cookie.</li> </ul> <p>Aqu\u00ed tienes el diagrama de c\u00f3mo funciona la autenticaci\u00f3n basada en sesiones.</p> <p></p> <p>Por otra parte, con JWT, cuando el cliente env\u00eda una solicitud de autenticaci\u00f3n al servidor, \u00e9ste enviar\u00e1 un token JSON al cliente, que incluye toda la informaci\u00f3n sobre el usuario junto con la respuesta.</p> <p>El cliente enviar\u00e1 este token con todas las solicitudes posteriores. Por tanto, el servidor no deber\u00e1 almacenar ninguna informaci\u00f3n sobre la sesi\u00f3n. Pero existe un problema con este enfoque. Cualquiera puede enviar una solicitud falsa con un token JSON falso y hacerse pasar por alguien que no es.</p> <p>Por ejemplo, supongamos que despu\u00e9s de la autenticaci\u00f3n, el servidor devuelve un objeto JSON al cliente con el nombre de usuario y el tiempo de expiraci\u00f3n. As\u00ed, dado que el objeto JSON es legible, cualquiera puede editar esta informaci\u00f3n y enviar una solicitud con ella. El problema es que no hay forma de validar esta solicitud.</p> <p>Aqu\u00ed es donde entra en juego la firma testigo. As\u00ed que en lugar de enviar s\u00f3lo un token JSON normal, el servidor enviar\u00e1 un token firmado, que puede verificar que la informaci\u00f3n no ha cambiado.</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#32-estructura-de-un-jwt","title":"3.2. Estructura de un JWT","text":"<p>Hablamos de la estructura de un JWT a trav\u00e9s de un token de ejemplo:</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikpv aG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n</code></pre> <p>Como puede ver, hay tres secciones en este JWT, cada una separada por un punto.</p> <p>Nota</p> <p>La codificaci\u00f3n <code>Base64</code> es una manera de asegurar que los datos no se corrompan, ya que no comprimen ni cifran los datos, sino que simplemente los codifican de forma que la mayor\u00eda de los sistemas pueden entender. Puede leer cualquier text codificado en Base64 simplemente descodific\u00e1ndolo.</p> <p>La primera secci\u00f3n del JWT es un header, que es una cadena codificada en Base64. Si descodifica el header, se ver\u00eda as\u00ed:</p> <pre><code>{ \n\"alg\":\"HS512\", \n\"typ\":\"JWT\"\n}\n</code></pre> <p>La secci\u00f3n del header contiene el algoritmo de hash, que se utiliz\u00f3 para generar la firma del token y el tipo.</p> <p>La segunda secci\u00f3n es el payload que contiene el objeto JSON que se envi\u00f3 de vuelta al usuario. Puesto que s\u00f3lo est\u00e1 codificado en Base64, cualquiera puede descodificarlo f\u00e1cilmente. Es obligatorio no incluir datos sensibles en los JWT, tales como contrase\u00f1as o informaci\u00f3n personal identificable.</p> <p>Normalmente, el cuerpo del JWT se ver\u00e1 as\u00ed, aunque no necesariamente se aplica:</p> <pre><code>{ \n\"sub\": \"1234567890\", \n\"name\": \"John Doe\", \n\"iat\": 1516239022\n}\n</code></pre> <p>Nota</p> <p>La mayor\u00eda de las veces, la propiedad <code>sub</code> contendr\u00e1 el ID del usuario, la propiedad <code>iat</code> (issued at), abreviada como <code>emitido a</code>, es el sello de tiempo de emisi\u00f3n del token. Tambi\u00e9n puede ver algunas propiedades comunes, como <code>eat</code> o <code>exp</code>, que es el tiempo de expiraci\u00f3n del token. </p> <p>Todas estas propiedades son los claims del token, la informaci\u00f3n.</p> <p>La secci\u00f3n final es la firma del token. \u00c9sta se genera haciendo un hash de la cadena creada con las dos secciones anteriores y una contrase\u00f1a secreta, utilizando el algoritmo mencionado en la secci\u00f3n del header.</p> <p>Puede visitar https://www.javainuse.com/jwtgenerator y https://jwt.io para generar tokens y probar con varios datos, secretos y hashes.</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#33-jwt-library-class","title":"3.3. JWT Library class","text":"<p>A\u00f1adiremos al <code>pom.xml</code> las siguientes dependencias:</p> <pre><code> &lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api --&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n        &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n        &lt;version&gt;0.13.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n    &lt;version&gt;0.13.0&lt;/version&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-jackson --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n    &lt;version&gt;0.13.0&lt;/version&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Esta clase es la que genera y comprueba la integridad de los tokens. Vamos a mostrar esa clase y qu\u00e9 elementos necesita. Esta clase ser\u00e1 una clase de biblioteca con m\u00e9todos para crear tokens, validarlos y extraer informaci\u00f3n de ellos. Podemos encontrar esta clase con nombres como <code>JWTUtils</code> o <code>JWTTokenProvider</code>. El esqueleto de esta clase es el siguiente:</p> <ul> <li>Carga o definici\u00f3n de constantes del token</li> <li>M\u00e9todo para generar JWT a partir de un objeto <code>Authentication</code></li> <li>M\u00e9todos para obtener informaci\u00f3n del token</li> <li>M\u00e9todo para validar el token (firma)</li> </ul> <p>La carga de constantes es as\u00ed:</p> <pre><code>package org.cipfpcheste.dam2.https.security.jwt;\n\nimport io.jsonwebtoken.*;\nimport io.jsonwebtoken.io.Decoders;\nimport io.jsonwebtoken.security.Keys;\nimport org.cipfpcheste.dam2.https.services.UserDetailsImpl;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.stereotype.Component;\n\nimport javax.crypto.SecretKey;\nimport java.util.Date;\n\n@Component\npublic class JWTUtils {\n\n\n    private static final Logger logger = LoggerFactory.getLogger(JWTUtils.class);\n\n    // Vamos a obtener del fichero application.properties una codificaci\u00f3n en base64 para la generaci\u00f3n de los tokens\n    // en la aplicaci\u00f3n la he generado en linux con el comando openssl rand -base64 64 para que me genere la cadena en base 64\n\n    @Value(\"${app.jwtSecret}\")\n    private String jwtSecret;\n\n    // Se guarda el tiempo de expiraci\u00f3n del token. Lo podemos variar a conveniencia. Al igual que el anterior, del application.properties\n    @Value(\"${app.jwtExpirationMs}\")\n    private int jwtExpirationMs;\n</code></pre> <p>Estas son los m\u00e9todos que implementamos:</p> <pre><code>/** Clave \u00fanica y coherente para firmar y validar */\n    private SecretKey key() {\n\n    }\n\n    public String generateJwtToken(Authentication authentication) {\n\n    }\n\n    public String getUserNameFromJwtToken(String token) {\n\n    }\n\n    public boolean validateJwtToken(String authToken) {\n\n    }\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#34-generar-tokens","title":"3.4. Generar Tokens","text":"<p>Veamos cada m\u00e9todo. Primero, necesitamos un objeto <code>Authentication</code>. Debemos saber que este objeto representa otro token (no nuestro JWT) con las credenciales del objeto que queremos identificar.</p> <p>Antes de generar o validar un token, necesitaremos una clave v\u00e1lida para lo dicho, firmar o validar y lo haremos as\u00ed:</p> <p><pre><code>/** Clave \u00fanica y coherente para firmar y validar */\n    private SecretKey key() {\n        // jwtSecret se asume codificado en Base64 (como en application.properties)\n        byte[] keyBytes = Decoders.BASE64.decode(jwtSecret);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n</code></pre> Y genero el token:</p> <pre><code>public String generateJwtToken(Authentication authentication) {\n    UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();\n\n    Date now = new Date();\n    Date expiryDate = new Date(now.getTime() + jwtExpirationMs);\n\n    return Jwts.builder()\n            .subject(userPrincipal.getUsername())\n            .issuedAt(now)\n            .expiration(expiryDate)\n            .signWith(key(), Jwts.SIG.HS512)\n            .compact();\n}\n</code></pre> <p>Vemos que:</p> <ul> <li>Recibimos un objeto <code>Authentication</code>, en el que hemos guardado un <code>UserDetailsImpl</code>. Como todas las implementaciones de detalles de usuario, podemos obtener el nombre de usuario, y lo utilizamos para establecer el sujeto del token.</li> <li>Establecemos <code>IAT</code> en el momento actual.</li> <li>Establecemos el tiempo de expiraci\u00f3n.</li> <li>Establecemos el algoritmo de cifrado y la palabra secreta, y el token est\u00e1 listo...</li> <li>El m\u00e9todo <code>compact()</code> crea y transforma el token en String.</li> </ul> <p>Nota</p> <p>Como se puede observar el m\u00e9todo signWith hace uso del m\u00e9todo definido para generar la clave a partir del base64 del properties, es decir, de la entrada de <code>app.jwtSecret</code>.</p> <pre><code>    private static final Logger logger = LoggerFactory.getLogger(JWTUtils.class);\n\n    @Value(\"${app.jwtSecret}\")\n    private String jwtSecret;\n\n    @Value(\"${app.jwtExpirationMs}\")\n    private int jwtExpirationMs;\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#35-validacion-de-usuarios-del-token","title":"3.5. Validaci\u00f3n de Usuarios del token","text":"<p>Para la validaci\u00f3n de los usuarios desde el token haremos uso de esta funci\u00f3n:</p> <pre><code>public String getUserNameFromJwtToken(String token) {\n    return Jwts.parser()\n            .verifyWith(key())\n            .build()\n            .parseSignedClaims(token)\n            .getPayload()\n            .getSubject();\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#36-validacion-de-tokens","title":"3.6. Validaci\u00f3n de Tokens","text":"<pre><code>public boolean validateJwtToken(String authToken) {\n    try {\n        Jwts.parser()\n                .verifyWith(key())\n                .build()\n                .parseSignedClaims(authToken);\n        return true;\n    } catch (SecurityException | MalformedJwtException e) {\n        logger.error(\"Invalid JWT token: {}\", e.getMessage());\n    } catch (ExpiredJwtException e) {\n            logger.error(\"JWT token is expired: {}\", e.getMessage());\n    } catch (UnsupportedJwtException e) {\n        logger.error(\"JWT token is unsupported: {}\", e.getMessage());\n    } catch (IllegalArgumentException e) {\n        logger.error(\"JWT claims string is empty: {}\", e.getMessage());\n    }\n    return false;\n}\n</code></pre> <p>En este m\u00e9todo comprobamos si es un token v\u00e1lido. Para ello primero generamos la key con hmacShaKeyFor, que es un m\u00e9todo de utilidad de JJWT que crea una SecretKey segura y apropiada para algoritmos HMAC a partir de bytes. Con este hacemos lo siguiente:</p> <p><pre><code>Jwts.parser()        // 1. Inicia el constructor del parser\n    .verifyWith(key()) // 2. Configura la clave de verificaci\u00f3n\n    .build()         // 3. Construye el parser\n    .parseSignedClaims(authToken); // 4. Parsea y verifica el token\n</code></pre> Si existe alg\u00fan problema con la integridad del token, podr\u00eda aparecer una excepci\u00f3n. Obtenemos los claims dentro de un blog <code>try-catch</code> e informamos si ocurre algo. Devolveremos <code>true</code> si no se captura ninguna excepci\u00f3n.</p> <p>Nota</p> <p>Recuerda que los claims son el contenido del payload del token. No necesitamos los claims en este m\u00e9todo, s\u00f3lo comprobar si todo est\u00e1 bien. Esto lo podr\u00edamos hacer encadenado dentro de parseSignedClaims(authToken) . getPauloads() pero no nos interesan, por lo que los omitimos.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#4-authentication-controller","title":"4. Authentication Controller","text":"<p>Ahora que tambi\u00e9n sabemos c\u00f3mo crear tokens y la estructura de <code>User</code> en nuestra base de datos, es hora de exponer nuestro path para registrar e iniciar sesi\u00f3n de usuarios. Por tanto, s\u00f3lo son obligatorios dos m\u00e9todos. La clase podr\u00eda ser algo as\u00ed:</p> <pre><code>@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n...\n}\n</code></pre> <ul> <li>La anotaci\u00f3n <code>@CrossOrigin</code> permite solicitudes de cross-origin en clases de controlador espec\u00edficas y/o m\u00e9todos de controlador. Se procesa si se configura un <code>HandlerMapping</code> apropiado. Cross-Origin Resource Sharing (CORS) es un concepto de seguridad que permite restringir los recursos implementados en navegadores web. Evita que el c\u00f3digo JavaScript produzca o consuma solicitudes contra un origen distinto. Por ejemplo, su aplicaci\u00f3n web se est\u00e1 ejecutando en el puerto 8080 y mediante JavaScript est\u00e1 intentando consumir servicios web RESTful desde el puerto 9090. En estas situaciones, se encontrar\u00e1 con el problema de seguridad de Cross-Origin Resource Sharing en sus navegadores web.</li> <li><code>@RequestMapping(\"/api/auth\")</code> indica que todos los controladores est\u00e1n dentro del camino <code>/api/auth</code>.</li> </ul> <p>Ve\u00e1moslos, pero antes de estudiar los m\u00e9todos, esta clase tiene estas variables necesarias:</p> <ul> <li><code>@Autowired AuthenticationManager authenticationManager;</code> \u2192 se utiliza para crear un token de <code>Authentication</code>, utilizado por el contexto de seguridad de Spring y por el generador de tokens.</li> <li><code>@Autowired UserRepository userRepository;</code> \u2192 se utiliza para acceder y guardar usuarios.</li> <li><code>@Autowired RoleRepository roleRepository;</code> \u2192 para comprobar si los roles que llegan a la solicitud son v\u00e1lidos.</li> <li><code>@Autowired PasswordEncoder encoder;</code> \u2192 se utiliza para cifrar la contrase\u00f1a del usuario.</li> <li><code>@Autowired JwtUtils jwtUtils;</code> \u2192 se utiliza para crear tokens JWT.</li> </ul> <p>Ahora que hemos presentado a los actores, vamos a la funci\u00f3n.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#41-signup-nuevo-usuario","title":"4.1. Signup (nuevo usuario)","text":"<p>El m\u00e9todo encargado de crear nuevos usuarios recibir\u00e1 un <code>SignupRequest</code> con estos datos:</p> <pre><code>{ \n\"username\":\"manuro\", \n\"email\":\"jm.romeromartinez@edu.gva.es\", \n\"password\":\"123456\", \n\"role\":[\"admin\",\"user\"]\n}\n</code></pre> <p>el cuerpo del m\u00e9todo es el siguiente, y ve\u00e1moslo por bloques:</p> <pre><code>@PostMapping(\"/signup\") \npublic ResponseEntity&lt;?&gt; registerUser(@Valid @RequestBody SignupRequest signUpRequest) { \nif (userRepository.existsByUsername(signUpRequest.getUsername())) { \nreturn ResponseEntity \n.badRequest() \n.body(new MessageResponse(\"Error: Username is already taken!\")); \n} \n\nif (userRepository.existsByEmail(signUpRequest.getEmail())) { \nreturn ResponseEntity \n.badRequest() \n.body(new MessageResponse(\"Error: Email is already in use!\")); \n} \n// Create new user's account \nUser user = new User(signUpRequest.getUsername(), \nsignUpRequest.getEmail(), \nencoder.encode(signUpRequest.getPassword()));\n</code></pre> <p>En esta primera parte:</p> <ul> <li>Comprobamos si existe alg\u00fan usuario con el mismo nombre de usuario o correo electr\u00f3nico, consultando nuestro repositorio. Si aparece alg\u00fan error, devolveremos un <code>ResponseEntity</code> como bad request con un mensaje descriptivo.</li> <li>Por \u00faltimo, creamos un nuevo usuario con nombre de usuario, correo electr\u00f3nico y una contrase\u00f1a encriptada.</li> </ul> <p>El siguiente bloque es responsable de obtener los roles (almacenados en un JSONArray de cadenas) y transformarlos en un <code>Set&lt;Role&gt;</code>.</p> <pre><code>Set&lt;String&gt; strRoles = signUpRequest.getRole(); \nSet&lt;Role&gt; roles = new HashSet&lt;&gt;(); \n\nif (strRoles == null) { \nRole userRole = roleRepository.findByName(ERole.ROLE_USER) \n.orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\")); \nroles.add(userRole); \n} else { \nstrRoles.forEach(role -&gt; { \nswitch (role) { \ncase \"admin\": \nRole adminRole = roleRepository.findByName(ERole.ROLE_ADMIN) \n.orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\")); \nroles.add(adminRole); \n\nbreak; \ncase \"mod\": \nRole modRole = roleRepository.findByName(ERole.ROLE_MODERATOR) \n.orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\")); \nroles.add(modRole);\nbreak; \ndefault: \nRole userRole = roleRepository.findByName(ERole.ROLE_USER) \n.orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\")); \nroles.add(userRole); \n} \n}); \n} \n\nuser.setRolas(rolas);\n</code></pre> <p>Ve\u00e1moslo:</p> <ul> <li>Primero comprobamos si el conjunto de roles est\u00e1 vac\u00edo. Si es cierto, establecemos un nuevo <code>Role</code> con <code>ERole.ROLE_USER</code> por defecto.</li> <li>En caso contrario, debemos recorrer todos los roles que obtenemos, comprobando cada rol en la base de datos y creando el objeto <code>Role</code> correspondiente.</li> </ul> <p>Por \u00faltimo, asignamos <code>Set&lt;Role&gt;</code> al usuario creado en el primer bloque, y en el tercer bloque s\u00f3lo necesitamos almacenar el nuevo usuario con <code>UserRepository</code> y enviar una respuesta de ok al cliente.</p> <pre><code>userRepository.save(user); \n\nreturn ResponseEntity.ok(new MessageResponse(\"User registered successfully!\")); \n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#42-signin-validarse-o-acceder","title":"4.2. Signin (Validarse o acceder)","text":"<p>Nota</p> <p>En castellano: </p> <ul> <li>Signin: registrarse, acceder al login. </li> <li>Signup: inscribirse, darse de alta. La primera vez</li> </ul> <p>Este controlador se utiliza para iniciar sesi\u00f3n de un usuario en nuestra aplicaci\u00f3n. Como hemos estudiado, el DTO que recibimos en el <code>HTTP_POST</code> es la clase <code>LoginRequest</code>, como \u00e9sta:</p> <pre><code>{ \n\"username\":\"manuro\", \n\"password\":\"123456\"\n}\n</code></pre> <p>El m\u00e9todo encargado ser\u00e1:</p> <pre><code>@PostMapping(\"/signin\") \npublic ResponseEntity&lt;?&gt; authenticateUser(@Valid @RequestBody LoginRequest loginRequest) { \n\nAuthentication authentication = authenticationManager.authenticate( \nnew UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword())); \n\nSecurityContextHolder.getContext().setAuthentication(authentication); \nString jwt = jwtUtils.generateJwtToken(authentication); \n\nUserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal(); \n\nList&lt;String&gt; roles = userDetails.getAuthorities().stream() \n.map(item -&gt; item.getAuthority()) \n.collect(Collectors.toList()); \n\nreturn ResponseEntity.ok(new JwtResponse(jwt, \nuserDetails.getId(), \nuserDetails.getUsername(), \nuserDetails.getEmail(), \nroles)); \n}\n</code></pre> <p>Ten en cuenta:</p> <ul> <li>La anotaci\u00f3n <code>@Valid</code> comprueba que el objeto JSON coincida con la clase <code>LoginRequest</code> (mira las anotaciones de esta clase).</li> <li>Creamos un token de <code>Authentication</code> (\u00e9ste no es el token JWT !!!) con el nombre de usuario y la contrase\u00f1a recibidos. La contrase\u00f1a todav\u00eda no est\u00e1 cifrada.</li> <li>El \u00faltimo token de <code>Authentication</code> se configura en <code>SecurityContextHolder</code>, un objeto que contiene un m\u00ednimo de seguridad a nivel de hilo. En este paso es cuando el subsistema de seguridad de Spring funciona, pidiendo a <code>UserDetailService</code> un usuario con ese nombre de usuario y contrase\u00f1a en nuestra base de datos, y se guarda en un Bean <code>UserDetails</code> en la memoria. Si alguna credencial es incorrecta, se lanzar\u00e1 una excepci\u00f3n, que ser\u00e1 gestionada por nuestro sistema (lo estudiaremos m\u00e1s adelante).</li> <li>Con este token (autenticaci\u00f3n) generamos nuestro token. Recuerda que dentro de <code>jwtUtils</code> s\u00f3lo obtenemos el nombre de usuario para generar el sujeto de nuestro token.</li> <li>Obtenemos el objeto <code>UserDetails</code> con el m\u00e9todo <code>getPrincipal()</code>, y</li> <li>Transformamos la lista de autoridades en una lista de cadenas (\u00bfhas estudiado c\u00f3mo mapear listas? \u00bfY filtrar? \u00bfY reducir?).</li> <li>Finalmente, creamos y devolvemos un <code>ResponseEntity</code>, con http_Status ok, con un <code>JwtResponse</code> dentro. Token m\u00e1s atributos. Un ejemplo de <code>JWTrespone</code> es:</li> </ul> <pre><code>{\n    \"accessToken\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJtYW51cm8iLCJpYXQiOjE3NjUzMDI1ODksImV4cCI6MTc2NTM4ODk4OX0.9yZHAZ1E8wemMbUVbJ9vkA4JhjTgXj4B8ETlhUZRGIpi3apFrXEpJ2RKlSBZoVKDcs-iebIzu7lLoujHAzmlLg\",\n    \"id\": 3,\n    \"username\": \"manuro\",\n    \"email\": \"jm.romeromartinez@edu.gva.es\",\n    \"roles\": [\n        \"ROLE_ADMIN\"\n    ],\n    \"tokenType\": \"Bearer\"\n}\n</code></pre> <p>Atenci\u00f3n</p> <p>El \u00faltimo token tiene saltos de l\u00ednea adicionales para evitar salir del margen del papel, es una cadena completa.</p> <p>Si el nombre de usuario no se encuentra en la base de datos, nuestra aplicaci\u00f3n crea la siguiente respuesta:</p> <pre><code>{ \n\"path\": \"/api/auth/signin\", \n\"error\": \"Unauthorized\", \n\"message\": \"Bad credentiales\", \n\"status\": 401\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#5-tokens-en-funcionamiento","title":"5. Tokens en funcionamiento","text":"<p>Ahora que el registro de usuarios y el inicio de sesi\u00f3n est\u00e1n implementados, hacemos una pregunta, \u00bfQu\u00e9 hace la aplicaci\u00f3n cliente con el JWTResponse que ha recibido despu\u00e9s del proceso de inicio de sesi\u00f3n? Los datos del usuario normalmente se utilizan para la interfaz (nombre completo, avatar, etc.). \u00bfPero qu\u00e9 pasa con los tokens?</p> <p>La respuesta, como estudiaremos m\u00e1s adelante, es almacenarlo, y despu\u00e9s enviarlo al servidor en cada solicitud como m\u00e9todo de Autenticaci\u00f3n y Autorizaci\u00f3n.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#51-enviando-tokens","title":"5.1. Enviando tokens","text":"<p>Para enviar un token, necesitamos adjuntarlo a la secci\u00f3n <code>Header</code>, creando un par\u00e1metro <code>Authorization</code> con el valor <code>Bearer token_recieved</code>, como puede ver enesta captura de pantalla de Postman:</p> <p></p> <p>Importante</p> <p>Recuerda: la palabra <code>Bearer</code> m\u00e1s un espacio en blanco m\u00e1s todo el token recibido (como <code>String</code>)</p> <p>De acuerdo, as\u00ed pues, la aplicaci\u00f3n cliente nos enviar\u00e1 el token a trav\u00e9s de la solicitud, pero \u00bfc\u00f3mo hace nuestro servidor para obtener y comprobar el token? La respuesta es que debemos decirlo en forma de filtro.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#6-configuracion-de-seguridad","title":"6. Configuraci\u00f3n de Seguridad","text":"<p>La clase que configura la seguridad es <code>WebSecurityConfig</code>. Vamos a explicarla por blogs de nuevo. Esta clase est\u00e1 compuesta por un conjunto de beans que se utilizar\u00e1n en todo el proyecto (recuerda la inyecci\u00f3n de c\u00f3digo). Explicaremos s\u00f3lo lo necesario.</p> <pre><code>@Configuration\n@EnableGlobalMethodSecurity( \nprePostEnabled = true)\npublic class WebSecurityConfig {\n\n}\n</code></pre> <p>Esta anotaci\u00f3n <code>@Configuration</code> indica a Spring que debe cargar esta clase. Tambi\u00e9n permite que Spring utilice anotaciones de filtros pre y post (lo estudiaremos m\u00e1s adelante).</p> <pre><code>@Autowired \nUserDetailsServiceImpl userDetailsService; \n\n@Autowired \nprivate AuthEntryPointJwt unauthorizedHandler; \n\n@Bean \npublic AuthTokenFilter authenticationJwtTokenFilter() { \nreturn new AuthTokenFilter(); \n}\n</code></pre> <p>Estos beans se explicar\u00e1n m\u00e1s adelante. En pocas palabras, son responsables de gestionar errores como manejador de excepciones y de c\u00f3mo aplicar cadenas de filtros para autenticar a usuarios.</p> <pre><code>@Bean \npublic DaoAuthenticationProvider authenticationProvider() { \nDaoAuthenticationProvider authProvider = new DaoAuthenticationProvider(); \n\nauthProvider.setUserDetailsService(userDetailsService); \nauthProvider.setPasswordEncoder(passwordEncoder()); \n\nreturn authProvider; \n}\n</code></pre> <p>Este Bean utiliza <code>UserDetailService</code> y <code>PasswordEncoder</code> para realizar el proceso de autenticaci\u00f3n. Esto significa acceder a la base de datos y comprobar el usuario y la contrase\u00f1a (con el mismo encoder que utilizamos para almacenar usuarios). Los siguientes Beans crean el <code>AuthenticationManager</code> y el encoder.</p> <pre><code>@Bean \npublic AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception { \nreturn authConfig.getAuthenticationManager(); \n} \n\n@Bean \npublic PasswordEncoder passwordEncoder() { \nreturn new BCryptPasswordEncoder(); \n}\n</code></pre> <p>Y por \u00faltimo, una de las configuraciones m\u00e1s importantes (y dif\u00edciles de entender), la cadena de filtros de seguridad. Las cadenas de filtros son c\u00f3digo que ponemos en medio entre el cliente y el servidor. Estos filtros interceptan la solicitud, la analizan y despu\u00e9s, dependiendo del resultado del filtro, simplemente pasan el control al servidor o env\u00edan una respuesta al cliente. Este filtro podr\u00eda cambiar la solicitud, a\u00f1adiendo o eliminando informaci\u00f3n que ser\u00e1 utilizada por el servidor.</p> <pre><code>@Bean \npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception { \nhttp.cors().and().csrf().disable() \n.exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and() \n.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() \n.authorizeRequests().antMatchers(\"/api/auth/**\").permitAll() \n.antMatchers(\"/api/test/**\").permitAll() \n.a\u00f1oRequest().authenticated(); \n\nhttp.authenticationProvider(authenticationProvider()); \n\nhttp.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class); \n\nreturn http.build(); \n}\n</code></pre> <p>Tenga en cuenta que:</p> <ul> <li>Habilitamos CORS (Cross-Origin Requests) y deshabilitamos CSRF (Cross Site Request Forgery)</li> <li>Establecemos la authenticationEntryPoint</li> <li>Permitimos el acceso a todos los caminos a <code>/api/auth/**</code></li> <li>Permitimos el acceso a todos los caminos a <code>/api/test/**</code></li> <li>Cualquier otra solicitud necesitar\u00e1 ser autenticada</li> </ul> <p>Por \u00faltimo, a\u00f1adimos el filtro antes y el proveedor de autenticaci\u00f3n.</p> <p>En una visi\u00f3n relajada, para entenderlo, los filtros se combinan con anotaciones que indican d\u00f3nde y cu\u00e1ndo debemos comprobar la Autenticaci\u00f3n y la Autorizaci\u00f3n.</p> <p></p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#61-authtokenfilter","title":"6.1. AuthTokenFilter","text":"<p>Esta clase contiene el proceso de token recibido de los clientes. Debe implementar <code>OncePerRequestFilter</code> y sobreescribir <code>doFilterInternal()</code>.</p> <pre><code>@Override \nprotected void doFilterInternal( \nHttpServletRequest request, \nHttpServletResponse response, \nFilterChain (filterChain) throws ServletException, IOException { \ntry { \nString jwt = parseJwt(request); \nif (jwt != null &amp;&amp; jwtUtils.validateJwtToken(jwt)) { \nString username = jwtUtils.getUserNameFromJwtToken(jwt); \n\nUserDetails userDetails = userDetailsService.loadUserByUsername(username); \nUsernamePasswordAuthenticationToken authentication = \nnew UsernamePasswordAuthenticationToken( \nuserDetails, \nnull, \nuserDetails.getAuthorities()); \nauthentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); \n\nSecurityContextHolder.getContext().setAuthentication(authentication); \n} \n} catch (Exception e) { \nlogger.error(\"Cannot set user authentication: {}\", e); \n} \n\nfilterChain.doFilter(request, response); \n}\n</code></pre> <p>En nuestras palabras, este m\u00e9todo se ejecutar\u00e1 cuando se haga una solicitud y:</p> <ul> <li>Extrae el token de la solicitud, devolviendo s\u00f3lo la informaci\u00f3n relevante (elimina <code>Bearer</code>).</li> <li>Comprueba que el token sea v\u00e1lido, y: </li> <li>Extrae el nombre de usuario (est\u00e1 en el payload del token) y </li> <li>Obtiene este <code>UserDetails</code> y crea un <code>UsernamePasswordAuthenticationToken</code> para ser inyectado en el resto de la solicitud-respuesta, obviamente con autoridades.</li> <li>Por \u00faltimo, contin\u00faa con el siguiente filtro, si existe, llamando <code>filterChain.doFilter(req,nada)</code>. Si no existe ning\u00fan filtro, el dispatcher pasa el control al controlador solicitado.</li> </ul>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#62-authentrypoint","title":"6.2. AuthEntryPoint","text":"<p>Esta clase contiene c\u00f3digo que se ejecutar\u00e1 cuando aparezca una excepci\u00f3n. Crea entonces un cuerpo gen\u00e9rico dentro de la respuesta y establece una respuesta precisa para el cliente.</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#7-controller-authorization","title":"7. Controller Authorization","text":"<p>S\u00f3lo queda decir qu\u00e9 solicitud necesita ser autorizada. Recuerda que con otras clases preparamos la autenticaci\u00f3n, \u00bfQui\u00e9n eres?. Ahora necesitamos preguntar \u00bfQu\u00e9 puedes hacer?</p> <p>Como marcamos en nuestra <code>filterChain</code>, a\u00f1adimos <code>addFilterBefore</code> para comprobar los roles. Pero, \u00bfd\u00f3nde debemos decir los roles que capturan cada solicitud? La respuesta es f\u00e1cil: los controladores. Veamos un controlador de prueba con filtro de autorizaci\u00f3n:</p> <p><pre><code>@CrossOrigin(originos = \"*\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/api/test\")\npublic class TestController { \n@GetMapping(\"/all\") \npublic String allAccess() { \nreturn \"Public Content.\"; \n} \n\n@GetMapping(\"/user\") \n@PreAuthorize(\"hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')\") \npublic String userAccess() { \nreturn \"User Content.\"; \n} \n\n@GetMapping(\"/mod\") \n@PreAuthorize(\"hasRole('MODERATOR')\") \npublic String moderatorAccess() { \nreturn \"Moderator Board.\"; \n} \n\n@GetMapping(\"/admin\") \n@PreAuthorize(\"hasRole('ADMIN')\") \npublic String adminAccess() { \nreturn \"Admin Board.\"; \n}\n}\n</code></pre> Si:</p> <ul> <li>No aparece ninguna anotaci\u00f3n: todos los roles pueden realizar esta solicitud</li> <li><code>@PreAuthorize(\"hasRole('role')\")</code> \u2192 Esta anotaci\u00f3n indica el rol que est\u00e1 autorizado para realizar esta solicitud. Puedes combinar m\u00e1s de un rol con <code>otro</code></li> </ul> <p>El proyecto completo lo puedes encontrar aqui</p>"},{"location":"Unidad%205%20Spring%20Boot/4_Spring_Security/#8-ejercicio-como-utilizar-este-proyecto","title":"8. Ejercicio. \u00bfC\u00f3mo utilizar este proyecto?","text":"<p>Probablemente tendr\u00e1s ya una API implementada y funcionando de forma no segura. Ahora tienes la tarea de fusionar con este proyecto para autorizar ciertas operaciones s\u00f3lo a usuarios registrados. Es una tarea larga (que no complicada), pero el resultado final ser\u00e1 muy gratificante.</p>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/","title":"5 Spring Hateoas","text":""},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#1-hateoas","title":"1. HATEOAS","text":"<p>Hateoas (Hypermedia as the engine of application state) es un principio de API RESTful definido por Roy Fielding. Principalmente significa que el cliente puede moverse por toda la aplicaci\u00f3n s\u00f3lo desde URI's generales en formato hipermedia. El principio implica que la API debe guiar al cliente a trav\u00e9s de la aplicaci\u00f3n devolviendo informaci\u00f3n relevante sobre los siguientes pasos potenciales, junto con cada respuesta.</p> <p>Para la conexi\u00f3n entre el servidor y el cliente, Fielding define estas cuatro caracter\u00edsticas:</p> <ul> <li>Identificaci\u00f3n \u00fanica de todos los recursos: todos los recursos deben poder ser identificados con un URI (Identificador de Recurso \u00danico).</li> <li>Interacci\u00f3n con recursos a trav\u00e9s de representaciones: Si un cliente necesita un recurso, el servidor le env\u00eda una representaci\u00f3n (por ejemplo, HTML, JSON o XML) para que el cliente pueda modificar o eliminar el recurso original.</li> <li>Mensajes expl\u00edcitos: cada mensaje intercambiado entre el servidor y el cliente debe contener todos los datos necesarios para entenderse mutuamente.</li> <li>HATEOAS: Este principio tambi\u00e9n integra una API REST. Esta estructura basada en hipermedia facilita a los clientes el acceso a la aplicaci\u00f3n, ya que no necesitan conocer nada m\u00e1s sobre la interfaz para poder acceder y navegar por ella.</li> </ul> <p>HATEOAS es, en resumidas cuentas, una de las propiedades m\u00e1s b\u00e1sicas de las API REST y, como tal, esencial en cualquier servicio REST.</p> <p>Un valor devuelto sin HATEOAS, con datos de un cliente:</p> <pre><code>{\n    \"idCliente\": 3,\n    \"nif\": \"33333333C\",\n    \"nombre\": \"Vicente\",\n    \"apellidos\": \"Mondrag\u00f3n\",\n    \"claveSeguridad\": \"1234\",\n    \"email\": \"vicente.mondragon@tia.es\",\n    \"recomendacion\": {\n      \"idRecomendacion\": 3,\n      \"observaciones\": \"Realiza muchos pedidos\"\n    },\n    \"listaCuentas\": [\n      {\n        \"idCuenta\": 8,\n        \"banco\": \"1001\",\n        \"sucursal\": \"1001\",\n        \"dc\": \"11\",\n        \"numeroCuenta\": \"1000000008\",\n        \"saldoActual\": 7500.0,\n        \"links\": [\n\n        ]\n      },\n      {\n        \"idCuenta\": 10,\n        \"banco\": \"1001\",\n        \"sucursal\": \"1001\",\n        \"dc\": \"11\",\n        \"numeroCuenta\": \"1000000010\",\n        \"saldoActual\": -3500.0,\n        \"links\": [\n\n        ]\n      }\n    ],\n    \"listaDirecciones\": [\n      {\n        \"idDireccion\": 5,\n        \"descripcion\": \"calle de la creu, 2\",\n        \"pais\": \"Espa\u00f1a\",\n        \"cp\": \"46701\"\n      }\n    ]\n  }\n</code></pre> <p>Ten en cuenta que:</p> <ul> <li>Hemos obtenido todos los datos del cliente</li> <li>No sabemos c\u00f3mo obtener datos de campos relacionados espec\u00edficos, como <code>Direccion</code> o <code>Cuenta</code>. Est\u00e1n ah\u00ed pero no sabemos c\u00f3mo obtenerlas</li> </ul> <p>La misma solicitud con HATEOAS:</p> <pre><code>{\n  \"idCliente\": 3,\n  \"nif\": \"33333333C\",\n  \"nombre\": \"Vicente\",\n  \"apellidos\": \"Mondrag\u00f3n\",\n  \"claveSeguridad\": \"1234\",\n  \"email\": \"vicente.mondragon@tia.es\",\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://localhost:9090/clientes/3\"\n    },\n    {\n      \"rel\": \"listaDirecciones\",\n      \"href\": \"http://localhost:9090/clientes/3/direcciones\"\n    },\n    {\n      \"rel\": \"listaCuentas\",\n      \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n    }\n  ]\n}\n</code></pre> <p>C\u00f3mo puedes ver:</p> <ul> <li>S\u00f3lo se env\u00edan los datos de un cliente</li> <li>Tenemos enlaces, con URI's claras para obtener informaci\u00f3n espec\u00edfica de este cliente</li> </ul> <p>y lo m\u00e1s importante Si el servidor cambia su estructura, enviar\u00e1 enlaces actualizados, y el cliente funcionar\u00e1 sin ning\u00fan problema</p>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#2-anadiendo-hateoas","title":"2. A\u00f1adiendo HATEOAS","text":""},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#21-librerias","title":"2.1. Librer\u00edas","text":"<p>Atenci\u00f3n</p> <p>En este texto, a\u00f1adiremos capacidades HATEOAS a una API RESTful desarrollada a lo largo de la unidad.</p> <p>S\u00f3lo necesitamos a\u00f1adir esta dependencia a nuestro <code>pom.xml</code>, suponiendo que hemos utilizado un proyecto iniciador de Spring:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>y ya est\u00e1.</p>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#22-wrappers-envoltorios","title":"2.2. Wrappers (Envoltorios)","text":""},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#221-punto-de-inicio","title":"2.2.1. Punto de inicio","text":"<p>Recuerda lo que hemos hecho en nuestro proyecto inicial:</p> <ul> <li>Clases Modelo o DAO \u2192 preparadas para guardar informaci\u00f3n en la base de datos. Est\u00e1n anotadas con Hibernate y son la base de nuestros repositorios. Por ejemplo, <code>Cliente</code>.</li> <li>Clases DTO preparadas para transferir datos desde nuestro modelo y hacia \u00e9ste. </li> <li>Estas clases encapsulan las DAO (a\u00f1adiendo o eliminando campos). </li> <li>Estas clases tienen m\u00e9todos para convertir entre DAO y DTO. </li> <li>Es el servicio quien realiza la conversi\u00f3n. </li> <li>El cliente nos enviar\u00e1 informaci\u00f3n en estas clases DTO. </li> <li>Estas clases pueden ser utilizadas tanto por una API Rest como por una aplicaci\u00f3n web MVC.</li> </ul> <p>Es necesario adaptar el DTO, ClienteDTO, a HATEOAS. Para ello lo envolveremos con RepresentationalModel:</p> <pre><code>package com.manu.dto;\n\nimport com.manu.model.Cliente;\nimport com.manu.model.Cuenta;\nimport com.manu.model.Direccion;\nimport com.manu.model.Recomendacion;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.hateoas.RepresentationModel;\n\nimport java.util.List;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class ClienteDTO extends RepresentationModel&lt;ClienteDTO&gt; {\n\n    private Integer idCliente;\n\n    private String nif;\n    private String nombre;\n    private String apellidos;\n    private String claveSeguridad;\n    private String email;\n    private Recomendacion recomendacion;\n    private List&lt;Cuenta&gt; listaCuentas;\n    private List&lt;Direccion&gt; direcciones;\n\n    public static ClienteDTO convertToDTO(Cliente cliente) {\n        ClienteDTO clienteDTO = new ClienteDTO();\n        clienteDTO.setIdCliente(cliente.getId());\n        clienteDTO.setNif(cliente.getNif());\n        clienteDTO.setNombre(cliente.getNombre());\n        clienteDTO.setApellidos(cliente.getApellidos());\n        clienteDTO.setClaveSeguridad(cliente.getClaveSeguridad());\n        clienteDTO.setEmail(cliente.getEmail());\n        clienteDTO.setRecomendacion(cliente.getRecomendacion());\n        clienteDTO.setListaCuentas(cliente.getListaCuentas());\n        clienteDTO.setDirecciones(cliente.getListaDirecciones());\n        return clienteDTO;\n    }\n\n    public static Cliente convertToEntity(ClienteDTO clientedto) {\n        Cliente cliente = new Cliente();\n        cliente.setId(clientedto.getIdCliente());\n        cliente.setNif(clientedto.getNif());\n        cliente.setNombre(clientedto.getNombre());\n        cliente.setApellidos(clientedto.getApellidos());\n        cliente.setClaveSeguridad(clientedto.getClaveSeguridad());\n        cliente.setEmail(clientedto.getEmail());\n        cliente.setRecomendacion(clientedto.getRecomendacion());\n        cliente.setListaCuentas(clientedto.getListaCuentas());\n        cliente.setRecomendacion(clientedto.getRecomendacion());\n        return cliente;\n    }\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#222-envoltorio-hateoas","title":"2.2.2. Envoltorio HATEOAS","text":"<p>Necesitamos definir una nueva clase para envolver nuestra respuesta HATEOAS.</p> <p>Partiendo de los DTO's, contiene toda la informaci\u00f3n de una clase, propia y relacionada (Cliente m\u00e1s Direcci\u00f3n m\u00e1s Cuentas). Con HATEOAS, como hemos mostrado recientemente, s\u00f3lo necesitamos la informaci\u00f3n propia del Cliente y necesitamos generar enlaces a entidades relacionadas. Entonces, necesitamos a\u00f1adir a la informaci\u00f3n del cliente la capacidad de generar y almacenar enlaces. La clase que lo permite es <code>RepresentationModel&lt;base_class&gt;</code> (documentaci\u00f3n completa aqu\u00ed). Esto a\u00f1adir\u00e1 a nuestras clases:</p> <ul> <li>Una estructura para guadar links</li> <li>M\u00e9todos para a\u00f1adir, comprobar y devolver links</li> </ul> <p>Para hacerlo</p> <pre><code>package com.manu.hateoas;\n\nimport com.manu.dto.ClienteDTO;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport org.springframework.hateoas.RepresentationModel;\n\nimport java.io.Serializable;\n\n@Data\n@AllArgsConstructor\npublic class ClienteHATEOAS extends RepresentationModel&lt;ClienteDTO&gt; implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n    private Integer idCliente;\n    private String nif;\n    private String nombre;\n    private String apellidos;\n    private String claveSeguridad;\n    private String email;\n\n    public static ClienteHATEOAS fromClienteDTO2HATEOAS(ClienteDTO clienteDTO) {\n        return new ClienteHATEOAS(\n                clienteDTO.getIdCliente(),\n                clienteDTO.getNif(),\n                clienteDTO.getNombre(),\n                clienteDTO.getApellidos(),\n                clienteDTO.getClaveSeguridad(),\n                clienteDTO.getEmail());\n    }\n}\n</code></pre> <p>Importante</p> <ul> <li>Al tener una API base que funciona con <code>ClienteDTO</code>, hemos creado esta clase envoltorio a partir de ella. </li> <li>Dado que HATEOAS es s\u00f3lo un formato de respuesta, puedes crearlo a partir de <code>Cliente</code> como clase base, pero debes definir tu servicio para devolver <code>Cliente</code> tambi\u00e9n. </li> <li>Es muy importante crear un m\u00e9todo de conversi\u00f3n <code>fromClienteDTO2HATEOAS</code>, que incluya los campos necesarios.</li> </ul> <p>Entonces, utilizaremos el m\u00e9todo <code>add(Link)</code> en nuestro envoltorio <code>ClienteHATEOAS</code> para a\u00f1adir tantos <code>Link</code> como sea necesario.</p> <pre><code>import static org.springframework.hateoas.server.core.DummyInvocationUtils.methodOn;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;\n\nLink self=linkTo(methodOn(controller_class.class)\n            .methodName(args))\n            .withSelfRel(); // or .withRel(String Link)\n</code></pre> <ul> <li><code>linkTo</code> \u2192 m\u00e9todo est\u00e1tico que crea un <code>Link</code> desde</li> <li><code>methodOn(class)</code> \u2192 busca en una clase de controlador un m\u00e9todo</li> <li><code>.methodName(args)</code> \u2192 obtiene una llamada real para este m\u00e9todo</li> <li>Y para etiquetar el enlace:</li> <li><code>.withSelfRel()</code> \u2192 crea un enlace llamado <code>self</code></li> <li><code>.withRel(String Link)</code> \u2192 crea un v\u00ednculo con el nombre dado.</li> </ul> <p>Ejemplos de nuestro <code>Cliente controller</code> en la siguiente secci\u00f3n</p>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#31-self-links","title":"3.1. Self links","text":"<pre><code>package com.manu.controller;\n\nimport com.manu.dto.ClienteDTO;\nimport com.manu.hateoas.ClienteHATEOAS;\nimport com.manu.service.ClienteService;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport static org.springframework.hateoas.server.core.DummyInvocationUtils.methodOn;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;\n\n@RestController\npublic class ClienteController {\n\n    private static final Logger myLog = Logger.getLogger(ClienteController.class.getName());\n\n    @Autowired\n    private ClienteService clienteService;\n\n    @Autowired\n    private HttpServletRequest context;\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Value(\"${developer.name}\")\n    private String devName;\n\n\n    @GetMapping(\"/\")\n    public String index() {\n        String res = \"Hola desde Spring\\n\";\n        res += \"Estas ejecutando \" + appName + \"\\n\";\n        res += \". Estando desarrollado por \" + devName + \"\\n\";\n        return res;\n    }\n\n        @GetMapping(\"/clientes\")\n        public List&lt;ClienteDTO&gt; listClientes() {\n            myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n            return clienteService.listAllClientes();\n        }\n\n\n\nClienteDTO clienteDTO = clienteService.getClienteById(idCliente);\nif (clienteDTO == null) {\n        return ResponseEntity.notFound().build();\n    }\n\n// Convertimos DTO a modelo HATEOAS\nClienteHATEOAS clienteHATEOAS = ClienteHATEOAS.fromClienteDTO2HATEOAS(clienteDTO);\n\n// A\u00f1adimos enlaces HATEOAS\nclienteHATEOAS.add(\n        linkTo(methodOn(ClienteController.class).showClienteById(idCliente))\n                .withSelfRel()\n</code></pre> <p>Este ejemplo:</p> <ul> <li>Carga un <code>ClienteDTO</code> del <code>ClienteService</code> actual.</li> <li>Luego busca en la clase <code>ClienteController</code> un m\u00e9todo llamado <code>showClienteById</code>.</li> <li>Hace una llamada interna y busca el camino y vincula el argumento al camino (\u00bfrecuerdas <code>@PathVariable</code>?)</li> <li>Por \u00faltimo, obtiene el camino (ruta) completo con el argumento y lo almacena en el Link con la referencia <code>self</code></li> </ul> <p>El resultado ser\u00e1 algo as\u00ed:</p> <pre><code>{\n  \"rel\": \"self\",\n  \"href\": \"http://localhost:9090/clientes/3\"\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#32-referenciando-links","title":"3.2. Referenciando links","text":"<pre><code>clienteHATEOAS.add(\n        linkTo(methodOn(CuentaController.class).listCuentasCliente(idCliente))\n                  .withRel(\"listaCuentas\")\n    );\n</code></pre> <p>Este ejemplo:</p> <ul> <li>Carga un <code>ClienteDTO</code> del <code>ClienteService</code> actual.</li> <li>Luego busca en la clase <code>CuentaController</code> un m\u00e9todo llamado <code>listCuentasCliente</code>.</li> <li>Hace una llamada interna y busca el camino y vincula el argumento al camino (\u00bfrecuerdas <code>@PathVariable</code>?)</li> <li>Por \u00faltimo, obtiene el camino (ruta) completo con el argumento y lo almacena en el Link con la referencia <code>listaCuentas</code> pasada como par\u00e1metro a <code>withRel</code></li> </ul> <p>El resultado ser\u00e1 algo as\u00ed: <pre><code>{\n  \"rel\": \"listaCuentas\",\n  \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n}\n</code></pre></p>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#33-anadiendo-enlaces-a-nuestro-envoltorio-y-ejemplo-completo","title":"3.3. A\u00f1adiendo enlaces a nuestro envoltorio y ejemplo completo","text":"<p>Una vez hemos visto como construir los enlaces con HATEOAS veamos el m\u00e9todo completo:</p> <p>El m\u00e9todo del controlador para obtener un <code>Cliente</code> ser\u00e1:</p> <pre><code>@GetMapping(\"/clientes/{idCliente}\")\n    public ResponseEntity&lt;ClienteHATEOAS&gt; showClienteById(@PathVariable Integer idCliente) {\n\n        ClienteDTO clienteDTO = clienteService.getClienteById(idCliente);\n        if (clienteDTO == null) {\n            return ResponseEntity.notFound().build();\n        }\n\n        // Convertimos DTO a modelo HATEOAS\n        ClienteHATEOAS clienteHATEOAS = ClienteHATEOAS.fromClienteDTO2HATEOAS(clienteDTO);\n\n        // A\u00f1adimos enlaces HATEOAS\n        clienteHATEOAS.add(\n                linkTo(methodOn(ClienteController.class).showClienteById(idCliente))\n                        .withSelfRel()\n        );\n        clienteHATEOAS.add(\n                linkTo(methodOn(DireccionController.class).listDireccionesCliente(idCliente))\n                        .withRel(\"listaDirecciones\")\n        );\n        clienteHATEOAS.add(\n                linkTo(methodOn(CuentaController.class).listCuentasCliente(idCliente))\n                        .withRel(\"listaCuentas\")\n        );\n\n        return ResponseEntity.ok(clienteHATEOAS);\n    }\n</code></pre> <p>y el resultado ser\u00e1 algo as\u00ed:</p> <pre><code>{\n  \"idCliente\": 3,\n  \"nif\": \"33333333C\",\n  \"nombre\": \"Vicente\",\n  \"apellidos\": \"Mondrag\u00f3n\",\n  \"claveSeguridad\": \"1234\",\n  \"email\": \"vicente.mondragon@tia.es\",\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://localhost:9090/clientes/3\"\n    },\n    {\n      \"rel\": \"listaDirecciones\",\n      \"href\": \"http://localhost:9090/clientes/3/direcciones\"\n    },\n    {\n      \"rel\": \"listaCuentas\",\n      \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n    }\n  ]\n}\n</code></pre> <p>Esto nos dar\u00e1 las URL's que nos permitir\u00e1n acceder a las direcciones del cliente 3 y las cuentas del cliente 3 ... pero ... \u00bfS\u00f3lo con lo que tenemos ser\u00e1 suficiente?</p> <p>Parece evidente que cuando invoquemos estos otros m\u00e9todos deberemos tener desarrollados los controladores de direcciones y cuentas para que respondan a estos.</p> <p>Veamos el ejemplo de cuentas.</p> <p>En el interfaz<code>CuentaService</code> a\u00f1adiomos un m\u00e9todo a implementar que recibir\u00e1n un id de cliente.</p> <pre><code> List&lt;CuentaDTO&gt; listCuentasCliente (Integer idCliente);\n</code></pre> <p>El interfaz quedar\u00e1 as\u00ed:</p> <pre><code>package com.manu.service;\n\nimport com.manu.dto.CuentaDTO;\n\nimport java.util.List;\n\npublic interface CuentaService {\n    CuentaDTO saveCuenta(CuentaDTO cuentaDTO);\n    CuentaDTO getCuentaById(Long id);\n    List&lt;CuentaDTO&gt; listAllCuentas();\n    List&lt;CuentaDTO&gt; listCuentasCliente (Integer idCliente);\n    void deleteCuenta(Long id);\n}\n</code></pre> <p>La implementaci\u00f3n en la clase <code>CuentaServiceImpl</code> :</p> <pre><code>    @Override\n    public List&lt;CuentaDTO&gt; listCuentasCliente(Integer idCliente) {\n        // Buuscamos el cliente con el m\u00e9todo de clienteRepository\n        Cliente cliente = clienteRepository.findById(Long.valueOf(idCliente))\n                .orElse(null);\n\n        if (cliente == null) {\n            // El cliente no existe -&gt; el controller ya traduce null a 404\n            return null;\n        }\n\n        // Obtenermos su lista de direcciones\n        if (cliente.getListaCuentas() == null || cliente.getListaCuentas().isEmpty()) {\n            // Cliente existe pero no tiene direcciones\n            return new ArrayList&lt;&gt;();\n        }\n\n        // Convertimos su lista de direcciones en un objetoDireccionDTO\n        return cliente.getListaCuentas()\n                .stream()\n                .map(CuentaDTO::convertToDTO)\n                .toList();\n    }\n</code></pre> <p>Podemos observar en este m\u00e9todo que disponemos de <code>clienteRepository</code>. Esta variable la hemos injectado con <code>@Autowired</code> en la clase, de tal manera que podemos acceder a los m\u00e9todos de ClienteRepository.</p> <p>Aqu\u00ed podemos ver la implementaci\u00f3n completa de este servicio:</p> <pre><code>package com.manu.service;\n\nimport com.manu.dto.CuentaDTO;\nimport com.manu.model.Cliente;\nimport com.manu.model.Cuenta;\nimport com.manu.repository.ClienteRepository;\nimport com.manu.repository.CuentaRespository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class CuentaServiceImpl implements CuentaService{\n\n    @Autowired\n    private CuentaRespository cuentaRespository;\n\n    @Autowired\n    private ClienteRepository clienteRepository;\n\n\n    @Override\n    public CuentaDTO saveCuenta(CuentaDTO cuentaDTO) {\n        Cuenta cuenta = CuentaDTO.convertToEntity(cuentaDTO);\n        cuentaRespository.save(cuenta);\n        return cuentaDTO;\n    }\n\n    @Override\n    public CuentaDTO getCuentaById(Long id) {\n        Optional&lt;Cuenta&gt; cuenta = cuentaRespository.findById(id);\n        return cuenta.map(CuentaDTO::convertToDTO).orElse(null);\n    }\n\n    @Override\n    public List&lt;CuentaDTO&gt; listAllCuentas() {\n        List&lt;Cuenta&gt; lista = cuentaRespository.findAll();\n        List&lt;CuentaDTO&gt; listaResultado = new ArrayList&lt;CuentaDTO&gt;();\n        for (int i = 0; i &lt; lista.size(); ++i) {\n            listaResultado.add(CuentaDTO.convertToDTO(lista.get(i)));\n        }\n        return listaResultado;\n    }\n\n    @Override\n    public List&lt;CuentaDTO&gt; listCuentasCliente(Integer idCliente) {\n        // Buuscamos el cliente con el m\u00e9todo de clienteRepository\n        Cliente cliente = clienteRepository.findById(Long.valueOf(idCliente))\n                .orElse(null);\n\n        if (cliente == null) {\n            // El cliente no existe -&gt; el controller ya traduce null a 404\n            return null;\n        }\n\n        // Obtenermos su lista de direcciones\n        if (cliente.getListaCuentas() == null || cliente.getListaCuentas().isEmpty()) {\n            // Cliente existe pero no tiene direcciones\n            return new ArrayList&lt;&gt;();\n        }\n\n        // Convertimos su lista de direcciones en un objetoDireccionDTO\n        return cliente.getListaCuentas()\n                .stream()\n                .map(CuentaDTO::convertToDTO)\n                .toList();\n    }\n\n    @Override\n    public void deleteCuenta(Long id) {\n        cuentaRespository.deleteById(id);\n    }\n}\n</code></pre>"},{"location":"Unidad%205%20Spring%20Boot/5_Spring_Hateoas/#4-trabajo-pendiente","title":"4. Trabajo pendiente","text":"<p>Ahora, haciendo una petici\u00f3n simple a un <code>Cliente</code> tenemos acceso a toda la informaci\u00f3n y siguientes acciones disponibles en los datos de la respuesta</p> <p>Esto permite al servidor poder evolucionar sin tener que modificar los clientes que le hacen peticiones, ya que cualquier modificaci\u00f3n ser\u00e1 inmediatamente notificada a los usuarios de las API en las propias respuestas.</p> <p>Ahora te toca a ti completar el proyecto desarrollado a\u00f1adiendo las clases necesarias y a\u00f1adiendo el HATEOAS en estos modelos. Si est\u00e1s inmerso en un proyecto, es adecuado que lo adaptaras a HATEOAS.</p> <p>Completa con direcciones y recomendaciones.</p>"},{"location":"Unidad%206%20MongoDB/1_NoSQL.es/","title":"1. Bases de datos NoSQL","text":"<p>El movimiento NoSQL (Not Only SQL) contempla todas aquellas alternativas a los sistemas de gesti\u00f3n de bases de datos relacionales tradicionales. Las bases de datos orientadas a objetos podr\u00edan ser un primer enfoque en estas bases de datos NoSQL. Sin embargo, existen otros modelos, con un enfoque totalmente diferente. Estas son bases de datos basadas en documentos, en pares clave-valor o en gr\u00e1ficos.</p> <p>Aunque algunas de las caracter\u00edsticas planteadas por estos paradigmas se est\u00e1n incorporando a los est\u00e1ndares SQL y los SGBD relacionales, la realidad actual es que este tipo de bases de datos est\u00e1 creciendo considerablemente en muchas \u00e1reas. A principios de los a\u00f1os 2000 surgi\u00f3 la web 2.0, que supuso la conversi\u00f3n de los usuarios en generadores de contenido. Posteriormente, con la web 3.0 o web sem\u00e1ntica, Internet se convierte en una gran base de datos, y el acceso a \u00e9sta ya no es exclusivo de las aplicaciones web, sino de todo tipo de aplicaciones y apps. Actualmente, estamos ante el auge de la inteligencia artificial y la web 4.0, como una evoluci\u00f3n de todo lo anterior. Con todo esto, podemos imaginar la gran cantidad de datos que los servidores deben almacenar, y que requiere un almacenamiento m\u00e1s deslocalizado, distribuido y suficientemente eficiente para soportar millones de consultas diarias.</p> <p>En esta unidad nos centraremos en las bases de datos tipo documento, espec\u00edficamente MongoDB, una base de datos basada en documentos JSON, muy popular en la web.</p>"},{"location":"Unidad%206%20MongoDB/1_NoSQL.es/#11-tipo-de-bases-de-datos","title":"1.1. Tipo de bases de datos","text":"<p>Podemos encontrar</p> <ol> <li> <p>Bases de datos clave-valor \u2192 Es un modelo de base de datos bastante sencillo y popular, donde cada elemento se identifica con una clave \u00fanica, siguiendo el modelo de tabla de hash, por lo que los datos se recuperan muy r\u00e1pidamente. Los objetos generalmente se almacenan como objetos binarios (BLOBs). Algunas bases de datos de este tipo son Cassandra (Apache), Bigtable (Google) o Dynamo (Amazon).</p> </li> <li> <p>Bases de datos documentales \u2192 Este modelo almacena la informaci\u00f3n en forma de documentos, generalmente <code>XML</code> o <code>JSON</code>, y se utiliza una clave \u00fanica para cada registro, de forma que se permiten b\u00fasquedas clave-valor. La diferencia respecto a las bases de datos clave-valor anteriores es que aqu\u00ed el valor es el documento en s\u00ed mismo, no datos binarios. Como veremos m\u00e1s adelante, son muy vers\u00e1tiles, por lo que ni siquiera necesitamos tener una estructura com\u00fan para los documentos que guardamos. El m\u00e1ximo exponente de ese tipo de base de datos es MongoDB.</p> </li> <li> <p>Bases de datos en grafos \u2192 Un grafo es un conjunto de v\u00e9rtices o nodos unidos por aristas, que nos permiten representar relaciones entre ellos. Las bases de datos en grafos intentan seguir este modelo, por lo que la informaci\u00f3n se representa como nodos en un grafo, y las relaciones entre ellos se representan por aristas. De esta forma, aprovechando la teor\u00eda de grafos, podemos recorrer la informaci\u00f3n de manera \u00f3ptima. Algunos ejemplos de este tipo de base de datos son Amazon Neptune, JanusGraph (Apache), SQL Server (Microsoft) o Neo4j.</p> </li> </ol>"},{"location":"Unidad%206%20MongoDB/2_MongoDB.es/","title":"2. MongoDB","text":"<p>MongoDB es una base de datos orientada a documentos, basada en el almacenamiento de sus estructuras de datos en documentos de tipo JSON con un esquema din\u00e1mico. Aunque empez\u00f3 a ser desarrollada por la empresa 10gen, hoy es un proyecto de c\u00f3digo abierto, con una gran comunidad de usuarios.</p> <p>Un servidor MongoDB puede contener varias bases de datos, y cada una de ellas est\u00e1 formada por un conjunto de colecciones, que podr\u00edamos comparar con las tablas de una base de datos relacional. Cada colecci\u00f3n almacena un conjunto de documentos JSON, formados por atributos clave-valor, que ser\u00edan los registros de una base de datos relacional.</p> <p>A grandes rasgos, podr\u00edamos establecer las siguientes comparaciones:</p> Modelo relacional MongoDB Base de datos relacional Base de datos orientada a documentos Tabla Colecci\u00f3n Registro/Fila Documentos JSON Columnas y valores de la tabla Pares Clave:Valor"},{"location":"Unidad%206%20MongoDB/2_MongoDB.es/#21-configuracion-y-primera-ejecucion","title":"2.1. Configuraci\u00f3n y primera ejecuci\u00f3n","text":"<p>MongoDB cubre una amplia gama de posibilidades, desde servidores de bases de datos locales hasta bases de datos en la nube. En su sitio web https://www.mongodb.com, podemos descubrir los diferentes productos y servicios que se ofrecen, entre ellos:</p> <ul> <li>Servidor MongoDB, con sus dos versiones, la Community, versi\u00f3n gratuita y comunitaria, y la Enterprise, su versi\u00f3n comercial orientada al mundo empresarial y con caracter\u00edsticas adicionales que mejoran el rendimiento y el soporte. Adem\u00e1s del servidor en s\u00ed, tambi\u00e9n se ofrece el servidor listo para uso en contenedores a trav\u00e9s de operadores de Kubernetes. El servidor est\u00e1 disponible en varias plataformas: Linux, Solaris, MacOS X y Windows. </li> <li>Podemos utilizar el mongo shell o compass o Studio3T gr\u00e1fico como cliente, instalado en nuestro sistema.</li> <li>MongoDB Atlas, la plataforma MongoDB en la nube (DBaaS o DataBase as a Service), que permite su despliegue en servicios como AWS, Azure o Google Cloud.</li> <li>Realm, un servicio de datos dise\u00f1ado para aplicaciones m\u00f3viles y web, y que incluye, adem\u00e1s de DB en la nube, varios servicios de backend totalmente gestionados.</li> </ul> <p>Utilizaremos como curso actual todos los servidores a trav\u00e9s de contenedores docker. Podr\u00edamos descargar la imagen docker v\u00eda:</p> <pre><code>docker pull mongo\n</code></pre> <p>y entonces crear el contenedor con:</p> <pre><code>docker run --name mongodb-srv \n-e MONGO_INITDB_ROOT_USERNAME=\"root\" \n-e MONGO_INITDB_ROOT_PASSWORD=\"toor\" \n-p 27017:27017 \n-d mongo\n</code></pre> <p>Entonces ya podemos conectar desde la herramienta elegida. Yo har\u00e9 uso de Studio3T.</p> <p>Se puede descargar de aqu\u00ed: https://studio3t.com/es/free/ </p>"},{"location":"Unidad%206%20MongoDB/2_MongoDB.es/#22-conexion-herramienta-grafica","title":"2.2. Conexi\u00f3n herramienta gr\u00e1fica","text":"<p>Una vez instalada la aplicaci\u00f3n, deber\u00e1s crear una conexi\u00f3n, previamente tienes que tener levantado el contenedor de mognodb:</p> <pre><code>sudo docker start mongodb-srv\n</code></pre> <p>Debes seleccionar primero la pesta\u00f1a Server en la que configurar\u00e1s: - el nombre de la conexi\u00f3n, en mi caso root - la direcci\u00f3n del servicio, localhost - puerto de escucha, 27017</p> <p></p> <p>Luego la pesta\u00f1a Authentication:</p> <ul> <li>Authentication Mode: Basic</li> <li>User Name: root</li> <li>Password: toor</li> <li>Authentication DB: admin</li> </ul> <p></p> <p>Pulsa a Test Connection y si es ok, Save.</p> <p></p> <p>Puesto que la herramienta no nos permite cargar ficheros json directamente, lo que vamos a realizar es hacerlo cargando una colecci\u00f3n de pel\u00edculas directamente.</p> <p>Esta colecci\u00f3n la podemos descargar es pelis.json</p> <p>Luego nos situaremos en el directorio en el que se encuentre este fichero y desde el terminal lanzaremos el siguiente comando:</p> <p><pre><code>sudo docker cp pelis.json mongodb-srv:/tmp/pelis.json\n</code></pre> Con este copiamos a un directorio temporal de mongodb el fichero json.</p> <p>Luego lo importamos as\u00ed:</p> <pre><code>sudo docker exec -it mongodb-srv mongoimport   --username root   --password toor   --authenticationDatabase admin   --db Cine1_V1   --collection Peli   --file /tmp/pelis.json   --jsonArray   --drop\n</code></pre> <p></p> <p>Y lo vemos en Studio3T</p> <p></p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/","title":"3. Trabajando con MongoDB: Operaciones b\u00e1sicas de shell","text":""},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#31-colecciones-y-documentos","title":"3.1. Colecciones y Documentos","text":"<p>Como ya sabemos, la unidad b\u00e1sica de informaci\u00f3n con la que trabaja MongoDB es el documento, que ser\u00eda el equivalente a un registro en un modelo relacional. Estos son documentos JSON, formados por pares clave-valor, y que representan la informaci\u00f3n de forma bastante intuitiva. Los servidores de MongoDB, por su parte, almacenar\u00e1n estos datos en formato BSON (Binary JSON), un formato de serializaci\u00f3n binaria.</p> <p>En cuanto a los documentos JSON para MongoDB, es necesario tener en cuenta algunos aspectos:</p> <ul> <li>En cuanto a las claves: </li> <li>No pueden ser nulas. </li> <li>Pueden consistir en cualquier car\u00e1cter UTF-8, excepto los caracteres <code>.</code> o <code>$</code>. </li> <li>Son sensibles a may\u00fasculas y min\u00fasculas. </li> <li>Deben ser \u00fanicas dentro del mismo documento.</li> <li>En cuanto a los valores: </li> <li>Pueden ser de cualquier tipo permitido.</li> <li>En cuanto al documento: </li> <li>Debe tener un campo <code>_id</code>, con un valor \u00fanico, que actuar\u00e1 como identificador del documento. </li> <li>Si no especificamos esta clave, MongoDB la generar\u00e1 autom\u00e1ticamente, con un objeto de tipo <code>ObjectId</code>.</li> </ul> <p>Si los documentos son el equivalente a los registros, las colecciones son el equivalente a las tablas, con la diferencia de que las colecciones tienen un esquema din\u00e1mico, con el que los documentos de la misma colecci\u00f3n pueden presentar claves o tipos de datos diferentes entre ellos.</p> <p>Los nombres de las colecciones estar\u00e1n sujetos a las siguientes restricciones:</p> <ul> <li>No pueden ser la cadena vac\u00eda (<code>`````), ni el car\u00e1cter</code>null<code>, ni contener el s\u00edmbolo</code>$`.</li> <li>Podemos utilizar el punto (<code>.</code>) en los nombres de las colecciones para a\u00f1adir prefijos, pero las colecciones no se pueden crear con el prefijo <code>system.</code>, ya que \u00e9ste se utiliza para colecciones internas del sistema. Por ejemplo, <code>db.system.test</code> no ser\u00eda v\u00e1lido, pero <code>db.systema.test</code> s\u00ed lo ser\u00eda.</li> </ul> <p>Para realizar las pruebas trabajaremos con el Shell que nos ofrece Studio3T.</p> <p>Una vez conectemos, bot\u00f3n derecho sobre la base de datos que nos interesa y opci\u00f3n de Open Intellishell:</p> <p></p> <p>Que nos abrir\u00e1 el shell a trav\u00e9s del cual ejecutar los comandos de mongodb:</p> <p></p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#32-operaciones-basicas-con-mongodb","title":"3.2. Operaciones b\u00e1sicas con MongoDB","text":"<p>A continuaci\u00f3n, veremos algunas de las operaciones b\u00e1sicas que podemos realizar en MongoDB:</p> <ul> <li><code>insertOne(documento)</code> \u2192 A\u00f1ade un documento a la colecci\u00f3n: </li> <li><code>db.collection.insertOne({ a:1 })</code></li> <li><code>insertMany(documents)</code> \u2192 A\u00f1ade un conjunto de documentos a la colecci\u00f3n: </li> <li><code>db.collection.insertMany([{ a:1 },{ a:2 },{ a:3,b:5 }])</code></li> <li><code>find(criteria)</code> \u2192 Obtiene todos los documentos de una colecci\u00f3n que coinciden con el patr\u00f3n especificado. </li> <li><code>db.collection.find({a:1})</code>. Tenga en cuenta que el patr\u00f3n ser\u00e1 tambi\u00e9n un objeto JSON.</li> <li><code>findOne(Criterion)</code> \u2192 Obtiene un elemento de la colecci\u00f3n que coincide con el patr\u00f3n. </li> <li><code>db.collection.findOne()</code></li> <li><code>updateOne(Criterion, Operation, [options])</code> y <code>updateMany(Criterion, Operation, [options])</code> \u2192 Actualiza uno (o varios en el caso de updateMany) documentos de la colecci\u00f3n. Requiere dos par\u00e1metros: </li> <li>los criterios de b\u00fasqueda del documento a actualizar y </li> <li>la operaci\u00f3n de actualizaci\u00f3n. </li> <li>Admite un tercer par\u00e1metro opcional para opciones. </li> <li><code>db.collection.updateOne({a:1}, {$set: {a:2}})</code></li> <li><code>deleteOne(Criterion)</code> y <code>deleteMany(Criterion)</code> \u2192 Elimina los documentos de una colecci\u00f3n que coinciden con los criterios. </li> <li><code>db.collection.deleteOne({a:1})</code></li> </ul> <p>En las siguientes secciones profundizaremos en las distintas operaciones.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#33-tipo-de-datos","title":"3.3. Tipo de datos","text":"<p>Los tipos de datos con los que trabaja MongoDB son similares a los que podemos encontrar en JavaScript y Java. MongoDB admite los tipos b\u00e1sicos descritos en la siguiente tabla:</p> <ul> <li><code>null</code> \u2192 Representa tanto el valor nulo como un campo que no existe.</li> <li><code>boolean</code> \u2192 Permite los valores true y false.</li> <li><code>number</code> \u2192 Representa valores num\u00e9ricos de punto flotante. Si queremos utilizar tipos enteros o enteros largos, debemos utilizar nuestras propias clases: NumberInt (32 bits) o NumberLong (64 bits).</li> <li><code>String</code> \u2192 Representa cualquier cadena de texto UTF-8 v\u00e1lida.</li> <li><code>Date</code> \u2192 Representa fechas, expresadas en milisegundos.</li> <li><code>array</code> \u2192 Listas de valores que se representan como vectores.</li> <li><code>Documentos incrustados</code> \u2192 Los documentos pueden tener otros documentos incrustados en ellos.</li> <li><code>ObjectId</code> \u2192 \u00c9ste es el tipo por defecto para los campos <code>_id</code>, y est\u00e1 dise\u00f1ado para generar f\u00e1cilmente valores \u00fanicos a nivel global.</li> </ul>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#331-fecha","title":"3.3.1. Fecha","text":"<p>Mongo utiliza el tipo <code>Date</code> de JavaScript. Cuando generamos un nuevo objeto de tipo Date, debemos utilizar el operador <code>New</code>, ya que de lo contrario obtendr\u00edamos una representaci\u00f3n de la fecha en forma de cadena. Por ejemplo, si definimos las variables <code>a</code> y <code>b</code> de la siguiente manera:</p> <pre><code>test&gt; let a=Date()\n\ntest&gt; let b=new Date()\n</code></pre> <p>los resultados ser\u00edan bastante diferentes:</p> <pre><code>test&gt; a\nWed Jan 14 2026 18:23:32 GMT+0100 (hora est\u00e1ndar de Europa central)\n\ntest&gt; typeof(a)\nstring\n\ntest&gt;b\nISODate('2026-01-14T17:23:50.465Z')\n\ntest&gt; typeof(b)\nobject\n</code></pre>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#332-arrays","title":"3.3.2. Arrays","text":"<p>Los arrays pueden utilizarse para representar colecciones ordenadas, como listas o colas, o colecciones desordenadas, como conjuntos. Como en JavaScript, ya diferencia de otros lenguajes, como Java, cada elemento del vector puede tener un tipo de dato diferente, incluidos otros objetos de tipo vector.</p> <p>Veamos algunos ejemplos sobre vectores en JavaScript y, por tanto, en MongoDB:</p> <pre><code>// array creation\ntest&gt; let v={objetos: [\"casa\", 10, {texto: \"hola\"}, false] }\n\n// ask for objects components\ntest&gt; v\n{ objetos: [ 'casa', 10, { texto: 'hola' }, false ] }\n\ntest&gt; v.objetos\n[ 'casa', 10, { texto: 'hola' }, false ]\n\n// ask for array cells\ntest&gt; v.objetos[1]\n10\n\ntest&gt; v.objetos[2]\n{ texto: 'hola' }\n\n// change values\ntest&gt; v.objetos[3]=!v.objetos[3]\ntrue\n\ntest&gt; v\n{ objetos: [ 'casa', 10, { texto: 'hola' }, true ] }\n</code></pre>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#333-documentos-incrustados","title":"3.3.3. Documentos incrustados","text":"<p>Un par clave-valor en un documento puede tener otro documento como valor. Esto se conoce como documentos incrustados (embedded), y ser\u00eda cuando se utiliza un objeto JSON dentro de otro. Por ejemplo:</p> <pre><code>&gt; let peli={ \ntitulo: \"Rogue One. En Star Wars Story.\", \na\u00f1o: 2016, \ndirector: { \nn\u00famero: \"Gareth\", \ncogidos: \"Edwards\", \na\u00f1o_nacimiento: 1975, \nnacionalidad: \"brit\u00e1nica\" \n} \n}\n</code></pre> <p>Como puede verse, el documento en s\u00ed mismo contiene informaci\u00f3n sobre la pel\u00edcula y su director. En un modelo relacional, normalmente tendr\u00edamos dos tablas relacionadas entre s\u00ed. En este caso, es posible que si queremos mantener informaci\u00f3n espec\u00edfica sobre los directores, acabemos con informaci\u00f3n redundante.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#334-que-son-los-objetids","title":"3.3.4. \u00bfQu\u00e9 son los OBjetIds?","text":"<p>La clase ObjectId utiliza 12 bytes, organizados de la siguiente manera:</p> <p></p> <ul> <li>Timestamp (bytes 0-3) \u2192 La marca de tiempo en segundos desde el 1 de enero de 1970.</li> <li>Machine ID (bytes 4-6) \u2192 Identificador \u00fanico de la m\u00e1quina, normalmente un hash de su hostname.</li> <li>PID (bytes 7-8) \u2192 Identificador del proceso que genera el ObjectID, para garantizar la unicidad dentro de la misma m\u00e1quina.</li> <li>Incremento (bytes 9-11) \u2192 Valor auto-incremental, para garantizar la unicidad en el mismo segundo, m\u00e1quina y proceso.</li> </ul> <p>Como puede verse, es un mecanismo m\u00e1s robusto que un campo auto-incremental como en MySQL. Esto corresponde a la naturaleza distribuida de MongoDB, por lo que los objetos se pueden generar en un entorno multi-host.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#34-anadiendo-informacion-a-las-colecciones","title":"3.4. A\u00f1adiendo informaci\u00f3n a las colecciones","text":"<p>La forma natural de a\u00f1adir elementos a la base de datos es a trav\u00e9s de los diferentes m\u00e9todos de inserci\u00f3n, disponibles en todas las colecciones.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#341-insertone","title":"3.4.1. <code>insertOne()</code>","text":"<p>Permite insertar un documento en la colecci\u00f3n. Por ejemplo, para insertar el objeto peli creado en la secci\u00f3n anterior, podemos hacer. Para ello antes definiremos la siguiente variable:</p> <pre><code>let peli2={\n    \"titulo\": \"Ciudad de Dios\",\n    \"anyo\": 2002,\n    \"director\": \"Fernando Meirelles\",\n    \"pais\": \"Brasil\",\n    \"genero\": [\"Crimen\", \"Drama\"],\n    \"duracion_minutos\": 130,\n    \"clasificacion\": \"No recomendada menores de 18 a\u00f1os\",\n    \"actores_principales\": [\"Alexandre Rodrigues\", \"Leandro Firmino\", \"Phellipe Haagensen\"],\n    \"puntuacion_imdb\": 8.6,\n    \"oscars\": 4\n  }\n</code></pre> <p></p> <pre><code>test&gt; db.Peli.insertOne(peli2)\n\n{\n  acknowledged: true,\n  insertedId: ObjectId('6967d5ac3ec39d568ab0834b')\n}\n</code></pre> <p></p> <p>Como puede verse, la respuesta es un documento JSON que contiene un valor booleano que indica si la operaci\u00f3n ha sido exitosa, y un ObjectID, con el ID asignado autom\u00e1ticamente.</p> <p>Importante</p> <p>Tenga en cuenta:</p> <ul> <li>Si la colecci\u00f3n a la que a\u00f1adimos un documento no existe, se crear\u00e1 autom\u00e1ticamente.</li> <li>En cuanto al campo <code>_id</code>, como podemos ver, se gener\u00f3 autom\u00e1ticamente. Sin embargo, podemos indicar este identificador, sin que sea de tipo ObjectId, cuya \u00fanica restricci\u00f3n es que sea \u00fanico, para evitar duplicados.</li> <li>No hemos utilizado ning\u00fan esquema para la colecci\u00f3n, puesto que cada documento que insertamos puede tener un esquema diferente.</li> </ul>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#342-insertmany","title":"3.4.2. <code>insertMany()</code>","text":"<p>Permite a\u00f1adir varios documentos a una colecci\u00f3n. Entonces, debemos proporcionar un array de documentos:</p> <pre><code>// we create three objects\nlet peli3={\n    \"titulo\": \"Regreso al futuro\",\n    \"anyo\": 1985,\n    \"director\": \"Robert Zemeckis\",\n    \"pais\": \"Estados Unidos\",\n    \"genero\": [\"Aventura\", \"Comedia\", \"Ciencia ficci\u00f3n\"],\n    \"duracion_minutos\": 116,\n    \"clasificacion\": \"Todos los p\u00fablicos\",\n    \"actores_principales\": [\"Michael J. Fox\", \"Christopher Lloyd\", \"Lea Thompson\"],\n    \"puntuacion_imdb\": 8.5,\n    \"oscars\": 1,\n    \"taquilla_global_millones\": 388.8\n};\nlet peli4= {\n    \"titulo\": \"El bueno, el feo y el malo\",\n    \"anyo\": 1966,\n    \"director\": \"Sergio Leone\",\n    \"pais\": \"Italia\",\n    \"genero\": [\"Western\"],\n    \"duracion_minutos\": 178,\n    \"clasificacion\": \"No recomendada menores de 13 a\u00f1os\",\n    \"actores_principales\": [\"Clint Eastwood\", \"Eli Wallach\", \"Lee Van Cleef\"],\n    \"puntuacion_imdb\": 8.8,\n    \"taquilla_global_millones\": 38.9\n};\nlet peli5={\n    \"titulo\": \"El se\u00f1or de los anillos: El retorno del rey\",\n    \"anyo\": 2003,\n    \"director\": \"Peter Jackson\",\n    \"pais\": \"Nueva Zelanda\",\n    \"genero\": [\"Aventura\", \"Drama\", \"Fantas\u00eda\"],\n    \"duracion_minutos\": 201,\n    \"clasificacion\": \"No recomendada menores de 12 a\u00f1os\",\n    \"actores_principales\": [\"Elijah Wood\", \"Viggo Mortensen\", \"Ian McKellen\"],\n    \"puntuacion_imdb\": 9.0,\n    \"oscars\": 11,\n    \"taquilla_global_millones\": 1146.0\n};\n\n// insert them, in array way\ntest&gt; db.Peli.insertMany([peli3, peli4, peli5])\n{\n  acknowledged: true,\n  insertedIds: {\n    '0': ObjectId('6967d7a13ec39d568ab0834c'),\n    '1': ObjectId('6967d7a13ec39d568ab0834d'),\n    '2': ObjectId('6967d7a13ec39d568ab0834e')\n  }\n}\n</code></pre> <p>Importante</p> <p>Si se produce un error durante la inserci\u00f3n, ni el documento que provoca el error ni los siguientes documentos se insertar\u00e1n en la colecci\u00f3n.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#35-eliminando-informacion","title":"3.5. Eliminando informaci\u00f3n","text":"<p>Para eliminar documentos de una colecci\u00f3n utilizaremos los comandos <code>deleteOne()</code>, <code>deleteMany()</code> o <code>findOneAndDelete()</code>, proporcion\u00e1ndoles como par\u00e1metro un JSON con una condici\u00f3n que queremos que cumplan el documento o documentos a eliminar.</p> <ul> <li>El comando deleteOne s\u00f3lo eliminar\u00e1 el primer elemento que coincida con los criterios, as\u00ed que si queremos eliminar un documento espec\u00edfico, debemos utilizar criterios que correspondan a identificadores \u00fanicos, como el <code>_id</code>.</li> <li>El comando deleteMany eliminar\u00e1 todos los documentos que coincidan con los criterios.</li> </ul> <p>Tanto <code>deleteOne</code> como <code>deleteMany</code> devuelven un documento con un booleano, indicando si la operaci\u00f3n se ha realizado, as\u00ed como el n\u00famero de elementos eliminados (deletedCount).</p> <p>Por su parte, findOneAndDelete tambi\u00e9n elimina un documento, bas\u00e1ndose en criterios de selecci\u00f3n y ordenaci\u00f3n, pero tambi\u00e9n devolviendo el documento que ha sido eliminado.</p> <p>Por ejemplo, creamos unacolecci\u00f3n con varios elementos:</p> <pre><code>db.pruebas.insertMany([{x:1}, {x:2}, {x:3}, {x:4}, {x:5}, {x:6}, {x:7}]);\n\n// to delete one document\ntest&gt; db.pruebas.deleteOne({})\n{ acknowledged: true, deletedCount: 1 }\n\n// as no confition is set, is satisfied by all documentos,\n// then first document will be deleted\n\n// to delete several documentos, for instance its x's value greather than 3\ntest&gt; db.pruebas.deleteMany({x:{$gt:3}})\n{ acknowledged: true, deletedCount: 4 }\n\n// delete and return a documento\ntest&gt; db.pruebas.findOneAndDelete({x:2})\n{ _id: ObjectId('6967d8bfb96045836cb0834c'), x: 2 }\n</code></pre> <p>Si queremos eliminar todos los documentos de una colecci\u00f3n, podr\u00edamos utilizar el comando <code>drop</code> en lugar de eso, pero hay que ir con mucho cuidado, ya que tambi\u00e9n eliminar\u00e1 alguna metainformaci\u00f3n.</p> <pre><code>test&gt; db.pruebas.drop()\n</code></pre>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#36-actualizacion-de-documentos","title":"3.6. Actualizaci\u00f3n de documentos","text":"<p>Para actualizar documentos, podemos optar por actualizaciones de reemplazo, utilizando el m\u00e9todo <code>replaceOne()</code>, o realizar modificaciones en los documentos existentes, utilizando los m\u00e9todos <code>updateOne()</code>, <code>updateMany()</code> y <code>findOneAndUpdate()</code>. Estos m\u00e9todos recibir\u00e1n dos argumentos: el primero ser\u00e1 los criterios o condiciones que deben cumplir los documentos a actualizar, y el segundo ser\u00e1 un documento con el nuevo documento o las actualizaciones a aplicar.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#361-actualizacion-de-reemplazo-replace","title":"3.6.1. Actualizaci\u00f3n de reemplazo (replace)","text":"<p>La operaci\u00f3n de reemplazo, como su nombre indica, reemplaza un documento entero que cumple los criterios de actualizaci\u00f3n con otro nuevo documento. Por ejemplo, creamos una nueva colecci\u00f3n de calendarios, para almacenar contactos, con informaci\u00f3n sobre tel\u00e9fonos:</p> <p><pre><code>test&gt; db.agenda.insertOne({n\u00famero:\"Jose\", telefonos:[{trabajo:\"55512345\", casa:\"555111222\"}]})\n{\n  acknowledged: true,\n  insertedId: ObjectId('6967db9ba67922ae4bb0834b')\n}\n</code></pre> Como podemos ver, este m\u00e9todo devuelve el <code>_id</code> del objeto, a trav\u00e9s del cual podremos identificar este documento de forma inequ\u00edvoca. As\u00ed, podr\u00edamos reemplazar este documento por otro mediante:</p> <pre><code>test&gt; db.agenda.replaceOne({\"_id\":ObjectId(\"6967db9ba67922ae4bb0834b\")}, \n{n\u00famero: \"Jose\", \ncorreos:[{trabajo: \"jose@empresa.com\"}, \n{personal: \"jose@proveedor.com\"}]} )\n\n// and the response is\n{\n  acknowledged: true,\n  insertedId: null,\n  matchedCount: 1,\n  modifiedCount: 1,\n  upsertedCount: 0\n}\n</code></pre> <p>Como puede verse, se trata de reemplazar todo el documento, con lo que podemos incluso modificar su estructura.</p> <p>Como hemos anticipado, las modificaciones se realizan utilizando los m\u00e9todos <code>updateOne()</code>, <code>updateMany()</code> y <code>findOneAndUpdate()</code>. Similar a las operaciones de eliminaci\u00f3n, el m\u00e9todo <code>updateOne()</code> modificar\u00e1 s\u00f3lo el primer documento que coincida con los criterios dados y el m\u00e9todo <code>updateMany()</code>, todos aquellos que coincidan con los criterios. Por su parte, el m\u00e9todo <code>findOneAndUpdate()</code> modifica el documento y devuelve el documento original por defecto, aunque esto es configurable a trav\u00e9s de opciones.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#3611-modificadores","title":"3.6.1.1. Modificadores","text":"<p>Los modificadores son claves especiales que nos permiten especificar operaciones de actualizaci\u00f3n m\u00e1s complejas. Normalmente, no necesitaremos reemplazar todo el documento, como en el caso anterior, sino a\u00f1adir o modificar campos espec\u00edficos:</p> <ul> <li><code>$set</code> \u2192 Asigna un valor a un campo del documento. Si no existe, lo crear\u00e1. </li> <li><code>db.collection.updateOne({criterio}, {$set: {campo:valor} });</code></li> <li><code>$unset</code> \u2192 Elimina un campo de uno o varios documentos. Como necesitamos introducir un par clave-valor, a\u00f1adiremos un booleano como valor. </li> <li><code>db.collection.updateMany({criterio}, {$unset: {campo:true} });</code></li> <li><code>$inc</code> \u2192 Incrementa o decrementa el valor num\u00e9rico de una clave (no se refiere al identificador), creando una nueva si no existe. </li> <li><code>db.collection.updateOne({criterio}, {$inc: {campo:incremento} });</code></li> <li><code>$push</code> \u2192 A\u00f1ade elementos a un array. Si el array no existe, lo crea con los elementos que indicamos en el push, mientras que si ya existe, los a\u00f1ade al final del mismo. </li> <li><code>db.collection.update({criterio}, {$push: {nombre_array:{lista_de_valores} } });</code></li> <li><code>$pull</code> \u2192 Elimina elementos de un array bas\u00e1ndose en alg\u00fan criterio. </li> <li><code>db.collection.update({criterio},{$pull:{vector:elemento}})</code>.</li> <li><code>$pop</code> \u2192 Elimina elementos de un array tratado como una pila o cola, es decir, eliminando el primer (-1) o \u00faltimo (1) elemento. </li> <li><code>db.collection.update({criterio},{$pop:{vector: [ -1 | 1 ] }})</code></li> </ul> <p>Information</p> <p>Estos modificadores funcionan tanto con <code>updateOne</code> como con <code>updateMany</code>.</p>"},{"location":"Unidad%206%20MongoDB/3_ShellOperations.es/#3612-upserts","title":"3.6.1.2. Upserts","text":"<p>Cuando no se encuentra ning\u00fan documento que coincida con los criterios para una actualizaci\u00f3n, como es de esperar, no se produce ning\u00fan cambio en la colecci\u00f3n. Por otra parte, en ocasiones, podemos desear que si un documento con ciertos criterios no existe cuando queremos modificarlo, se cree. Esto se logra a trav\u00e9s de actualizaciones especiales, llamadas <code>upserts</code>. Con esta operaci\u00f3n, nos ahorramos buscar primero en la colecci\u00f3n para saber si debemos realizar una operaci\u00f3n de inserci\u00f3n (si no existe) o de modificaci\u00f3n (si existe).</p> <p>Para realizar un upsert, utilizaremos el tercer argumento de las actualizaciones, que consiste en un documento con diferentes opciones en formato clave-valor, a\u00f1adiendo la clave upsert a true.</p> <pre><code>db.collection.updateOne({criter\u00eda},{modification}, {upsert:true});\n</code></pre>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/","title":"4. Consultas en Mongo","text":""},{"location":"Unidad%206%20MongoDB/4_Queries.es/#41-find","title":"4.1. find()","text":"<p>El comando find nos permite recuperar los documentos de una colecci\u00f3n que coinciden con un criterio especificado como documento JSON. Su sintaxis b\u00e1sica es la siguiente:</p> <p><pre><code>db.collection.find({criter\u00eda_in_JSON_formato});\n</code></pre> Debemos tener en cuenta aspectos como los tipos de datos que utilizamos, que es importante, puesto que el documento <code>{edad:20}</code> no es el mismo que <code>{edad:\"20\"}</code>.</p> <p>Por otro lado, tambi\u00e9n debemos considerar que el documento vac\u00edo <code>{}</code> coincide con todos los documentos, por lo que la consulta <code>db.collection.find({})</code> devolver\u00eda todos los objetos de la colecci\u00f3n.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#411-que-claves-recuperar","title":"4.1.1. \u00bfQu\u00e9 claves recuperar?","text":"<p>El comando find devuelve los documentos completos que coinciden con los criterios de selecci\u00f3n. Si no queremos obtener todas las claves, podemos especificar qu\u00e9 claves queremos consultar, incluy\u00e9ndolas en un segundo par\u00e1metro:</p> <pre><code>db.collection.find({query_document}, {key_1:1, key_2:1});\n</code></pre> <p>Como podemos ver, este segundo par\u00e1metro tambi\u00e9n se expresa en formato JSON (de nuevo) y est\u00e1 formado por dos claves (<code>key_1</code> y <code>key_2</code>), ambas con un valor de 1. Este valor num\u00e9rico tambi\u00e9n se interpreta como <code>true</code>. Es decir, aqu\u00ed especificamos cu\u00e1les son los campos que queremos mostrar. En caso de que queramos mostrar todos los campos y esconder algunos, utilizar\u00edamos la misma sintaxis, pero ahora utilizando un 0 para aquellos campos que queremos esconder.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#412-operaciones-de-comparacion","title":"4.1.2. Operaciones de comparaci\u00f3n","text":"<p>MongoDB nos permite realizar comparaciones con datos num\u00e9ricos, siempre utilizando el formato de documento JSON <code>db.collection.find({key: {$operator:value} });</code></p> <p>Los operadores de comparaci\u00f3n que podemos utilizar en MongoDB son:</p> <ul> <li><code>$lt</code> \u2192 Menor que</li> <li><code>$lte</code> \u2192 Menor o igual que</li> <li><code>$gt</code> \u2192 Mayor que</li> <li><code>$gte</code> \u2192 Mayor o igual que</li> </ul>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#413-operacion-or","title":"4.1.3. Operaci\u00f3n OR","text":"<p>Si queremos realizar un filtro o consulta donde se cumplan varias condiciones (una operaci\u00f3n AND), s\u00f3lo deberemos separarlas por comas en el mismo documento JSON que utilizamos como criterio. Por otra parte, si lo que queremos es llevar a cabo una operaci\u00f3n OR, debemos utilizar un operador especial.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#414-operadores-in-y-nin","title":"4.1.4. Operadores <code>$IN</code> y <code>$NIN</code>","text":"<p>Un caso especial de OR es cuando queremos comprobar si un campo se encuentra dentro de un conjunto espec\u00edfico de valores. Es decir, si es un valor u otro. Por eso utilizamos el operador <code>$in</code>, de la siguiente manera:</p> <pre><code>db.collection.find({key:{$in:[vector_de_valores]}})\n</code></pre> <p>De forma similar, existe el operador <code>$nin</code> (Not In), que obtiene los documentos donde el valor especificado no se encuentra en la lista. Debemos tener en cuenta que en este \u00faltimo caso tambi\u00e9n se mostrar\u00e1n aquellos documentos que tengan un valor nulo para la clave.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#415-operador-or","title":"4.1.5. Operador <code>$OR</code>","text":"<p>Cuando queremos realizar la operaci\u00f3n OR en diferentes campos del documento, utilizaremos el operador <code>$OR</code>, al que pasamos un vector de posibles condiciones, de la siguiente manera:</p> <pre><code>db.collection.find({$or:[condition1, condition2,...]})\n</code></pre> <p>Attention</p> <p>Las condiciones del array son condiciones en json</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#416-operador-not","title":"4.1.6. Operador <code>$NOT</code>","text":"<p>El operador <code>$NOT</code> es un operador metacondicional, es decir, siempre se aplica a otro criterio, invirtiendo su valor de certeza. Su sintaxis ser\u00eda:</p> <pre><code>db.collection.find({key:{$not: {criterion}}}).pretty();\n</code></pre>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#417-operador-exists","title":"4.1.7. Operador <code>$EXISTS</code>","text":"<p>Recordemos que en MongoDB, los documentos no tienen una estructura o esquema com\u00fan, por lo que es posible que existan claves definidas s\u00f3lo en algunos de ellos. El operador <code>$exists</code> se utiliza para comprobar la existencia o no de una determinada clave. La sintaxis a utilizar ser\u00eda:</p> <pre><code>db.collection.find({key:{ $exists: true|false }})\n</code></pre> <p>Con esto obtenemos los documentos para los que la clave existe o no, dependiendo de si hemos indicado true o false en la consulta.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#42-resultados-de-las-consultas-y-tipos-de-datos","title":"4.2. Resultados de las consultas y tipos de datos","text":"<p>Los tipos de datos en MongoDB pueden tener algunos comportamientos especiales. Veremos algunos casos para saber qu\u00e9 hacer en determinadas situaciones.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#421-valores-nulos","title":"4.2.1. valores nulos","text":"<p>El valor null coincide con las siguientes situaciones:</p> <ul> <li>Cuando el valor de la clave es null, o</li> <li>Cuando la clave no existe en el documento (en este caso, normalmente se dice que el campo no est\u00e1 informado)</li> </ul>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#422-expresiones-regulares-y-cadenas-de-caracteres","title":"4.2.2. Expresiones regulares y cadenas de caracteres","text":"<p>Cuando aplicamos un filtro de documento por un campo de texto, puede que no conozcamos exactamente el valor del campo por el que queremos filtrar. Las expresiones regulares ofrecen un potente mecanismo para la coincidencia de cadenas.</p> <p>MongoDB nos permite utilizar estas expresiones de diversas formas, ya sea utilizando expresiones regulares de Javascript o utilizando el operador <code>$regex</code>, que utiliza Expresiones Regulares Compatibles con Perl (PCRE). Las expresiones regulares de Javascript se expresan utilizando la siguiente sintaxis:</p> <pre><code>{ key: /pattern/&lt;options&gt; }\n</code></pre> <p>Como podemos ver, utilizamos un patr\u00f3n similar a una cadena de texto, pero utilizando la barra inclinada <code>/</code> como delimitador en lugar de las comillas (<code>``). Por su parte, si utilizamos el operador</code>$regex`, podemos utilizar la siguiente sintaxi:</p> <pre><code>{ key: { $regex: /pattern/, $options: '&lt;options&gt;' } }\n{ key: { $regex: 'pattern', $options: '&lt;options&gt;' } }\n{ key: { $regex: /pattern/&lt;options&gt; } }\n</code></pre> <p>Podemos encontrar varias opciones para expresiones regulares:</p> <ul> <li><code>i</code> \u2192 Las coincidencias no distinguen entre may\u00fasculas y min\u00fasculas: </li> <li><code>{name:/john/i}</code> </li> <li><code>{name: { $regex: 'john',$options: 'y'}}</code></li> <li><code>m</code> \u2192 Permite incluir caracteres como <code>^</code> o <code>$</code>, para coincidir al principio o al final, en cadenas con m\u00faltiples l\u00edneas. </li> <li><code>{name:/^John/m}</code> </li> <li><code>{name: { $regex: 'John', $options: 'm'}}</code></li> <li><code>x</code> Ignora los espacios en blanco en el patr\u00f3n <code>$regex</code>, siempre que no est\u00e9n escapados o incluidos en una clase de caracteres. </li> <li><code>{name: { $regex: ' J oh n',$options: 'x'}}</code></li> <li><code>s</code> Permite que el car\u00e1cter punto (<code>.</code>) represente cualquier car\u00e1cter, incluyendo el car\u00e1cter de nueva l\u00ednea. </li> <li><code>{name:/ju.n/s}</code> </li> <li><code>{name: { $regex: 'thu.n',$options: 's'}}</code></li> </ul> <p>Puede encontrar m\u00e1s informaci\u00f3n sobre expresiones regulares y casos particulares en los que se recomienda utilizar un tipo de expresi\u00f3n u otra en la documentaci\u00f3n oficial de MongoDB sobre <code>$regex</code> aqu\u00ed.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#43-consideraciones-sobre-el-tipo-de-datos-de-las-consultas","title":"4.3. Consideraciones sobre el tipo de datos de las consultas","text":""},{"location":"Unidad%206%20MongoDB/4_Queries.es/#431-consultas-con-arrays","title":"4.3.1. Consultas con arrays","text":"<p>Para buscar elementos coincidentes dentro de un array, procedemos con la misma sintaxis como si fuera cualquier otra clave, utilizando el documento de consulta <code>{key:value}</code>, siendo la clave un array, y el valor, ya sea un n valor que debe contener el array, u otro vector ordenado que queremos que coincida exactamente.</p> <p>Por ejemplo:</p> <ul> <li><code>db.collection.find({ my_vector : value })</code> \u2192 Coincide con todos los documentos en los que el vector <code>my_vector</code> aparece, en la posici\u00f3n que sea, el valor indicado. </li> <li><code>db.users.find({roles:\"admin\"})</code> muestra los usuarios que en el array <code>roles</code> tienen el rol admin (u otros).</li> <li><code>db.collection.find({ my_vector : [value] })</code> \u2192 Coincide con todos los documentos en los que el vector <code>my_vector</code> aparece s\u00f3lo el valor indicado. </li> <li><code>db.users.find({roles:[\"admin\"]})</code> muestra a los usuarios que tienen exactamente el rol admin.</li> </ul> <p>Adem\u00e1s, tambi\u00e9n podemos utilizar expresiones regulares o dem\u00e1s operadores que hemos visto como condiciones.</p> <p>Por otra parte, tambi\u00e9n podemos referirnos a un elemento espec\u00edfico del vector por su \u00edndice, utilizando la notaci\u00f3n de puntos y entre comillas:</p> <ul> <li><code>db.collection.find({\"my_vector.position\" :[value]})</code> </li> <li><code>db.users.find({\"roles.2\":[\"admin\"]})</code> muestra el usuario que tiene como tercer rol admin</li> </ul>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#432-el-operador-all","title":"4.3.2. El operador <code>$all</code>","text":"<p>Con <code>$all</code> podemos especificar m\u00e1s de un elemento coincidente dentro del array:</p> <ul> <li><code>db.collection.find({ my_vector : {$all:[value1, value2,...]}})</code> </li> <li><code>db.users.find({roles:{$all:[\"mod\",\"admin\"]}})</code> muestra los usuarios que tienen los roles mod y admin (y posiblemente otros).</li> </ul>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#433-el-operador-size","title":"4.3.3. El operador <code>$size</code>","text":"<p>Utilizando <code>$size</code> podemos incluir condiciones sobre la longitud de los vectores:</p> <ul> <li><code>db.collection.find({ my_vector : {$size:size} })</code></li> </ul>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#434-el-operador-slice","title":"4.3.4. El operador <code>$slice</code>","text":"<p>El operador slice nos permite obtener un subconjunto de los elementos del vector, con la siguiente sintaxis:</p> <ul> <li><code>key: {$slice: x}</code>: </li> <li>si x&gt;0 obtiene los primeros x elementos </li> <li>si x&lt;0, obtiene los \u00faltimos x elementos</li> <li><code>key: {$slice: [ x , y ] }</code> Obtener y elementos desde el elemento a la posici\u00f3n x del documento embebido</li> </ul> <p>Para consultar documentos embebidos, simplemente especifique el camino completo de la clave, cerrado entre comillas y separado por puntos: <code>db.collection.find({\"path.to.key\":value_or_condition})</code></p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#44-cursores","title":"4.4. Cursores","text":"<p>Cuando realizamos una consulta, MongoDB devuelve los resultados utilizando cursos, que son punteros en los resultados de la consulta, como conectores en la unidad 2. Los clientes que utilizan Mongo iteran sobre estos cursos para recuperar los resultados, y ofrecen un conjunto de funcionalidades, como limitar los resultados, etc.</p> <p>Cuando realizamos una consulta en una base de datos con muchos resultados, el cliente (<code>mongosh</code>) devuelve s\u00f3lo 20 resultados y el mensaje <code>Type \"it\" for more</code>, para continuar iterando el cursor.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#441-limite-skip-y-suerte","title":"4.4.1. L\u00edmite, Skip y Suerte","text":"<p>MongoDB nos permite realizar ciertas limitaciones en los resultados. Entre ellas, podemos destacar:</p> <ul> <li><code>limit</code> \u2192 Para limitar el n\u00famero de resultados</li> <li><code>skip</code> \u2192 Salta un n\u00famero espec\u00edfico de resultados.</li> <li><code>sort</code> \u2192 Ordena los resultados. Necesita un objeto JSON con las claves para ordenar, y un valor de 1 para ordenar ascendentemente o -1 para ordenar descendentemente.</li> </ul>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#45-introduccion-al-marco-de-agrupacion","title":"4.5. Introducci\u00f3n al Marco de Agrupaci\u00f3n","text":"<p>Las consultas de agrupaci\u00f3n que realiz\u00e1bamos con operadores como <code>GROUP BY</code>, <code>SUM</code> o <code>COUNT</code> en SQL se pueden realizar con el Marco de Agrupaci\u00f3n de MongoDB. Las consultas de agrupaci\u00f3n tienen la siguiente sintaxis:</p> <pre><code>db.collection.aggregate( [&lt;pipeline&gt;] )\n</code></pre> <p>El pipeline o tuberia tiene un concepto similar a las tiber\u00edas de Unix: los resultados de una orden se pasan como entrada a otra, para obtener resultados conjuntamente.</p> <p>Las operaciones que podemos realizar dentro de estas consultas de agrupaci\u00f3n son:</p> <ul> <li><code>$project</code> \u2192 Para realizar una proyecci\u00f3n sobre un conjunto de datos de entrada, a\u00f1adiendo, eliminando o recalculando campos para que la salida sea diferente.</li> <li><code>$match</code> \u2192 Filtra la entrada para reducir el n\u00famero de documentos, dejando s\u00f3lo aquellos que cumplen ciertas condiciones.</li> <li><code>$limit</code> \u2192 Restringe el n\u00famero de resultados.</li> <li><code>$skip</code> \u2192 Salta un cierto n\u00famero de registros.</li> <li><code>$unwind</code> \u2192 Convierte un array para devolverlo separado en documentos.</li> <li><code>$group</code> \u2192 Agrupa documentos seg\u00fan cierta condici\u00f3n.</li> <li><code>$sort</code> \u2192 Ordena un conjunto de documentos, seg\u00fan el campo especificado.</li> <li><code>$geoNear</code>\u2192 Se utiliza como datos geoespaciales, devolviendo los documentos ordenados por proximidad seg\u00fan un punto geoespacial.</li> </ul> <p>Para realizar c\u00e1lculos sobre los datos producidos por las tuber\u00edas, utilizaremos expresiones. Las expresiones son funciones que realizan cierta operaci\u00f3n sobre un grupo de documentos, vector o campo espec\u00edfico. Algunas de estas expresiones son <code>$max</code>, <code>$min</code>, <code>$divide</code> o <code>$substr</code>.</p> <p>Puede encontrar mucha m\u00e1s informaci\u00f3n sobre agregaciones a la documentaci\u00f3n oficial de MongoDB.</p>"},{"location":"Unidad%206%20MongoDB/4_Queries.es/#46-ejercicios","title":"4.6. Ejercicios","text":"<p>Seguimos trabajando con la colecci\u00f3n de pel\u00edculas. En este caso, utilizaremos el terminal mongosh (o Studio3T si lo prefieres), y realizaremos las siguientes consultas sobre esta colecci\u00f3n.</p> <ol> <li>Obtenga todas las producciones que se estrenaron en <code>2023</code> o que tienen 180 o m\u00e1s minutos de duraci\u00f3n.</li> <li>Obtenga todas las pel\u00edculas que NO se estrenaron entre los a\u00f1os <code>2000</code> y <code>2010</code>.</li> <li>Obtenga todas las pel\u00edculas para las que la clave \"oscars\" no est\u00e1 definida.</li> <li>Obtenga el t\u00edtulo de todas las pel\u00edculas que comienzan con la cadena <code>The</code>, independientemente de may\u00fasculas o min\u00fasculas.</li> <li>Obtenga el t\u00edtulo de todas las pel\u00edculas que contienen el g\u00e9nero comedia (<code>Comedia</code>).</li> <li>Muestre el t\u00edtulo y los g\u00e9neros de las pel\u00edculas que contienen el g\u00e9nero comedia (<code>Comedia</code>) o thriller (<code>Thriller</code>) o acci\u00f3n (<code>Acci\u00f3n</code>).</li> <li>Obtenga el t\u00edtulo y los g\u00e9neros de las pel\u00edculas que tienen tres g\u00e9neros.</li> <li>Obtenga las pel\u00edculas con una calificaci\u00f3n de <code>puntuacion_imdb</code> superior a <code>4</code>.</li> <li>Haga la misma consulta que antes, pero limitando el n\u00famero de documentos a 10.</li> <li>Ahora muestre el t\u00edtulo y la calificaci\u00f3n de aquellas pel\u00edculas con una calificaci\u00f3n superior a 4, ordenadas por calificaci\u00f3n (de m\u00e1s alta a m\u00e1s baja) y limitando los resultados a 10.</li> </ol>"},{"location":"Unidad%206%20MongoDB/5_Mongo_Java.es/","title":"5. MongoDB y Java","text":"<p>Vamos a ver c\u00f3mo acceder a MongoDB desde nuestros programas Java. Primeramente, como vimos en la unidad 2, estudiaremos c\u00f3mo acceder directamente y despu\u00e9s desde ORM.</p>"},{"location":"Unidad%206%20MongoDB/5_Mongo_Java.es/#51-drivers","title":"5.1. Drivers","text":"<p>Como sabemos, para conectar desde nuestras aplicaciones a una base de datos necesitamos un controlador o driver. MongoDB ofrece drivers oficiales para una multitud de plataformas, incluyendo C, C++, C#, NodeJS, Python, y por supuesto, Java, entre otros muchos.</p> <p>Focaliz\u00e1ndonos en Java, MongoDB nos ofrece dos drivers:</p> <ul> <li>El driver Java para aplicaciones s\u00edncronas.</li> <li>El driver de Reactive Streams para el procesamiento de Streams as\u00edncronos.</li> </ul> <p>Aunque actualmente existe una tendencia hacia la programaci\u00f3n reactiva, trabajaremos con el driver Java s\u00edncrono para facilitar la comprensi\u00f3n y centrarnos en el acceso real a los datos.</p>"},{"location":"Unidad%206%20MongoDB/5_Mongo_Java.es/#511-el-driver-java","title":"5.1.1. El driver Java","text":"<p>Utilizando el MongoDB Driver para Java podemos conectar tanto a una base de datos local o remota, como a un cluster de MongoDB Atlas. Este driver (MongoDB Java Driver) se puede encontrar en los repositorios Maven, proporcionando un gran n\u00famero de clases e interfaces para facilitar el trabajo con MongoDB desde Java.</p> <p>En un proyecto Gradle deber\u00edamos utilizar:</p> <pre><code>// Source: https://mvnrepository.com/artifact/org.mongodb/mongodb-driver-sync\nimplementation(\"org.mongodb:mongodb-driver-sync:5.6.2\")\n</code></pre> <p>mientras que en un proyecto Maven:</p> <pre><code>&lt;!-- Source: https://mvnrepository.com/artifact/org.mongodb/mongodb-driver-sync --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;\n    &lt;artifactId&gt;mongodb-driver-sync&lt;/artifactId&gt;\n    &lt;version&gt;5.6.2&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Adem\u00e1s vamos a a\u00f1adir en el pom.xml el gestor de logs de tal manera que de forma eficiente podamos gestionar los niveles de informaci\u00f3n. Para ello a\u00f1adimos las siguientes dependencias:</p> <pre><code>        &lt;!-- Source: https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n            &lt;version&gt;2.25.3&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n            &lt;version&gt;2.20.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Una vez hecho esto, debemos crear dentro del directorio resources el fichero logback.xml y dentro del mismo configurar los niveles de log:</p> <pre><code>&lt;configuration&gt;\n    &lt;!-- Appender para consola --&gt;\n    &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n    &lt;!-- \ud83d\udd39 MODO VERBOSE: Cambia a DEBUG --&gt;\n    &lt;!-- \ud83d\udd38 MODO NORMAL: Cambia a INFO --&gt;\n    &lt;!-- \ud83d\udd34 MODO SILENCIOSO: Cambia a ERROR --&gt;\n\n    &lt;!-- Nivel espec\u00edfico para MongoDB --&gt;\n    &lt;logger name=\"org.mongodb.driver\" level=\"ERROR\"/&gt;\n\n    &lt;!-- Nivel para tu aplicaci\u00f3n --&gt;\n    &lt;logger name=\"org.cipfpcheste.dam2\" level=\"INFO\"/&gt;\n\n    &lt;!-- Nivel global --&gt;\n    &lt;root level=\"ERROR\"&gt;\n        &lt;appender-ref ref=\"CONSOLE\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"Unidad%206%20MongoDB/5_Mongo_Java.es/#52-conexion-a-una-base-de-datos","title":"5.2. Conexi\u00f3n a una base de datos","text":"<p>Para conectar y comunicarnos con una base de datos necesitamos a un cliente. En el caso del driver de Java para MongoDB, el cliente se implementa a trav\u00e9s de la clase MongoClient.</p> <p>La clase <code>MongoClient</code> representa un conjunto de conexiones a un servidor MongoDB. Estas conexiones son seguras para hilos, es decir, varios hilos de ejecuci\u00f3n pueden acceder a ellos de forma segura.</p> <p>La forma de crear instancias de <code>MongoClient</code> es a trav\u00e9s del m\u00e9todo <code>MongoClients.create()</code>. Adem\u00e1s, por lo general, s\u00f3lo necesitamos una instancia de esta clase, incluso en aplicaciones multi-hilo. El m\u00e9todo <code>MongoClients.create</code> toma como argumento una <code>Connection String</code>, con el siguiente formato simplificado (los par\u00e1metros entre corchetes son opcionales):</p> <pre><code>mongodb:// [usuario: contrase\u00f1a @] host[:port] /?opciones\n</code></pre> <p>As\u00ed, una forma de obtener, por ejemplo, una conexi\u00f3n al servidor local ser\u00eda:</p> <pre><code>String uri = \"mongodb://localhost:27017\";\nMongoClient mongoClient = MongoClients.create(uri);\n</code></pre> <p>La clase MongoClient, entre otros, soporta los siguientes m\u00e9todos:</p> <ul> <li><code>getDatabase(String name)</code> \u2192 Obtiene una referencia a una base de datos cuyo nombre se pasa como argumento.</li> <li><code>listDatabaseNames()</code> \u2192 Obtiene una lista de Strings (interfaz <code>MongoIterable</code>) con los nombres de las bases de datos del servidor.</li> <li><code>close()</code> \u2192 Cierra la conexi\u00f3n con el servidor. Siempre debe hacerse cuando ya no se vaya a utilizar.</li> </ul>"},{"location":"Unidad%206%20MongoDB/5_Mongo_Java.es/#521-mongodatabase","title":"5.2.1. MongoDatabase","text":"<p>El m\u00e9todo <code>getDatabase()</code> de la clase <code>MongoClient</code> devuelve una referencia a un objeto que implementa la interfaz <code>MongoDatabase</code>, que representa una conexi\u00f3n a una base de datos. Esta interfaz define los siguientes m\u00e9todos:</p> <ul> <li><code>getCollection(String name)</code> \u2192 Obtiene una referencia a la colecci\u00f3n.</li> <li><code>listCollectionNames()</code> \u2192 Obtiene una lista de Strings (interfaz <code>MongoIterable</code>) con los nombres de las colecciones de la base de datos.</li> <li><code>listCollections()</code> \u2192 Obtiene una lista de referencias (<code>MongoCollection</code>) en las colecciones de la base de datos.</li> <li><code>createCollection(String name)</code> \u2192 Crea una nueva colecci\u00f3n con el nombre especificado en la base de datos.</li> <li><code>drop()</code> \u2192 Elimina la base de datos.</li> </ul> <p>Aqu\u00ed encontrar\u00e1s un ejemplo de conexi\u00f3n y listado de bases de datos y colecciones de un servidor dado:</p> <pre><code>package org.cipfpcheste.dam2;\n\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport org.bson.Document;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) {\n        // Conector b\u00e1sico\n        conectorBasico();\n\n        // Conector con opciones\n        conectorAvanzado();\n        // Conector para operaciones CRUD\n        operacionesCRUD();\n    }\n\n    /**\n     * Conector b\u00e1sico a MongoDB\n     */\n    public static void conectorBasico() {\n        System.out.println(\"=== CONECTOR B\u00c1SICO MONGODB ===\");\n\n        // 1. Cadena de conexi\u00f3n simple\n        String connectionString = \"mongodb://root:toor@localhost:27017/Cine1_V1?authSource=admin\";\n\n        try (MongoClient mongoClient = MongoClients.create(connectionString)) {\n            System.out.println(\"Conexi\u00f3n establecida exitosamente\");\n\n            // 2. Acceder a una base de datos\n            MongoDatabase database = mongoClient.getDatabase(\"Cine1_V1\");\n            System.out.println(\"Base de datos: \" + database.getName());\n\n            // 3. Acceder a una colecci\u00f3n\n            MongoCollection&lt;Document&gt; collection = database.getCollection(\"Peli\");\n            System.out.println(\"Colecci\u00f3n: \" + collection.getNamespace());\n            System.out.println(\"Documentos en colecci\u00f3n: \" + collection.countDocuments());\n\n        } catch (Exception e) {\n            System.err.println(\"Error de conexi\u00f3n: \" + e.getMessage());\n        }\n\n    }\n\n    /**\n     * Conector avanzado con opciones\n     */\n    public static void conectorAvanzado() {\n        System.out.println(\"\\n=== CONECTOR AVANZADO MONGODB ===\");\n\n        // Cadena de conexi\u00f3n con autenticaci\u00f3n\n        String connectionString = \"mongodb://root:toor@localhost:27017/Cine1_V1?authSource=admin\";\n\n        // Con opciones adicionales\n        String connectionStringWithOptions =\n                \"mongodb://localhost:27017\" +\n                        \"/?maxPoolSize=50\" +\n                        \"&amp;w=majority\" +\n                        \"&amp;retryWrites=true\" +\n                        \"&amp;readPreference=primary\";\n\n        try (MongoClient mongoClient = MongoClients.create(connectionString)) {\n\n            // Listar bases de datos\n            System.out.println(\"Bases de datos disponibles:\");\n            mongoClient.listDatabaseNames().forEach(System.out::println);\n\n            // Acceder a la base de datos peliculasdb\n            MongoDatabase db = mongoClient.getDatabase(\"Cine1_V1\");\n\n            // Listar colecciones\n            System.out.println(\"\\nColecciones en peliculasdb:\");\n            db.listCollectionNames().forEach(System.out::println);\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Operaciones CRUD b\u00e1sicas\n     */\n    public static void operacionesCRUD() {\n        System.out.println(\"\\n=== OPERACIONES CRUD B\u00c1SICAS ===\");\n\n        String connectionString = \"mongodb://root:toor@localhost:27017/Cine1_V1?authSource=admin\";\n\n        try (MongoClient mongoClient = MongoClients.create(connectionString)) {\n            MongoDatabase database = mongoClient.getDatabase(\"Cine1_V1\");\n            MongoCollection&lt;Document&gt; peliculas = database.getCollection(\"Peli\");\n\n            // 1. INSERTAR un documento\n            Document nuevaPelicula = new Document(\"titulo\", \"Inception\")\n                    .append(\"anyo\", 2010)\n                    .append(\"director\", \"Christopher Nolan\")\n                    .append(\"pais\", \"Estados Unidos\")\n                    .append(\"genero\", java.util.Arrays.asList(\"Ciencia ficci\u00f3n\", \"Acci\u00f3n\", \"Thriller\"))\n                    .append(\"duracion_minutos\", 148)\n                    .append(\"puntuacion_imdb\", 8.8);\n\n            peliculas.insertOne(nuevaPelicula);\n            System.out.println(\"Documento insertado: \" + nuevaPelicula.getObjectId(\"_id\"));\n\n            // 2. BUSCAR documentos\n            System.out.println(\"\\nPel\u00edculas de Christopher Nolan:\");\n            peliculas.find(new Document(\"director\", \"Christopher Nolan\"))\n                    .forEach(doc -&gt; System.out.println(\"- \" + doc.getString(\"titulo\") + \" (\" + doc.getInteger(\"anyo\") + \")\"));\n\n            // 3. ACTUALIZAR un documento\n            peliculas.updateOne(\n                    new Document(\"titulo\", \"Inception\"),\n                    new Document(\"$set\", new Document(\"puntuacion_imdb\", 8.9))\n            );\n            System.out.println(\"\\nPuntuaci\u00f3n actualizada\");\n\n            // 4. ELIMINAR un documento\n            peliculas.deleteOne(new Document(\"titulo\", \"Inception\"));\n            System.out.println(\"Documento eliminado\");\n\n            // 5. CONTAR documentos\n            long total = peliculas.countDocuments();\n            System.out.println(\"\\nTotal de pel\u00edculas: \" + total);\n\n            // 6. AGGREGATION b\u00e1sica\n            System.out.println(\"\\nPel\u00edculas por pa\u00eds:\");\n            peliculas.aggregate(java.util.Arrays.asList(\n                    new Document(\"$group\",\n                            new Document(\"_id\", \"$pais\")\n                                    .append(\"total\", new Document(\"$sum\", 1))\n                    ),\n                    new Document(\"$sort\", new Document(\"total\", -1))\n            )).forEach(doc -&gt; System.out.println(\n                    doc.getString(\"_id\") + \": \" + doc.getInteger(\"total\") + \" pel\u00edculas\"\n            ));\n\n        } catch (Exception e) {\n            System.err.println(\"Error en operaciones CRUD: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/5_Mongo_Java.es/#53-consultas","title":"5.3. Consultas","text":"<p>El m\u00e9todo <code>getCollection()</code> de <code>MongoDatabase()</code> nos proporciona una colecci\u00f3n de <code>Document</code> (<code>MongoCollection&lt;Document&gt;</code>), sobre la que podremos realizar consultas utilizando el m\u00e9todo <code>find()</code>. Este m\u00e9todo, que ya conocemos del shell de MongoDB, nos permitir\u00e1 filtrar documentos bas\u00e1ndonos en ciertos criterios.</p> <p>Estos criterios se expresan como filtros (query filters en la documentaci\u00f3n), y pueden contener varios operadoresde consulta sobre algunos campos que determinar\u00e1n qu\u00e9 documentos de la colecci\u00f3n se incluyen como resultados.</p> <p>La clase <code>Filter</code> nos proporciona m\u00e9todos de f\u00e1brica para realizar estas consultas, de forma similar a como trabaj\u00e1bamos con el shell de MongoDB. Esta clase nos ofrece:</p> <ul> <li>Consulta vac\u00eda, con <code>Filters.empty()</code>.</li> <li>Operadores de comparaci\u00f3n: Para realizar consultas basadas en valores de la colecci\u00f3n: </li> <li><code>Filters.eq(key, value)</code>, <code>Filters.gt(key, value)</code>, <code>Filters.gte(key, value)</code>, <code>Filters.lt(key, value)</code> o <code>Filters.lte(key, value)</code>.</li> <li>Operadores l\u00f3gicos: Para realizar operaciones l\u00f3gicas sobre el resultado de otras consultas: <code>Filter.and(other_filters)</code>, <code>Filter.or(other_filters)</code>, etc.</li> <li>Operadores de array: Permiten realizar consultas basadas en el valor o n\u00famero de elementos de un vector: <code>Filters.size(vector, size)</code>.</li> <li>Otros operadores, como <code>Filter.exists()</code> o <code>Filter.regex()</code>, para comprobar la existencia de una clave o realizar una b\u00fasqueda con expresi\u00f3n regular.</li> </ul> <p>Adem\u00e1s de los filtros, tambi\u00e9n podremos incluir operaciones de agregaci\u00f3n, a trav\u00e9s del m\u00e9todo <code>aggregate()</code> de una instancia de <code>MongoCollection</code>. Puedes consultar la documentaci\u00f3n sobre agregaciones en la gu\u00eda de operaciones de agregaci\u00f3n de MongoDB.</p> <p>Por otra parte, la API del driver de MongoDB tambi\u00e9n nos permite realizar proyecciones de campos utilizando la clase <code>Projections</code>, que ofrece los m\u00e9todos <code>Projections.fields()</code>, <code>Projections.include()</code> o <code>Projections.excludeID()</code>.</p> <p>Ejemplo de b\u00fasqueda de pel\u00edculas de un a\u00f1o dado, s\u00f3lo 10 resultados:</p> <pre><code>public static void getPelisAnyo(MongoClient cliente, int anyo) {\n\n// get collection from database\n        MongoDatabase db=cliente.getDatabase(\"Cine1_V1\");\n\n// get documents from that colection\n        MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"Peli\");\n\n// And now, we apply a filtr and limit\n        FindIterable&lt;Document&gt; docsPelis = colPelis\n                .find(Filters.eq(\"anyo\", anyo))\n                .limit(10);\n\n// we show it\n        for (Document doc : docsPelis) {\n            System.out.println(doc.toString());\n        }\n    }\n</code></pre> <p>Recuerda</p> <p>La clase <code>Document</code> tiene varios m\u00e9todos para trabajar como documentos JSON en la unidad 1. Podemos obtener cada campo dada una clave, obteniendo su valor.</p> <p>Otro ejemplo con filtros y proyecciones:</p> <pre><code>public static void getPelisEntre(MongoClient cliente, int anyo1, int anyo2) {\n\n// check anyo values\n        if (anyo1&gt;anyo2){\n            int tmp=anyo1;\n            anyo1=anyo2;\n            anyo2=tmp;\n        }\n\n// get document collection\n        MongoDatabase db=cliente.getDatabase(\"Cine1_V1\");\n        MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"Peli\");\n\n// Creamos el filtro\n        Bson filter= Filters.and(\n                Filters.gte(\"anyo\", anyo1),\n                Filters.lte(\"anyo\", anyo2)\n        );\n\n// Create projecction\n        Bson projection= Projections\n                .fields(Projections.include(\"titulo\", \"anyo\"),\n                        Projections.excludeId());\n\n// Run the filters\n        FindIterable&lt;Document&gt; DocsPelis = colPelis\n                .find(filter)\n                .projection(projection);\n\n// Show the films\n        for (Document doc : DocsPelis) {\n            System.out.println(doc.toString());\n        }\n    }\n</code></pre> <p>y el programa final ser\u00eda:</p> <pre><code>package org.cipfpcheste.dam2;\n\nimport com.mongodb.client.*;\nimport com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.Projections;\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\n\n//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=\"Run\"/&gt; or\n// click the &lt;icon src=\"AllIcons.Actions.Execute\"/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) {\n        // Conector b\u00e1sico\n        conectorBasico();\n\n        // Conector con opciones\n        conectorAvanzado();\n        // Conector para operaciones CRUD\n        operacionesCRUD();\n    }\n\n    /**\n     * Conector b\u00e1sico a MongoDB\n     */\n    public static void conectorBasico() {\n        System.out.println(\"=== CONECTOR B\u00c1SICO MONGODB ===\");\n\n        // 1. Cadena de conexi\u00f3n simple\n        String connectionString = \"mongodb://root:toor@localhost:27017/Cine1_V1?authSource=admin\";\n\n        try (MongoClient mongoClient = MongoClients.create(connectionString)) {\n            System.out.println(\"Conexi\u00f3n establecida exitosamente\");\n\n            // 2. Acceder a una base de datos\n            MongoDatabase database = mongoClient.getDatabase(\"Cine1_V1\");\n            System.out.println(\"Base de datos: \" + database.getName());\n\n            // 3. Acceder a una colecci\u00f3n\n            MongoCollection&lt;Document&gt; collection = database.getCollection(\"Peli\");\n            System.out.println(\"Colecci\u00f3n: \" + collection.getNamespace());\n            System.out.println(\"Documentos en colecci\u00f3n: \" + collection.countDocuments());\n\n        } catch (Exception e) {\n            System.err.println(\"Error de conexi\u00f3n: \" + e.getMessage());\n        }\n\n    }\n\n    /**\n     * Conector avanzado con opciones\n     */\n    public static void conectorAvanzado() {\n        System.out.println(\"\\n=== CONECTOR AVANZADO MONGODB ===\");\n\n        // Cadena de conexi\u00f3n con autenticaci\u00f3n\n        String connectionString = \"mongodb://root:toor@localhost:27017/Cine1_V1?authSource=admin\";\n\n        // Con opciones adicionales\n        String connectionStringWithOptions =\n                \"mongodb://localhost:27017\" +\n                        \"/?maxPoolSize=50\" +\n                        \"&amp;w=majority\" +\n                        \"&amp;retryWrites=true\" +\n                        \"&amp;readPreference=primary\";\n\n        try (MongoClient mongoClient = MongoClients.create(connectionString)) {\n\n            // Listar bases de datos\n            System.out.println(\"Bases de datos disponibles:\");\n            mongoClient.listDatabaseNames().forEach(System.out::println);\n\n            // Acceder a la base de datos peliculasdb\n            MongoDatabase db = mongoClient.getDatabase(\"Cine1_V1\");\n\n            // Listar colecciones\n            System.out.println(\"\\nColecciones en Cine1_V1:\");\n            db.listCollectionNames().forEach(System.out::println);\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Operaciones CRUD b\u00e1sicas\n     */\n    public static void operacionesCRUD() {\n        System.out.println(\"\\n=== OPERACIONES CRUD B\u00c1SICAS ===\");\n\n        String connectionString = \"mongodb://root:toor@localhost:27017/Cine1_V1?authSource=admin\";\n\n        try (MongoClient mongoClient = MongoClients.create(connectionString)) {\n            MongoDatabase database = mongoClient.getDatabase(\"Cine1_V1\");\n            MongoCollection&lt;Document&gt; peliculas = database.getCollection(\"Peli\");\n\n            // 1. INSERTAR un documento\n            Document nuevaPelicula = new Document(\"titulo\", \"Inception\")\n                    .append(\"anyo\", 2010)\n                    .append(\"director\", \"Christopher Nolan\")\n                    .append(\"pais\", \"Estados Unidos\")\n                    .append(\"genero\", java.util.Arrays.asList(\"Ciencia ficci\u00f3n\", \"Acci\u00f3n\", \"Thriller\"))\n                    .append(\"duracion_minutos\", 148)\n                    .append(\"puntuacion_imdb\", 8.8);\n\n            peliculas.insertOne(nuevaPelicula);\n            System.out.println(\"Documento insertado: \" + nuevaPelicula.getObjectId(\"_id\"));\n\n            // 2. BUSCAR documentos\n            System.out.println(\"\\nPel\u00edculas de Christopher Nolan:\");\n            peliculas.find(new Document(\"director\", \"Christopher Nolan\"))\n                    .forEach(doc -&gt; System.out.println(\"- \" + doc.getString(\"titulo\") + \" (\" + doc.getInteger(\"anyo\") + \")\"));\n\n            // 3. ACTUALIZAR un documento\n            peliculas.updateOne(\n                    new Document(\"titulo\", \"Inception\"),\n                    new Document(\"$set\", new Document(\"puntuacion_imdb\", 8.9))\n            );\n            System.out.println(\"\\nPuntuaci\u00f3n actualizada\");\n\n            // 4. ELIMINAR un documento\n            peliculas.deleteOne(new Document(\"titulo\", \"Inception\"));\n            System.out.println(\"Documento eliminado\");\n\n            // 5. CONTAR documentos\n            long total = peliculas.countDocuments();\n            System.out.println(\"\\nTotal de pel\u00edculas: \" + total);\n\n            // 6. AGGREGATION b\u00e1sica\n            System.out.println(\"\\nPel\u00edculas por pa\u00eds:\");\n            peliculas.aggregate(java.util.Arrays.asList(\n                    new Document(\"$group\",\n                            new Document(\"_id\", \"$pais\")\n                                    .append(\"total\", new Document(\"$sum\", 1))\n                    ),\n                    new Document(\"$sort\", new Document(\"total\", -1))\n            )).forEach(doc -&gt; System.out.println(\n                    doc.getString(\"_id\") + \": \" + doc.getInteger(\"total\") + \" pel\u00edculas\"\n            ));\n\n            System.out.println(\"*\".repeat(250));\n            System.out.println(\"Filtros avanzados\");\n            System.out.println(\"*\".repeat(250));\n            getPelisEntre(mongoClient,2000,2025);\n            System.out.println(\"*\".repeat(250));\n            System.out.println(\"Numero de peliculas para el a\u00f1o indicado\");\n            System.out.println(\"*\".repeat(250));\n            getPelisAnyo(mongoClient,2023);\n            System.out.println(\"*\".repeat(250));\n\n\n\n        } catch (Exception e) {\n            System.err.println(\"Error en operaciones CRUD: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Conector con manejo de excepciones\n     */\n    public static MongoClient createConnectionWithRetry() {\n        String connectionString = \"mongodb://localhost:27017\";\n        int maxRetries = 3;\n        int retryDelay = 2000; // 2 segundos\n\n        for (int i = 0; i &lt; maxRetries; i++) {\n            try {\n                System.out.println(\"Intentando conexi\u00f3n \" + (i + 1) + \"/\" + maxRetries);\n                MongoClient client = MongoClients.create(connectionString);\n\n                // Verificar conexi\u00f3n\n                client.listDatabaseNames().first();\n                System.out.println(\"Conexi\u00f3n exitosa\");\n                return client;\n\n            } catch (Exception e) {\n                System.err.println(\"Intento \" + (i + 1) + \" fallido: \" + e.getMessage());\n\n                if (i &lt; maxRetries - 1) {\n                    try {\n                        Thread.sleep(retryDelay);\n                    } catch (InterruptedException ie) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n        throw new RuntimeException(\"No se pudo conectar despu\u00e9s de \" + maxRetries + \" intentos\");\n    }\n\n    public static void getPelisEntre(MongoClient cliente, int anyo1, int anyo2) {\n\n// check anyo values\n        if (anyo1&gt;anyo2){\n            int tmp=anyo1;\n            anyo1=anyo2;\n            anyo2=tmp;\n        }\n\n// get document collection\n        MongoDatabase db=cliente.getDatabase(\"Cine1_V1\");\n        MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"Peli\");\n\n// Creamos el filtro\n        Bson filter= Filters.and(\n                Filters.gte(\"anyo\", anyo1),\n                Filters.lte(\"anyo\", anyo2)\n        );\n\n// Create projecction\n        Bson projection= Projections\n                .fields(Projections.include(\"titulo\", \"anyo\"),\n                        Projections.excludeId());\n\n// Run the filters\n        FindIterable&lt;Document&gt; DocsPelis = colPelis\n                .find(filter)\n                .projection(projection);\n\n// Show the films\n        for (Document doc : DocsPelis) {\n            System.out.println(doc.toString());\n        }\n    }\n\n    public static void getPelisAnyo(MongoClient cliente, int anyo) {\n\n// get collection from database\n        MongoDatabase db=cliente.getDatabase(\"Cine1_V1\");\n\n// get documents from that colection\n        MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"Peli\");\n\n// And now, we apply a filtr and limit\n        FindIterable&lt;Document&gt; docsPelis = colPelis\n                .find(Filters.eq(\"anyo\", anyo))\n                .limit(10);\n\n// we show it\n        for (Document doc : docsPelis) {\n            System.out.println(doc.toString());\n        }\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/","title":"6. Spring Data MongoDB y API REST","text":"<p>Como sabemos, el proyecto Spring Data, incluido en la plataforma Spring, proporciona un marco para simplificar el acceso y la persistencia de datos en distintos repositorios de informaci\u00f3n. Dentro de este proyecto se encuentra Spring Data MongoDB, que proporciona integraci\u00f3n con bases de datos MongoDB, a trav\u00e9s de un modelo centrado en POJOs que interact\u00faan con colecciones de documentos y proporciona un repositorio de acceso a datos.</p> <p>En esta secci\u00f3n, y continuando con la unidad anterior, abordaremos el desarrollo de componentes de acceso a datos a trav\u00e9s de Spring Data, as\u00ed como microservicios que ofrecen estos datos a trav\u00e9s de una API REST, todo ello siguiendo el patr\u00f3n MVC que ya conocemos.</p>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#61-definiendo-el-modelo-documento","title":"6.1. Definiendo el Modelo \u2013 Documento","text":"<p>Una base de datos MongoDB est\u00e1 compuesta por colecciones de <code>Document</code>. Aunque estos Documentos pueden tener estructuras diferentes entre s\u00ed o distintos tipos de datos, el modelo requiere una estructura est\u00e1tica. As\u00ed pues, lo primero que debemos hacer es crear una clase que represente este Documento Principal para MongoDB, que ser\u00e1 lo que se devolver\u00e1 por las consultas que se hagan.</p> <p>En este contexto, existen dos anotaciones principales que utilizaremos:</p> <ul> <li><code>@Document</code> \u2192 para indicar que una clase corresponde a un objeto de dominio (domain object) que se puede mapear en la base de datos para ofrecer persistencia. Esta anotaci\u00f3n para MongoDB ser\u00eda la equivalente a <code>@Entity</code> en JPA. Si no se indica nada, el nombre de la colecci\u00f3n que se va a utilizar se interpretar\u00e1 como correspondiente al nombre de la clase en min\u00fasculas. As\u00ed, si tenemos la clase <code>org.cipfpcheste.dam2.springmongodb.model.Pelicula</code>, se utilizar\u00e1 la colecci\u00f3n <code>pelicula</code>. Sin embargo,gitt podemos indicar la colecci\u00f3n con la que estamos trabajando, ya sea a trav\u00e9s de los atributos value o collection, con la siguiente sintaxis: </li> <li><code>@Document(value=\"collection\")</code> </li> <li><code>@Document(\"collection\")</code> </li> <li><code>@Document(collection=\"collection\")</code></li> <li><code>@Id</code> Se aplica a un campo, y se utiliza para indicar que el campo se utilizar\u00e1 como identificador. Como sabemos, cada documento en MongoDB requiere un identificador. Si no se proporciona ninguna, el controlador asignar\u00e1 un <code>ObjectID</code> autom\u00e1ticamente. Es importante tener en cuenta que los tipos de datos que podemos utilizar como identificadores pueden ser tanto <code>Strings</code> como <code>BigInteger</code>, puesto que Spring se encargar\u00e1 de convertirlos al tipo ObjectID.</li> </ul> <p>Importante</p> <p>Existe una anotaci\u00f3n <code>@DocumentReference</code> para relacionar Documentos uno dentro de otros, por ejemplo cuando almacenamos en una clase objetos de otras clases, como las relaciones en bases de datos SQL.</p> <p>Adem\u00e1s de \u00e9stas, existen otras anotaciones m\u00e1s espec\u00edficas que podemos utilizar. Si lo desea, puede consultarlas en la documentaci\u00f3n de referencia de Spring Data MongoDB aqu\u00ed.</p> <pre><code>package org.cipfpcheste.dam2.springmongodb.model;\n\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\nimport org.springframework.data.mongodb.core.mapping.Field;\n\nimport java.util.List;\n\n@Document(collection = \"Peli\")\npublic class Pelicula {\n\n    @Id\n    private String id;\n\n    private String titulo;\n\n    private Integer anyo;\n\n    private String director;\n\n    private String pais;\n\n    private List&lt;String&gt; genero;\n\n    @Field(\"duracion_minutos\")\n    private Integer duracionMinutos;\n\n    private String clasificacion;\n\n    @Field(\"actores_principales\")\n    private List&lt;String&gt; actoresPrincipales;\n\n    @Field(\"puntuacion_imdb\")\n    private Double puntuacionImdb;\n\n    @Field(\"taquilla_global_millones\")\n    private Double taquillaGlobalMillones;\n\n    private Integer oscars;\n\n    @Field(\"premios_goya\")\n    private Integer premiosGoya;\n\n    // Constructores\n    public Pelicula() {\n    }\n\n    public Pelicula(String titulo, Integer anyo, String director, String pais,\n                    List&lt;String&gt; genero, Integer duracionMinutos, String clasificacion,\n                    List&lt;String&gt; actoresPrincipales, Double puntuacionImdb,\n                    Double taquillaGlobalMillones) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.director = director;\n        this.pais = pais;\n        this.genero = genero;\n        this.duracionMinutos = duracionMinutos;\n        this.clasificacion = clasificacion;\n        this.actoresPrincipales = actoresPrincipales;\n        this.puntuacionImdb = puntuacionImdb;\n        this.taquillaGlobalMillones = taquillaGlobalMillones;\n    }\n\n    // Getters y Setters\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getTitulo() {\n        return titulo;\n    }\n\n    public void setTitulo(String titulo) {\n        this.titulo = titulo;\n    }\n\n    public Integer getAnyo() {\n        return anyo;\n    }\n\n    public void setAnyo(Integer anyo) {\n        this.anyo = anyo;\n    }\n\n    public String getDirector() {\n        return director;\n    }\n\n    public void setDirector(String director) {\n        this.director = director;\n    }\n\n    public String getPais() {\n        return pais;\n    }\n\n    public void setPais(String pais) {\n        this.pais = pais;\n    }\n\n    public List&lt;String&gt; getGenero() {\n        return genero;\n    }\n\n    public void setGenero(List&lt;String&gt; genero) {\n        this.genero = genero;\n    }\n\n    public Integer getDuracionMinutos() {\n        return duracionMinutos;\n    }\n\n    public void setDuracionMinutos(Integer duracionMinutos) {\n        this.duracionMinutos = duracionMinutos;\n    }\n\n    public String getClasificacion() {\n        return clasificacion;\n    }\n\n    public void setClasificacion(String clasificacion) {\n        this.clasificacion = clasificacion;\n    }\n\n    public List&lt;String&gt; getActoresPrincipales() {\n        return actoresPrincipales;\n    }\n\n    public void setActoresPrincipales(List&lt;String&gt; actoresPrincipales) {\n        this.actoresPrincipales = actoresPrincipales;\n    }\n\n    public Double getPuntuacionImdb() {\n        return puntuacionImdb;\n    }\n\n    public void setPuntuacionImdb(Double puntuacionImdb) {\n        this.puntuacionImdb = puntuacionImdb;\n    }\n\n    public Double getTaquillaGlobalMillones() {\n        return taquillaGlobalMillones;\n    }\n\n    public void setTaquillaGlobalMillones(Double taquillaGlobalMillones) {\n        this.taquillaGlobalMillones = taquillaGlobalMillones;\n    }\n\n    public Integer getOscars() {\n        return oscars;\n    }\n\n    public void setOscars(Integer oscars) {\n        this.oscars = oscars;\n    }\n\n    public Integer getPremiosGoya() {\n        return premiosGoya;\n    }\n\n    public void setPremiosGoya(Integer premiosGoya) {\n        this.premiosGoya = premiosGoya;\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#explicacion-de-los-decoradores","title":"\ud83d\udccb Explicaci\u00f3n de los Decoradores","text":""},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#1-documentcollection-peli","title":"1. <code>@Document(collection = \"Peli\")</code>","text":"<ul> <li>Paquete: <code>org.springframework.data.mongodb.core.mapping.Document</code></li> <li>Prop\u00f3sito: Indica que esta clase Java representa un documento MongoDB</li> <li>Par\u00e1metro :<code>collection</code> Especifica que los documentos se almacenan en la colecci\u00f3n llamada \"Peli\"</li> <li>Nota: Sin este par\u00e1metro, Spring usar\u00eda el nombre de la clase en min\u00fasculas (\"pelicula\")</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#2-id","title":"2. <code>@Id</code>","text":"<ul> <li>Paquete: <code>org.springframework.data.annotation.Id</code></li> <li>Prop\u00f3sito: Marca el campo como el identificador \u00fanico del documento</li> <li>Comportamiento:</li> <li>MongoDB usa <code>_id</code> como identificador por defecto</li> <li>Spring mapea autom\u00e1ticamente <code>_id</code> \u2194 <code>id</code></li> <li>Si no se proporciona valor, MongoDB genera un autom\u00e1ticamente <code>ObjectId</code></li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#3-fieldnombre_campo","title":"3. <code>@Field(\"nombre_campo\")</code>","text":"<ul> <li>Paquete: <code>org.springframework.data.mongodb.core.mapping.Field</code></li> <li>Prop\u00f3sito: Mapea un atributo Java a un campo con nombre diferente en MongoDB</li> <li>Ejemplos en la clase:</li> <li>\u2192 En Java: , en MongoDB: <code>@Field(\"duracion_minutos\")</code> <code>duracionMinutos</code> <code>duracion_minutos</code></li> <li>\u2192 En Java: , en MongoDB: <code>@Field(\"actores_principales\")</code> <code>actoresPrincipales</code> <code>actores_principales</code> </li> <li>\u2192 En Java: , en MongoDB: <code>@Field(\"puntuacion_imdb\")</code> <code>puntuacionImdb</code> <code>puntuacion_imdb</code> </li> <li>\u2192 En Java: , en MongoDB: <code>@Field(\"taquilla_global_millones\")</code> <code>taquillaGlobalMillones</code> <code>taquilla_global_millones</code> </li> <li>\u2192 En Java: , en MongoDB: <code>@Field(\"premios_goya\")</code> <code>premiosGoya</code> <code>premios_goya</code> </li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#estructura-de-los-campos","title":"\ud83d\uddc2\ufe0f Estructura de los Campos","text":""},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#campos-sin-field","title":"Campos sin : <code>@Field</code>","text":"<p>Cuando NO usas , Spring mapea el nombre del atributo Java directamente: <code>@Field</code></p> <ul> <li>\u2192 <code>titulo</code> <code>titulo</code></li> <li>\u2192 <code>anyo</code> <code>anyo</code></li> <li>\u2192 <code>director</code> <code>director</code></li> <li>\u2192 <code>pais</code> <code>pais</code></li> <li>\u2192 <code>genero</code> <code>genero</code> </li> <li>\u2192 <code>clasificacion</code> <code>clasificacion</code> </li> <li>\u2192 <code>oscars</code> <code>oscars</code> </li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#campos-con-field","title":"Campos con : <code>@Field</code>","text":"<p>Permiten usar convenciones diferentes entre Java (camelCase) y MongoDB (snake_case):</p> <ul> <li>Java: \u2194 MongoDB: <code>duracionMinutos</code> <code>duracion_minutos</code> </li> <li>Java: \u2194 MongoDB: <code>actoresPrincipales</code> <code>actores_principales</code> </li> <li>Java: \u2194 MongoDB: <code>puntuacionImdb</code> <code>puntuacion_imdb</code> </li> <li>Java: \u2194 MongoDB: <code>taquillaGlobalMillones</code> <code>taquilla_global_millones</code> </li> <li>Java: \u2194 MongoDB: <code>premiosGoya</code> <code>premios_goya</code> </li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#tipos-de-datos","title":"\ud83d\udcca Tipos de Datos","text":"Campo Tipo Java Tipo MongoDB id String ObjectId / String titulo String String anyo Integer Int32 director String String pais String String genero List Array duracionMinutos Integer Int32 clasificacion String String actoresPrincipales List Array puntuacionImdb Double Double taquillaGlobalMillones Double Double oscars Integer Int32 premiosGoya Integer Int32"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#62-definiendo-el-repositorio","title":"6.2. Definiendo el Repositorio","text":"<p>Como sabemos, el repositorio es la interfaz encargada de gestionar el acceso a los datos. En el caso de MongoDB, \u00e9ste derivar\u00e1 de <code>MongoRepository</code>, que ser\u00e1 una interfaz parametrizada por dos argumentos:</p> <ul> <li><code>MongoRepository&lt;T, Id&gt;</code>, donde: </li> <li><code>T</code> \u2192 El tipo de documento, que corresponder\u00e1 a la clase definida en el modelo, y </li> <li><code>Id</code>\u2192 El tipo de dato al que pertenecer\u00e1 el identificador.</li> </ul> <p>La interfaz MongoRepository, como hemos dicho, ser\u00e1 espec\u00edfica para MongoDB, y derivar\u00e1 de las interfaces <code>CrudRepository</code> y <code>PagingAndSortingRepository</code>, de las que heredar\u00e1 todos sus m\u00e9todos. De esta forma, en el repositorio s\u00f3lo deberemos declarar aquellos m\u00e9todos que sean m\u00e1s espec\u00edficos para nuestra aplicaci\u00f3n, ya que todos los m\u00e9todos para implementar operaciones CRUD, as\u00ed como <code>findAll()</code> y <code>findById()</code> ser\u00e1n heredados de <code>MongoRepository</code>.</p> <p>Para definir nuestras propias consultas en el repositorio, utilizaremos la anotaci\u00f3n <code>@Query</code>, proporcionando la consulta en cuesti\u00f3n como valor:</p> <pre><code>@Query(value=\"{ parameterized_query}\") // respecto a la clase base del repositorio\nList&lt;DocumentType&gt; methodName(list_parameters);\n</code></pre> <p>Para suministrar par\u00e1metros a la consulta, \u00e9stos se reciben como argumentos del m\u00e9todo, y se referencian por su orden a la consulta: <code>?0</code> para el primer argumento, <code>?1</code> para el segundo, etc. Quiz\u00e1s en versiones m\u00e1s nuevas se pueden utilizar par\u00e1metros de forma nominal, como <code>:parameter_name</code>.</p> <pre><code>package org.cipfpcheste.dam2.springmongodb.repository;\n\nimport org.cipfpcheste.dam2.springmongodb.model.Pelicula;\nimport org.springframework.data.mongodb.repository.MongoRepository;\nimport org.springframework.data.mongodb.repository.Query;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface PeliculaRepository extends MongoRepository&lt;Pelicula, String&gt; {\n\n    // Buscar por t\u00edtulo\n    List&lt;Pelicula&gt; findByTituloContainingIgnoreCase(String titulo);\n\n    // Buscar por director\n    List&lt;Pelicula&gt; findByDirectorContainingIgnoreCase(String director);\n\n    // Buscar por pa\u00eds\n    List&lt;Pelicula&gt; findByPais(String pais);\n\n    // Buscar por a\u00f1o\n    List&lt;Pelicula&gt; findByAnyo(Integer anyo);\n\n    // Buscar por g\u00e9nero\n    List&lt;Pelicula&gt; findByGeneroContaining(String genero);\n\n    // Buscar pel\u00edculas con puntuaci\u00f3n mayor o igual\n    List&lt;Pelicula&gt; findByPuntuacionImdbGreaterThanEqual(Double puntuacion);\n\n    // Buscar pel\u00edculas ganadoras de Oscars\n    @Query(\"{ 'oscars': { $exists: true, $ne: null } }\")\n    List&lt;Pelicula&gt; findPeliculasConOscars();\n\n    // Buscar pel\u00edculas ganadoras de Goyas\n    @Query(\"{ 'premios_goya': { $exists: true, $ne: null } }\")\n    List&lt;Pelicula&gt; findPeliculasConGoyas();\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#63-definiendo-el-servicio","title":"6.3. Definiendo el servicio","text":"<p>Los servicios se encargan de la capa de negocio de nuestra aplicaci\u00f3n y acceden a los datos a trav\u00e9s del repositorio, enviando los resultados al controlador. Estos servicios, en general, se caracterizan por:</p> <ul> <li>Utilizar las anotaciones <code>@Service</code>, para indicar a Spring que se est\u00e1 implementando un servicio</li> <li>Por un lado, se define la interfaz del Servicio y, por otro, se realiza la implementaci\u00f3n a trav\u00e9s de la clase <code>ServiceImpl</code>.</li> <li>Se utiliza la anotaci\u00f3n <code>@Autowired</code> en referencias a repositorios para enlazar o inyectar el servicio en cuesti\u00f3n con este repositorio.</li> <li>Una vez obtenga los datos del repositorio, los env\u00eda al controlador.</li> </ul> <p>Interfaz PeliculaService:</p> <p><pre><code>package org.cipfpcheste.dam2.springmongodb.service;\n\nimport org.cipfpcheste.dam2.springmongodb.model.Pelicula;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface PeliculaService {\n\n    // Operaciones CRUD b\u00e1sicas\n    List&lt;Pelicula&gt; obtenerTodasLasPeliculas();\n\n    Optional&lt;Pelicula&gt; obtenerPeliculaPorId(String id);\n\n    Pelicula crearPelicula(Pelicula pelicula);\n\n    Pelicula actualizarPelicula(String id, Pelicula peliculaActualizada);\n\n    boolean eliminarPelicula(String id);\n\n    // B\u00fasquedas espec\u00edficas\n    List&lt;Pelicula&gt; buscarPorTitulo(String titulo);\n\n    List&lt;Pelicula&gt; buscarPorDirector(String director);\n\n    List&lt;Pelicula&gt; buscarPorPais(String pais);\n\n    List&lt;Pelicula&gt; buscarPorAnyo(Integer anyo);\n\n    List&lt;Pelicula&gt; buscarPorGenero(String genero);\n\n    List&lt;Pelicula&gt; buscarPorPuntuacionMinima(Double puntuacion);\n\n    List&lt;Pelicula&gt; obtenerPeliculasConOscars();\n\n    List&lt;Pelicula&gt; obtenerPeliculasConGoyas();\n}\n</code></pre> Implementaci\u00f3n del interfaz, PeliculaServiceImpl:</p> <pre><code>package org.cipfpcheste.dam2.springmongodb.service;\n\nimport org.cipfpcheste.dam2.springmongodb.model.Pelicula;\nimport org.cipfpcheste.dam2.springmongodb.repository.PeliculaRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class PeliculaServiceImpl implements PeliculaService {\n\n    @Autowired\n    private PeliculaRepository peliculaRepository;\n\n    @Override\n    public List&lt;Pelicula&gt; obtenerTodasLasPeliculas() {\n        return peliculaRepository.findAll();\n    }\n\n    @Override\n    public Optional&lt;Pelicula&gt; obtenerPeliculaPorId(String id) {\n        return peliculaRepository.findById(id);\n    }\n\n    @Override\n    public Pelicula crearPelicula(Pelicula pelicula) {\n        return peliculaRepository.save(pelicula);\n    }\n\n    @Override\n    public Pelicula actualizarPelicula(String id, Pelicula peliculaActualizada) {\n        return peliculaRepository.findById(id)\n            .map(pelicula -&gt; {\n                pelicula.setTitulo(peliculaActualizada.getTitulo());\n                pelicula.setAnyo(peliculaActualizada.getAnyo());\n                pelicula.setDirector(peliculaActualizada.getDirector());\n                pelicula.setPais(peliculaActualizada.getPais());\n                pelicula.setGenero(peliculaActualizada.getGenero());\n                pelicula.setDuracionMinutos(peliculaActualizada.getDuracionMinutos());\n                pelicula.setClasificacion(peliculaActualizada.getClasificacion());\n                pelicula.setActoresPrincipales(peliculaActualizada.getActoresPrincipales());\n                pelicula.setPuntuacionImdb(peliculaActualizada.getPuntuacionImdb());\n                pelicula.setTaquillaGlobalMillones(peliculaActualizada.getTaquillaGlobalMillones());\n                pelicula.setOscars(peliculaActualizada.getOscars());\n                pelicula.setPremiosGoya(peliculaActualizada.getPremiosGoya());\n                return peliculaRepository.save(pelicula);\n            })\n            .orElse(null);\n    }\n\n    @Override\n    public boolean eliminarPelicula(String id) {\n        if (peliculaRepository.existsById(id)) {\n            peliculaRepository.deleteById(id);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; buscarPorTitulo(String titulo) {\n        return peliculaRepository.findByTituloContainingIgnoreCase(titulo);\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; buscarPorDirector(String director) {\n        return peliculaRepository.findByDirectorContainingIgnoreCase(director);\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; buscarPorPais(String pais) {\n        return peliculaRepository.findByPais(pais);\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; buscarPorAnyo(Integer anyo) {\n        return peliculaRepository.findByAnyo(anyo);\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; buscarPorGenero(String genero) {\n        return peliculaRepository.findByGeneroContaining(genero);\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; buscarPorPuntuacionMinima(Double puntuacion) {\n        return peliculaRepository.findByPuntuacionImdbGreaterThanEqual(puntuacion);\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; obtenerPeliculasConOscars() {\n        return peliculaRepository.findPeliculasConOscars();\n    }\n\n    @Override\n    public List&lt;Pelicula&gt; obtenerPeliculasConGoyas() {\n        return peliculaRepository.findPeliculasConGoyas();\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#64-definiendo-el-controlador","title":"6.4. Definiendo el controlador","text":"<p>Finalmente, nos queda la implementaci\u00f3n del controlador, que ya conocemos de Spring. Recordamos las caracter\u00edsticas principales de \u00e9ste:</p> <ul> <li>Utilizar la anotaci\u00f3n <code>@RestController</code> a nivel de clase para indicar que se trata de un controlador REST</li> <li>Utilizar la anotaci\u00f3n <code>@RequestMapping</code> a nivel de clase para especificar el camino base para los puntos finales del servicio,</li> <li>Utilizar la anotaci\u00f3n <code>@Autowired</code> en las propiedades que hacen referencia al servicio, para inyectarlo autom\u00e1ticamente,</li> <li>Utilizar las anotaciones <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code> a los m\u00e9todos que implementar\u00e1n solicitudes de tipo GET, POST, PUT o DELETE, especificando su Endpoint.</li> <li>Utilizar las anotaciones <code>@PathVariable</code> o <code>@RequestParam</code> o <code>@RequestBody</code> en los argumentos de los m\u00e9todos anteriores para obtener los valores del camino, solicitud o cuerpo.</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#2-openapi-swagger","title":"2. OpenAPI (Swagger)","text":"<p>Swagger, ahora OpenApi, es una herramienta que se integra completamente con Spring y nos va a permitir describir, producir, consumir y visualizar servicios web RESTful.[1]\u200b Comenz\u00f3 como parte del marco Swagger, y se convirti\u00f3 en un proyecto separado en 2016, supervisado por la Iniciativa OpenAPI, un proyecto de colaboraci\u00f3n de c\u00f3digo abierto de la Fundaci\u00f3n Linux.[2]\u200b Swagger y algunas otras herramientas pueden generar c\u00f3digo, documentaci\u00f3n y casos de prueba con un archivo de interfaz.</p> <p>Lo primero que debemos hacer es a\u00f1adir la dependencia en el pom.xl:</p> <pre><code>      &lt;!-- Source: https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n            &lt;version&gt;3.0.1&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Generamos el paquete <code>config</code>en el cual definiremos la configuraci\u00f3n de OpenAPI en una clase:</p> <pre><code>package org.cipfpcheste.dam2.springmongodb.config;\n\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.info.Contact;\nimport io.swagger.v3.oas.models.info.Info;\nimport io.swagger.v3.oas.models.info.License;\nimport io.swagger.v3.oas.models.servers.Server;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.List;\n\n@Configuration\npublic class OpenAPIConfig {\n\n    @Bean\n    public OpenAPI peliculasAPI() {\n        Server localServer = new Server();\n        localServer.setUrl(\"http://localhost:8080\");\n        localServer.setDescription(\"Servidor de Desarrollo Local de 2\u00ba DAM\");\n\n        Contact contact = new Contact();\n        contact.setEmail(\"manu@cipfpcheste.dam2\");\n        contact.setName(\"Jos\u00e9 Manuel Romero\");\n        contact.setUrl(\"https://portal.edu.gva.es/fpcheste/\");\n\n        License mitLicense = new License()\n                .name(\"MIT License\")\n                .url(\"https://choosealicense.com/licenses/mit/\");\n\n        Info info = new Info()\n                .title(\"API de Gesti\u00f3n de Pel\u00edculas\")\n                .version(\"1.0.0\")\n                .contact(contact)\n                .description(\"API REST para la gesti\u00f3n de pel\u00edculas con MongoDB\")\n                .termsOfService(\"https://www.cipfpcheste.dam2/terms\")\n                .license(mitLicense);\n\n        return new OpenAPI()\n                .info(info)\n                .servers(List.of(localServer));\n    }\n}\n</code></pre> <ul> <li>Paquete: <code>org.springframework.context.annotation.Configuration</code></li> <li>Prop\u00f3sito: Indica que esta clase contiene definiciones de beans de Spring</li> <li>Comportamiento: Spring procesar\u00e1 esta clase al iniciar la aplicaci\u00f3n y registrar\u00e1 los beans definidos</li> <li> <p>Alternativa: Podr\u00eda usar <code>@SpringBootConfiguration</code> pero <code>@Configuration</code> es m\u00e1s est\u00e1ndar</p> </li> <li> <p>Anotaci\u00f3n: <code>@Bean</code> marca este m\u00e9todo como productor de un bean de Spring</p> </li> <li>Tipo de retorno: - objeto principal que contiene toda la configuraci\u00f3n de la documentaci\u00f3n <code>OpenAPI</code></li> <li>Nombre del bean: Por defecto es el nombre del m\u00e9todo (<code>peliculasAPI</code>)</li> <li>Ciclo de vida: Singleton - se crea una sola instancia durante la vida de la aplicaci\u00f3n</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#configuracion-del-servidor","title":"Configuraci\u00f3n del servidor","text":"<pre><code>Server localServer = new Server();\nlocalServer.setUrl(\"http://localhost:8080\");\nlocalServer.setDescription(\"Servidor de Desarrollo Local\");\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#componentes","title":"Componentes:","text":"<ul> <li>Clase: <code>io.swagger.v3.oas.models.servers.Server</code></li> <li><code>setUrl()</code>: Define la URL base donde est\u00e1 corriendo tu API</li> <li><code>setDescription()</code>: Descripci\u00f3n legible del servidor</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#para-que-sirve","title":"\u00bfPara qu\u00e9 sirve?","text":"<ul> <li>Define d\u00f3nde est\u00e1n disponibles los endpoints de tu API</li> <li>Puedes tener m\u00faltiples servidores (desarrollo, staging, producci\u00f3n)</li> <li>Swagger UI usar\u00e1 esta URL para hacer las peticiones de prueba</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#ejemplo-con-multiples-servidores","title":"Ejemplo con m\u00faltiples servidores:","text":"<pre><code>Server devServer = new Server();\ndevServer.setUrl(\"http://localhost:8080\");\ndevServer.setDescription(\"Desarrollo\");\n\nServer prodServer = new Server();\nprodServer.setUrl(\"https://api.produccion.com\");\nprodServer.setDescription(\"Producci\u00f3n\");\n\nreturn new OpenAPI()\n    .info(info)\n    .servers(List.of(devServer, prodServer));\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#informacion-de-contacto","title":"Informaci\u00f3n de Contacto","text":"<pre><code>Contact contact = new Contact();\ncontact.setEmail(\"tu-email@cipfpcheste.dam2\");\ncontact.setName(\"Tu Nombre\");\ncontact.setUrl(\"https://www.cipfpcheste.dam2\");\n</code></pre> <ul> <li>Clase: <code>io.swagger.v3.oas.models.info.Contact</code></li> <li><code>setEmail()</code>: Email de contacto del responsable de la API</li> <li><code>setName()</code>: Nombre del desarrollador o equipo</li> <li><code>setUrl()</code>: URL del sitio web del desarrollador/organizaci\u00f3n</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#donde-se-muestra","title":"\u00bfD\u00f3nde se muestra?","text":"<p>Esta informaci\u00f3n aparece en la secci\u00f3n \"Contact\" de Swagger UI, permitiendo a los usuarios de la API saber a qui\u00e9n contactar para soporte o preguntas.</p>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#licencia","title":"Licencia","text":"<pre><code>License mitLicense = new License()\n        .name(\"MIT License\")\n        .url(\"https://choosealicense.com/licenses/mit/\");\n</code></pre> <ul> <li>Clase: <code>io.swagger.v3.oas.models.info.License</code></li> <li><code>name()</code>: Nombre de la licencia bajo la cual se distribuye la API</li> <li><code>url()</code>: URL con el texto completo de la licencia</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#licencias-comunes","title":"Licencias comunes:","text":"<pre><code>// MIT License\nnew License().name(\"MIT\").url(\"https://opensource.org/licenses/MIT\");\n\n// Apache 2.0\nnew License().name(\"Apache 2.0\").url(\"https://www.apache.org/licenses/LICENSE-2.0.html\");\n\n// GPL v3\nnew License().name(\"GPL v3\").url(\"https://www.gnu.org/licenses/gpl-3.0.html\");\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#informacion-general-de-la-api","title":"Informaci\u00f3n General de la API","text":"<pre><code>Info info = new Info()\n        .title(\"API de Gesti\u00f3n de Pel\u00edculas\")\n        .version(\"1.0.0\")\n        .contact(contact)\n        .description(\"API REST para la gesti\u00f3n de pel\u00edculas con MongoDB\")\n        .termsOfService(\"https://www.cipfpcheste.dam2/terms\")\n        .license(mitLicense);\n</code></pre> <ul> <li>Clase: <code>io.swagger.v3.oas.models.info.Info</code></li> <li><code>title()</code>: T\u00edtulo principal de tu API (aparece en la parte superior de Swagger UI)</li> <li><code>version()</code>: Versi\u00f3n de la API (\u00fatil para control de versiones)</li> <li><code>contact()</code>: Objeto Contact definido anteriormente</li> <li><code>description()</code>: Descripci\u00f3n detallada de qu\u00e9 hace tu API</li> <li><code>termsOfService()</code>: URL con los t\u00e9rminos de servicio</li> <li><code>license()</code>: Objeto License definido anteriormente</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#versionado-semantico-recomendado","title":"Versionado sem\u00e1ntico recomendado:","text":"<pre><code>version(\"1.0.0\")  // MAYOR.MENOR.PARCHE\n//        ^-- Cambios incompatibles\n//     ^----- Nueva funcionalidad compatible\n//  ^-------- Correcciones de bugs\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#objeto-openapi-final","title":"Objeto OpenAPI Final","text":"<pre><code>return new OpenAPI()\n        .info(info)\n        .servers(List.of(localServer));\n</code></pre> <ul> <li>Clase: <code>io.swagger.v3.oas.models.OpenAPI</code></li> <li><code>info()</code>: Adjunta toda la informaci\u00f3n de la API</li> <li><code>servers()</code>: Lista de servidores disponibles</li> </ul>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#este-objeto-es-el-que-spring-usara-para","title":"Este objeto es el que Spring usar\u00e1 para:","text":"<ol> <li>Generar la documentaci\u00f3n JSON en <code>/api-docs</code></li> <li>Renderizar Swagger UI en <code>/swagger-ui.html</code></li> <li>Proveer metadatos a herramientas de cliente (Postman, etc.)</li> </ol>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#documentar-el-controlador","title":"Documentar el Controlador","text":"<p>Veamos las anotaciones que se visualizar\u00e1n en el interfaz Web:</p> <pre><code>package org.cipfpcheste.dam2.springmongodb.controller;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.media.Content;\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport io.swagger.v3.oas.annotations.responses.ApiResponses;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.cipfpcheste.dam2.springmongodb.model.Pelicula;\nimport org.cipfpcheste.dam2.springmongodb.service.PeliculaService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/peliculas\")\n@Tag(name = \"Pel\u00edculas\", description = \"API para la gesti\u00f3n de pel\u00edculas\")\npublic class PeliculaController {\n\n    @Autowired\n    private PeliculaService peliculaService;\n\n    @Operation(\n        summary = \"Obtener todas las pel\u00edculas\",\n        description = \"Retorna una lista completa de todas las pel\u00edculas almacenadas en la base de datos\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"Lista de pel\u00edculas obtenida exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; obtenerTodasLasPeliculas() {\n        return ResponseEntity.ok(peliculaService.obtenerTodasLasPeliculas());\n    }\n\n    @Operation(\n        summary = \"Obtener pel\u00edcula por ID\",\n        description = \"Retorna una pel\u00edcula espec\u00edfica basada en su identificador \u00fanico\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"Pel\u00edcula encontrada\",\n                     content = @Content(schema = @Schema(implementation = Pelicula.class))),\n        @ApiResponse(responseCode = \"404\", description = \"Pel\u00edcula no encontrada\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Pelicula&gt; obtenerPeliculaPorId(\n            @Parameter(description = \"ID de la pel\u00edcula a buscar\", required = true)\n            @PathVariable String id) {\n        return peliculaService.obtenerPeliculaPorId(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n\n    @Operation(\n        summary = \"Crear nueva pel\u00edcula\",\n        description = \"Crea y almacena una nueva pel\u00edcula en la base de datos\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"201\", description = \"Pel\u00edcula creada exitosamente\",\n                     content = @Content(schema = @Schema(implementation = Pelicula.class))),\n        @ApiResponse(responseCode = \"400\", description = \"Datos de pel\u00edcula inv\u00e1lidos\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @PostMapping\n    public ResponseEntity&lt;Pelicula&gt; crearPelicula(\n            @Parameter(description = \"Datos de la pel\u00edcula a crear\", required = true)\n            @RequestBody Pelicula pelicula) {\n        Pelicula nuevaPelicula = peliculaService.crearPelicula(pelicula);\n        return ResponseEntity.status(HttpStatus.CREATED).body(nuevaPelicula);\n    }\n\n    @Operation(\n        summary = \"Actualizar pel\u00edcula\",\n        description = \"Actualiza los datos de una pel\u00edcula existente\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"Pel\u00edcula actualizada exitosamente\",\n                     content = @Content(schema = @Schema(implementation = Pelicula.class))),\n        @ApiResponse(responseCode = \"404\", description = \"Pel\u00edcula no encontrada\"),\n        @ApiResponse(responseCode = \"400\", description = \"Datos de pel\u00edcula inv\u00e1lidos\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @PutMapping(\"/{id}\")\n    public ResponseEntity&lt;Pelicula&gt; actualizarPelicula(\n            @Parameter(description = \"ID de la pel\u00edcula a actualizar\", required = true)\n            @PathVariable String id,\n            @Parameter(description = \"Nuevos datos de la pel\u00edcula\", required = true)\n            @RequestBody Pelicula pelicula) {\n        Pelicula peliculaActualizada = peliculaService.actualizarPelicula(id, pelicula);\n        if (peliculaActualizada != null) {\n            return ResponseEntity.ok(peliculaActualizada);\n        }\n        return ResponseEntity.notFound().build();\n    }\n\n    @Operation(\n        summary = \"Eliminar pel\u00edcula\",\n        description = \"Elimina una pel\u00edcula de la base de datos\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"204\", description = \"Pel\u00edcula eliminada exitosamente\"),\n        @ApiResponse(responseCode = \"404\", description = \"Pel\u00edcula no encontrada\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; eliminarPelicula(\n            @Parameter(description = \"ID de la pel\u00edcula a eliminar\", required = true)\n            @PathVariable String id) {\n        if (peliculaService.eliminarPelicula(id)) {\n            return ResponseEntity.noContent().build();\n        }\n        return ResponseEntity.notFound().build();\n    }\n\n    @Operation(\n        summary = \"Buscar pel\u00edculas por t\u00edtulo\",\n        description = \"Busca pel\u00edculas que contengan el texto especificado en el t\u00edtulo (sin distinci\u00f3n de may\u00fasculas/min\u00fasculas)\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"B\u00fasqueda completada exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/buscar/titulo\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; buscarPorTitulo(\n            @Parameter(description = \"Texto a buscar en el t\u00edtulo\", required = true)\n            @RequestParam String titulo) {\n        return ResponseEntity.ok(peliculaService.buscarPorTitulo(titulo));\n    }\n\n    @Operation(\n        summary = \"Buscar pel\u00edculas por director\",\n        description = \"Busca pel\u00edculas dirigidas por el director especificado\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"B\u00fasqueda completada exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/buscar/director\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; buscarPorDirector(\n            @Parameter(description = \"Nombre del director\", required = true)\n            @RequestParam String director) {\n        return ResponseEntity.ok(peliculaService.buscarPorDirector(director));\n    }\n\n    @Operation(\n        summary = \"Buscar pel\u00edculas por pa\u00eds\",\n        description = \"Busca pel\u00edculas producidas en el pa\u00eds especificado\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"B\u00fasqueda completada exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/buscar/pais\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; buscarPorPais(\n            @Parameter(description = \"Pa\u00eds de producci\u00f3n\", required = true)\n            @RequestParam String pais) {\n        return ResponseEntity.ok(peliculaService.buscarPorPais(pais));\n    }\n\n    @Operation(\n        summary = \"Buscar pel\u00edculas por a\u00f1o\",\n        description = \"Busca pel\u00edculas estrenadas en el a\u00f1o especificado\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"B\u00fasqueda completada exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/buscar/anyo\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; buscarPorAnyo(\n            @Parameter(description = \"A\u00f1o de estreno\", required = true, example = \"1972\")\n            @RequestParam Integer anyo) {\n        return ResponseEntity.ok(peliculaService.buscarPorAnyo(anyo));\n    }\n\n    @Operation(\n        summary = \"Buscar pel\u00edculas por g\u00e9nero\",\n        description = \"Busca pel\u00edculas que pertenezcan al g\u00e9nero especificado\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"B\u00fasqueda completada exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/buscar/genero\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; buscarPorGenero(\n            @Parameter(description = \"G\u00e9nero de la pel\u00edcula\", required = true, example = \"Drama\")\n            @RequestParam String genero) {\n        return ResponseEntity.ok(peliculaService.buscarPorGenero(genero));\n    }\n\n    @Operation(\n        summary = \"Buscar pel\u00edculas por puntuaci\u00f3n m\u00ednima\",\n        description = \"Busca pel\u00edculas con una puntuaci\u00f3n IMDB mayor o igual a la especificada\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"B\u00fasqueda completada exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/buscar/puntuacion\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; buscarPorPuntuacionMinima(\n            @Parameter(description = \"Puntuaci\u00f3n m\u00ednima en IMDB\", required = true, example = \"8.0\")\n            @RequestParam Double puntuacion) {\n        return ResponseEntity.ok(peliculaService.buscarPorPuntuacionMinima(puntuacion));\n    }\n\n    @Operation(\n        summary = \"Obtener pel\u00edculas ganadoras de Oscars\",\n        description = \"Retorna todas las pel\u00edculas que han ganado premios Oscar\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"Lista obtenida exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/premios/oscars\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; obtenerPeliculasConOscars() {\n        return ResponseEntity.ok(peliculaService.obtenerPeliculasConOscars());\n    }\n\n    @Operation(\n        summary = \"Obtener pel\u00edculas ganadoras de Goyas\",\n        description = \"Retorna todas las pel\u00edculas que han ganado premios Goya\"\n    )\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"200\", description = \"Lista obtenida exitosamente\"),\n        @ApiResponse(responseCode = \"500\", description = \"Error interno del servidor\")\n    })\n    @GetMapping(\"/premios/goyas\")\n    public ResponseEntity&lt;List&lt;Pelicula&gt;&gt; obtenerPeliculasConGoyas() {\n        return ResponseEntity.ok(peliculaService.obtenerPeliculasConGoyas());\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#modelo-de-datos-pelicula","title":"Modelo de datos (Pelicula)","text":"<p>Actualizamos la clase Pel\u00edcula con las anotaciones de OpenAPI:</p> <pre><code>package org.cipfpcheste.dam2.springmongodb.model;\n\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\nimport org.springframework.data.mongodb.core.mapping.Field;\n\nimport java.util.List;\n\n@Document(collection = \"Peli\")\n@Schema(description = \"Modelo que representa una pel\u00edcula en el sistema\")\npublic class Pelicula {\n\n    @Id\n    @Schema(description = \"Identificador \u00fanico de la pel\u00edcula\", \n            example = \"507f1f77bcf86cd799439011\", \n            accessMode = Schema.AccessMode.READ_ONLY)\n    private String id;\n\n    @Schema(description = \"T\u00edtulo de la pel\u00edcula\", \n            example = \"El Padrino\", \n            required = true)\n    private String titulo;\n\n    @Schema(description = \"A\u00f1o de estreno\", \n            example = \"1972\", \n            required = true)\n    private Integer anyo;\n\n    @Schema(description = \"Nombre del director\", \n            example = \"Francis Ford Coppola\", \n            required = true)\n    private String director;\n\n    @Schema(description = \"Pa\u00eds de producci\u00f3n\", \n            example = \"Estados Unidos\", \n            required = true)\n    private String pais;\n\n    @Schema(description = \"Lista de g\u00e9neros de la pel\u00edcula\", \n            example = \"[\\\"Drama\\\", \\\"Crimen\\\"]\", \n            required = true)\n    private List&lt;String&gt; genero;\n\n    @Field(\"duracion_minutos\")\n    @Schema(description = \"Duraci\u00f3n de la pel\u00edcula en minutos\", \n            example = \"175\")\n    private Integer duracionMinutos;\n\n    @Schema(description = \"Clasificaci\u00f3n por edad\", \n            example = \"R\")\n    private String clasificacion;\n\n    @Field(\"actores_principales\")\n    @Schema(description = \"Lista de actores principales\", \n            example = \"[\\\"Marlon Brando\\\", \\\"Al Pacino\\\", \\\"James Caan\\\"]\")\n    private List&lt;String&gt; actoresPrincipales;\n\n    @Field(\"puntuacion_imdb\")\n    @Schema(description = \"Puntuaci\u00f3n en IMDB\", \n            example = \"9.2\", \n            minimum = \"0\", \n            maximum = \"10\")\n    private Double puntuacionImdb;\n\n    @Field(\"taquilla_global_millones\")\n    @Schema(description = \"Recaudaci\u00f3n global en millones de d\u00f3lares\", \n            example = \"246.1\")\n    private Double taquillaGlobalMillones;\n\n    @Schema(description = \"N\u00famero de premios Oscar ganados\", \n            example = \"3\")\n    private Integer oscars;\n\n    @Field(\"premios_goya\")\n    @Schema(description = \"N\u00famero de premios Goya ganados\", \n            example = \"0\")\n    private Integer premiosGoya;\n\n    // Constructores\n    public Pelicula() {\n    }\n\n    public Pelicula(String titulo, Integer anyo, String director, String pais,\n                    List&lt;String&gt; genero, Integer duracionMinutos, String clasificacion,\n                    List&lt;String&gt; actoresPrincipales, Double puntuacionImdb,\n                    Double taquillaGlobalMillones) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.director = director;\n        this.pais = pais;\n        this.genero = genero;\n        this.duracionMinutos = duracionMinutos;\n        this.clasificacion = clasificacion;\n        this.actoresPrincipales = actoresPrincipales;\n        this.puntuacionImdb = puntuacionImdb;\n        this.taquillaGlobalMillones = taquillaGlobalMillones;\n    }\n\n    // Getters y Setters\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getTitulo() {\n        return titulo;\n    }\n\n    public void setTitulo(String titulo) {\n        this.titulo = titulo;\n    }\n\n    public Integer getAnyo() {\n        return anyo;\n    }\n\n    public void setAnyo(Integer anyo) {\n        this.anyo = anyo;\n    }\n\n    public String getDirector() {\n        return director;\n    }\n\n    public void setDirector(String director) {\n        this.director = director;\n    }\n\n    public String getPais() {\n        return pais;\n    }\n\n    public void setPais(String pais) {\n        this.pais = pais;\n    }\n\n    public List&lt;String&gt; getGenero() {\n        return genero;\n    }\n\n    public void setGenero(List&lt;String&gt; genero) {\n        this.genero = genero;\n    }\n\n    public Integer getDuracionMinutos() {\n        return duracionMinutos;\n    }\n\n    public void setDuracionMinutos(Integer duracionMinutos) {\n        this.duracionMinutos = duracionMinutos;\n    }\n\n    public String getClasificacion() {\n        return clasificacion;\n    }\n\n    public void setClasificacion(String clasificacion) {\n        this.clasificacion = clasificacion;\n    }\n\n    public List&lt;String&gt; getActoresPrincipales() {\n        return actoresPrincipales;\n    }\n\n    public void setActoresPrincipales(List&lt;String&gt; actoresPrincipales) {\n        this.actoresPrincipales = actoresPrincipales;\n    }\n\n    public Double getPuntuacionImdb() {\n        return puntuacionImdb;\n    }\n\n    public void setPuntuacionImdb(Double puntuacionImdb) {\n        this.puntuacionImdb = puntuacionImdb;\n    }\n\n    public Double getTaquillaGlobalMillones() {\n        return taquillaGlobalMillones;\n    }\n\n    public void setTaquillaGlobalMillones(Double taquillaGlobalMillones) {\n        this.taquillaGlobalMillones = taquillaGlobalMillones;\n    }\n\n    public Integer getOscars() {\n        return oscars;\n    }\n\n    public void setOscars(Integer oscars) {\n        this.oscars = oscars;\n    }\n\n    public Integer getPremiosGoya() {\n        return premiosGoya;\n    }\n\n    public void setPremiosGoya(Integer premiosGoya) {\n        this.premiosGoya = premiosGoya;\n    }\n}\n</code></pre>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#configuracion-opcional-en-applicationproperties","title":"Configuraci\u00f3n Opcional en application.properties","text":"<pre><code>springdoc.api-docs.path=/api-docs\nspringdoc.swagger-ui.path=/swagger-ui.html\nspringdoc.swagger-ui.operationsSorter=method\nspringdoc.swagger-ui.tagsSorter=alpha\nspringdoc.swagger-ui.tryItOutEnabled=true\n</code></pre> <p>No es necesaria.</p>"},{"location":"Unidad%206%20MongoDB/6_Spring_MongoDB.es/#acceso-con-el-interfaz-web","title":"Acceso con el interfaz Web","text":"<p>Por defecto podemos acceder a la aplicaci\u00f3n desde esta url: http://localhost:8080/swagger-ui/index.html</p> <p></p> <p>El proyecto final lo podemos encontrar aqui</p>"},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/","title":"Configuraci\u00f3n del entorno de trabajo","text":""},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#configuracion-del-entorno-de-trabajo","title":"Configuraci\u00f3n del entorno de trabajo","text":"<p>A continuaci\u00f3n explicaremos como instalar el software necesario para realizar este curso:</p> <ul> <li>Python3</li> <li>Visual Studio Code: El IDE</li> <li>Visual Studio Code: Extensiones</li> <li>Anaconda: Anaconda Navigator: Jupyter Notebook</li> <li>Instalar paquetes de Python</li> </ul>"},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#instalacion-de-python","title":"Instalaci\u00f3n de  Python","text":"<pre><code>sudo apt-get install python python3\n</code></pre>"},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#comprobamos-que-esta-bien-instalado","title":"Comprobamos que est\u00e1 bien instalado","text":"<pre><code>python3\n</code></pre>"},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#visual-studio-code","title":"Visual Studio Code","text":"<pre><code>sudo apt-get update\nsudo apt-get install apt-transport-https\nsudo apt-get install curl\n</code></pre> <p>Despu\u00e9s instalamos el repositorio:</p> <pre><code>curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.gpg\nsudo install -o root -g root -m 644 microsoft.gpg /etc/apt/trusted.gpg.d/\nsudo sh -c 'echo \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable\nmain\" &gt; /etc/apt/sources.list.d/vscode.list\n</code></pre> <p>Por \u00faltimo actualizamos el sistema e instalamos el visual code:</p> <pre><code>sudo apt-get update\nsudo apt-get install code\n</code></pre>"},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#visual-studio-code-extensiones","title":"Visual Studio Code: Extensiones","text":""},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#anaconda-anaconda-navigator-jupyter-notebook","title":"Anaconda: Anaconda Navigator: Jupyter Notebook","text":"<p>Para instalar Anaconda, tanto en Ubuntu como en Windows, hace falta registrarse gratuitamente en https://www.anaconda.com/, descargar el instalador y seguir las instrucciones.</p> <p>Para comprobar si funciona correctamente despu\u00e9s de la instalaci\u00f3n escribiremos por consola:</p> <pre><code>conda list\n</code></pre> <p>En algunos casos hace falta activar anaconda para futuros arranques poniendo la ruta adecuada seg\u00fan donde tengamos la instalaci\u00f3n:</p> <pre><code>source /home/manu/anaconda3/bin/activate\n</code></pre> <p>Tras realizar la instalaci\u00f3n podemos lanzar anaconda-navigator por consola:</p> <pre><code>anaconda-navigator\n</code></pre> <p></p> <p>Podemos lanzar jupyter.  Jupiter Notebook es un entorno de desarrollo muy sencillo que se utiliza a trav\u00e9s del navegador, lo cual facilita much\u00edsimo su uso al no hacer falta instalar ning\u00fan componente adicional. Nos va a permitir escribir c\u00f3digo en Python, pero adem\u00e1s tambi\u00e9n mezclarlo con otros componentes interesantes, como pueden ser \u201ctexto no ejecutable\u201d para documentar. Tambi\u00e9n nos permitir\u00e1 guardar el resultado de la ejecuci\u00f3n de ese c\u00f3digo en Python para que cuando lo abramos no tengamos que ejecutarlo para ver que hace.</p> <p>Dentro de Jupyter Notebook podemos navegar por nuestro directorio de carpetas y crear una nueva carpeta. Si queremos crear una nueva carpeta dentro de \u201cDocumentos\u201d pulsamos en \u201cNew\\Folder\u201d y si queremos cambiarle el nombre por defecto podemos seleccionar la carpeta y pulsar en \u201cRename\u201d para darle el nombre \u201cHolaMundo\u201d. Creemos nuestro primer notebook (\u201cNew\\Python [conda env:base]\u201d) y cambiemosle el nombre a \u201cHolaMundo\u201d pulsando sobre el t\u00edtulo por defecto:</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"Unidad%207%20IA/Configuraci%C3%B3n%20del%20entorno%20de%20trabajo/#instalar-paquetes-de-python","title":"Instalar paquetes de Python:","text":"<pre><code>conda install numpy\nconda install pandas\nconda install matplotlib\nconda install seaborn\nconda install scikit-learn\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/","title":"NLP: Transformers y LLMs","text":"<p>Ponente: Jose Ram\u00f3n Cebolla Cebolla  </p> <p>Objetivos de la sesi\u00f3n: </p> <p>En esta sesi\u00f3n aprenderemos a:  </p> <ul> <li>Comprender c\u00f3mo la arquitectura Transformer y los Grandes Modelos de Lenguaje (LLMs) han revolucionado por completo el Procesamiento del Lenguaje Natural.  </li> <li>Entender el mecanismo de atenci\u00f3n, la idea clave que permite a los Transformers capturar el significado y el contexto profundo de un texto.  </li> <li>Implementar ejemplos pr\u00e1cticos en Python para dominar las distintas variantes de Transformers (Encoders, Decoders y Encoder-Decoders) y resolver una gran variedad de tareas, desde clasificaci\u00f3n avanzada hasta generaci\u00f3n o traducci\u00f3n de texto.  </li> <li>Aprender a interactuar directamente con LLMs de \u00faltima generaci\u00f3n, como Mistral, a trav\u00e9s de sus APIs, para poder utilizar todo su potencial en nuestras propias aplicaciones creando una webapp con Flask y opcionalmente dockeriz\u00e1ndola.  </li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#evolucion-del-nlp-la-era-de-los-transformers-y-llms","title":"Evoluci\u00f3n del NLP: La Era de los Transformers y LLMs","text":"<p>El procesamiento del lenguaje natural (NLP) ha evolucionado desde enfoques manuales hasta m\u00e9todos basados en datos y aprendizaje profundo. Esta sesi\u00f3n explora su \u00faltima etapa para entender en qu\u00e9 situaci\u00f3n nos encontramos:</p> <ul> <li>Etapa 1: Sistemas basados en reglas (1950s-1980s)</li> <li>Etapa 2: M\u00e9todos estad\u00edsticos y ML cl\u00e1sico (1990s-2010)</li> <li>Etapa 3: Word embeddings y redes neuronales (2010s)</li> <li>Etapa 4: Transformers y LLMs (2017-Actualidad)</li> </ul> <p>La IA es capaz de comprender la entrada y responder adecuadamente. En los \u00faltimos a\u00f1os la IA est\u00e1 en boca de todos y se ha normalizado el uso de chatbots conversacionales como ChatGPT.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#futuro-del-nlp","title":"Futuro del NLP","text":"<p>A nivel laboral est\u00e1 comenzando una era disruptiva con la utilizaci\u00f3n de la IA generativa para ser m\u00e1s productivo en un sinf\u00edn de tareas.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#etapa-4-transformers-y-llms-2017-actualidad","title":"Etapa 4 \u2013 Transformers y LLMs (2017-Actualidad)","text":""},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#arquitectura-transformer","title":"Arquitectura Transformer","text":"<p>\u00a1\u00a1El paper \u201cAttention is all you need\u201d lo cambi\u00f3 todo!!</p> <p>\u00bfPor qu\u00e9 los Transformers son tan buenos?</p> <p>Imagina que lees un libro y recuerdas solo las partes importantes sin repetir todo. \u00a1Eso hace un transformer!</p> <p>Antes los modelos, como RNN, eran lentos y olvidaban el contexto lejano.</p> <p>A lo largo de esta pr\u00e1ctica intentaremos explicar el motivo, pero por ejemplo, en \u201cPensaba que ser\u00eda el mejor d\u00eda de mi vida, pero cuando vi a Jose me di cuenta que no lo ser\u00eda\u201d, un transformer llega a entender que la frase es negativa a pesar de que hasta el final de la frase no se dan pistas...</p> <p>Usan \u201catenci\u00f3n\u201d en lugar de procesar palabras una por una.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#entendiendo-como-funciona-la-atencion-en-los-transformers","title":"Entendiendo c\u00f3mo funciona la atenci\u00f3n en los Transformers","text":"<p>La atenci\u00f3n en los modelos Transformer es el mecanismo clave que les permite procesar el lenguaje de manera efectiva, logrando crear relaciones entre palabras, capturar el contexto din\u00e1mico y recordar la informaci\u00f3n lejana.</p> <p>Si nos paramos a pensar, tener una representaci\u00f3n est\u00e1tica de una palabra no refleja toda la riqueza del lenguaje. Incorporar el resto del contexto en la representaci\u00f3n sem\u00e1ntica de las palabras nos permite profundizar en el significado real que toma esa palabra en ese contexto concreto.</p> <p>T\u00e9cnicamente, funciona a trav\u00e9s del mecanismo de autoatenci\u00f3n (Self-Attention), que nos permitir\u00e1, si nos quedamos con la esencia de las palabras, hacer cosas como traducir textos de entrada de un lenguaje a otro.</p> <p></p> <p>Para las explicaciones utilizar\u00e9 los gr\u00e1ficos de Jay Alammar: https://jalammar.github.io/illustrated-transformer/</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#funcionamiento-de-la-autoatencion","title":"Funcionamiento de la Autoatenci\u00f3n","text":""},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#1-proyeccion-a-vectores-query-key-y-value","title":"1. Proyecci\u00f3n a vectores \u2018Query\u2019, \u2018Key\u2019 y \u2018Value\u2019","text":"<p>Para cada token (palabra o subpalabra) en la secuencia de entrada, se proyecta su embedding inicial en tres vectores diferentes mediante tres matrices de pesos aprendibles: Query (WQ), Key (WK) y Value (WV).</p> <p></p> <p>Veamoslo con la representaci\u00f3n de la frase \u201cThinking Machines\u201d:</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#simil-de-biblioteca","title":"S\u00edmil de biblioteca","text":"<ul> <li> <p>Query (Consulta): Representa lo que cada palabra est\u00e1 buscando en las dem\u00e1s palabras de la oraci\u00f3n. Son como las preguntas que haces en la biblioteca para encontrar informaci\u00f3n espec\u00edfica. Por ejemplo, podr\u00edas preguntar: \u201c\u00bfD\u00f3nde puedo encontrar informaci\u00f3n sobre la Segunda Guerra Mundial?\u201d</p> </li> <li> <p>Key (Clave): Representa lo que cada palabra ofrece a las dem\u00e1s en t\u00e9rminos de informaci\u00f3n relevante. Son como etiquetas que describen el contenido de cada libro en la biblioteca. Cada libro tiene una serie de etiquetas que indican sobre qu\u00e9 temas trata. Por ejemplo, un libro podr\u00eda tener las claves \u201cHistoria\u201d, \u201cSegunda Guerra Mundial\u201d, \u201cEuropa\u201d.</p> </li> <li> <p>Value (Valor): Contiene la informaci\u00f3n real que se agregar\u00e1 a la representaci\u00f3n de la palabra actual bas\u00e1ndose en la atenci\u00f3n. Son el contenido real de los libros, es decir, la informaci\u00f3n que contienen. Siguiendo con el ejemplo, el valor ser\u00eda el texto completo de un libro sobre la Segunda Guerra Mundial.</p> </li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#como-logra-la-atencion-sus-objetivos","title":"\u00bfC\u00f3mo logra la Atenci\u00f3n sus objetivos?","text":"<ol> <li>Crear y dar fuerza a las relaciones entre palabras en una oraci\u00f3n:</li> <li>El mecanismo de autoatenci\u00f3n permite que cada palabra interact\u00fae directamente con todas las dem\u00e1s a trav\u00e9s del c\u00e1lculo de las puntuaciones de relevancia entre sus vectores \u2018Query\u2019 y \u2018Key\u2019.</li> <li>Cuanto m\u00e1s sem\u00e1nticamente relacionadas sean dos palabras en un contexto dado, mayor ser\u00e1 la puntuaci\u00f3n de relevancia entre su \u2018Query\u2019 y su \u2018Key\u2019, lo que resultar\u00e1 en un mayor peso de atenci\u00f3n.</li> <li> <p>Al combinar los vectores \u2018Value\u2019 ponderados por estos pesos de atenci\u00f3n, la representaci\u00f3n de cada palabra se enriquece con la informaci\u00f3n de las palabras con las que tiene relaciones m\u00e1s fuertes.</p> </li> <li> <p>Capturar el contexto din\u00e1mico de las palabras:</p> </li> <li>A diferencia de los embeddings de palabras est\u00e1ticos (como Word2Vec) que tienen una representaci\u00f3n fija para cada palabra, la autoatenci\u00f3n genera embeddings contextualizados. Por eso tambi\u00e9n se les llama modelos de embeddings contextualizados.</li> <li> <p>La representaci\u00f3n de cada token se vuelve dependiente del contexto de toda la secuencia porque se calcula considerando su relaci\u00f3n con todos los dem\u00e1s tokens.</p> </li> <li> <p>No olvidar el contexto lejano:</p> </li> <li>Las capas recurrentes (como LSTMs y GRUs) tienen dificultades para mantener la informaci\u00f3n de partes lejanas de la secuencia debido al problema de la \"memoria a corto plazo\".</li> <li>El mecanismo de autoatenci\u00f3n, en cambio, permite que cada palabra atienda directamente a cualquier otra palabra en la secuencia, independientemente de su distancia lineal. No hay una dependencia secuencial estricta; la informaci\u00f3n puede fluir directamente entre palabras lejanas a trav\u00e9s de las conexiones de atenci\u00f3n.</li> <li>Esto es crucial para entender oraciones largas donde las dependencias sem\u00e1nticas pueden existir entre palabras que est\u00e1n muy separadas.</li> </ol>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplos-practicos-de-atencion","title":"Ejemplos pr\u00e1cticos de atenci\u00f3n","text":"<ol> <li> <p>\"Juan esta durmiendo en su habitaci\u00f3n tranquilo\":    Los transformers entienden que \"tranquilo\" se refiere a \"Juan\" aunque est\u00e9 muy lejos y est\u00e9 junto a la palabra \"habitaci\u00f3n\".</p> </li> <li> <p>Diferencias entre \"Juan esta sentado en el banco\" (mueble) y \"Deposit\u00f3 dinero en el banco\" (edificio):    Los embeddings contextualizados resultantes para \"banco\" en ambas frases ser\u00e1n diferentes, reflejando sus distintos significados contextuales. Esto permite al Transformer diferenciar la polisemia de las palabras.</p> </li> <li> <p>\"Pensaba que ser\u00eda el mejor d\u00eda de mi vida, pero cuando vi a Jose me di cuenta que no lo ser\u00eda\":    Permite al modelo mantener la coherencia sem\u00e1ntica y \"recordar\" el contexto lejano para entender la contradicci\u00f3n impl\u00edcita.</p> </li> </ol>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#resumen-del-mecanismo-de-atencion","title":"Resumen del mecanismo de atenci\u00f3n","text":"<p>En resumen, el mecanismo de atenci\u00f3n del Transformer, a trav\u00e9s del c\u00e1lculo din\u00e1mico de la relevancia entre palabras y la creaci\u00f3n de embeddings contextualizados, permite capturar complejas relaciones sem\u00e1nticas, adaptarse al contexto cambiante de las palabras y mantener la informaci\u00f3n relevante incluso a largas distancias dentro de una secuencia.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#tipos-de-transformers","title":"Tipos de Transformers","text":"<p>Profundicemos a continuaci\u00f3n los distintos tipos de Transformers que existen:</p> <ul> <li>Encoders</li> <li>Decoders</li> <li>Encoders-Decoders</li> </ul> <p>Muchos de estos transformers pueden funcionar con GPU o con CPU a una velocidad m\u00e1s lenta, lo que les da un valor a\u00f1adido.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#modelos-encoder","title":"Modelos Encoder","text":"<p>Los modelos Encoder son Transformers que est\u00e1n dise\u00f1ados para comprender el texto de entrada codific\u00e1ndolo de forma informativa, creando una representaci\u00f3n enriquecida de la entrada.</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplos-de-modelos-encoder","title":"Ejemplos de modelos Encoder:","text":"<ul> <li>BERT (Bidirectional Encoder Representations from Transformers), lanzado en octubre de 2018.</li> <li>DistilBERT, una versi\u00f3n destilada de BERT (60% m\u00e1s r\u00e1pida, 40% m\u00e1s ligera).</li> <li>RoBERTa, SpanBERT, ALBERT, DeBERTa, DeBERTa-v2, DeBERTa-v3.</li> </ul> <p>Los modelos Encoder son m\u00e1s aptos para tareas de comprensi\u00f3n de texto (NLU = Natural Language Understanding).</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#tareas-tipicas-de-encoder","title":"Tareas t\u00edpicas de Encoder:","text":"<ul> <li>Clasificaci\u00f3n de texto</li> <li>Reconocimiento de Entidades Nombradas (NER)</li> <li>Recuperaci\u00f3n de informaci\u00f3n (IR)</li> <li>An\u00e1lisis de sentimientos, detecci\u00f3n de spam, clasificaci\u00f3n de pares de texto.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplos-practicos-con-encoders","title":"Ejemplos pr\u00e1cticos con Encoders","text":"<p>En los siguientes apartados se explicaran los ejemplos de c\u00f3digo del fichero Puedes abrirlo en Google Colab e ir probandolo.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#clasificacion-binaria-con-distilbert","title":"Clasificaci\u00f3n binaria con DistilBERT","text":"<pre><code>from transformers import pipeline\n\nclasificador = pipeline('sentiment-analysis')\nprint(clasificador.model.name_or_path)\nprint(clasificador.tokenizer.name_or_path)\n\nmensajeEN = ['Love this product!', \"Terrible service, horrible day\", ...]\nresults = clasificador(mensajeEN)\n\nfor mensaje, result in zip(mensajeEN, results):\n    print(f\"Mensaje: {mensaje} -&gt; Sentimiento: {result['label']} (Score: {result['score']:.2f})\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#clasificacion-ternaria-en-espanol-con-roberta","title":"Clasificaci\u00f3n ternaria en espa\u00f1ol con RoBERTa","text":"<pre><code>clasificador = pipeline('text-classification', model=\"pysentimiento/robertuito-sentiment-analysis\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#analisis-de-sentimiento-con-bert-multilingue","title":"An\u00e1lisis de sentimiento con BERT multiling\u00fce","text":"<pre><code>classifier = pipeline(\"sentiment-analysis\", model=\"nlptown/bert-base-multilingual-uncased-sentiment\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ner-con-bert-en-espanol","title":"NER con BERT en espa\u00f1ol","text":"<pre><code>ner_pipeline = pipeline(\"ner\", model=\"nrm8488/bert-spanish-cased-finetuned-ner\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#recuperacion-de-informacion-ir-con-distilbert","title":"Recuperaci\u00f3n de informaci\u00f3n (IR) con DistilBERT","text":"<pre><code>qa = pipeline('question-answering')\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#clasificacion-multi-etiqueta-con-roberta","title":"Clasificaci\u00f3n multi-etiqueta con RoBERTa","text":"<pre><code>classifier = pipeline(task=\"text-classification\", model=\"Sambove/roberta-base-go_emotions\", top_k=None)\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#clasificacion-zero-shot-con-deberta","title":"Clasificaci\u00f3n Zero-Shot con DeBERTa","text":"<pre><code>zero_shot_classifier = pipeline(\"zero-shot-classification\", model=\"MoritzLaurer/mDeBERTa-v3-base-mnli-xnli\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#modelos-decoder","title":"Modelos Decoder","text":"<p>Los modelos decoder son Transformers que se centran en generar texto de forma autoregresiva, lo que significa que retroceden o predicen el siguiente valor de una secuencia en funci\u00f3n de todos los valores anteriores.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplos-de-modelos-decoder","title":"Ejemplos de modelos Decoder:","text":"<ul> <li>GPT (Improving Language Understanding by Generative Pre-Training), junio 2018.</li> <li>GPT-2, GPT-3, GPT-4.</li> <li>Modelos opensource: Mistral, Phi-2, Qwen-1.5, Gemma.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplo-practico-generacion-de-texto-con-gpt-2","title":"Ejemplo pr\u00e1ctico: Generaci\u00f3n de texto con GPT-2","text":"<pre><code>from transformers import pipeline, set_seed\n\ngenerador = pipeline(\"text-generation\", model=\"gpt2\")\nset_seed(42)\ntexto = generador(\"Hello, I'm a language model.\", max_length=30, num_return_sequences=5)\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#modelos-encoder-decoder","title":"Modelos Encoder-Decoder","text":"<p>Los modelos encoder-decoder son Transformers que act\u00faan como un puente entre la comprensi\u00f3n y la generaci\u00f3n de texto. Toman una secuencia de entrada, la codifican en una representaci\u00f3n, y luego utilizan un decoder para generar una secuencia de salida. Por ello hay quien los llama tambi\u00e9n modelos secuencia a secuencia.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplos","title":"Ejemplos:","text":"<ul> <li>BART (octubre 2019)</li> <li>T5 (Text-to-Text Transformer, octubre 2019)</li> <li>Pegasus (diciembre 2019)</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#aplicaciones-principales","title":"Aplicaciones principales:","text":"<ul> <li>Traducci\u00f3n autom\u00e1tica</li> <li>Resumen autom\u00e1tico</li> <li>Respuesta generativa a preguntas</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplos-practicos","title":"Ejemplos pr\u00e1cticos:","text":""},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#traduccion-de-texto-con-seq2seq","title":"Traducci\u00f3n de texto con seq2seq","text":"<pre><code>traductor = pipeline(\"translation_en_to_es\", model=\"Helsinki-NLP/opus-mt-en-es\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#resumen-de-texto-con-bart","title":"Resumen de texto con BART","text":"<pre><code>resumen = pipeline(\"summarization\", model=\"facebook/bart-large-cnn\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#clasificacion-few-shot-con-bart","title":"Clasificaci\u00f3n Few-shot con BART","text":"<pre><code>classifier = pipeline(\"zero-shot-classification\", model=\"facebook/bart-large-mnli\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#respuesta-generativa-a-pregunta","title":"Respuesta generativa a pregunta","text":"<pre><code>qa_pipeline = pipeline(\"text2text-generation\", tokenizer=\"vgaraujov/t5-base-spanish\", model=\"benjleite/t5s-spanish-qa\")\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#recapitulacion-de-arquitecturas","title":"Recapitulaci\u00f3n de arquitecturas","text":"<ul> <li>Modelos encoder: Especializados en tareas que requieren comprender la entrada (clasificaci\u00f3n, NER). Tambi\u00e9n conocidos como modelos bidireccionales.</li> <li>Modelos decoder: Especializados en tareas generativas. Tambi\u00e9n conocidos como modelos generativos.</li> <li>Modelos encoder-decoder: Buenas para tareas generativas que requieren comprender una entrada para generar una salida (traducci\u00f3n, resumen). Tambi\u00e9n conocidos como modelos seq2seq.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#grandes-modelos-del-lenguaje-llms","title":"Grandes Modelos del Lenguaje (LLMs)","text":"<p>Los LLMs (Large Language Models) son modelos con millones de par\u00e1metros. Permiten di\u00e1logos naturales y respuestas \u00fatiles capaces de traducir y entender lo que se le pide con precisi\u00f3n.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#usos-principales","title":"Usos principales:","text":"<ul> <li>Generaci\u00f3n de texto (contenido, chatbots, c\u00f3digo)</li> <li>Modelos de chat generativos: ChatGPT, Claude, Gemini, Deepseek, Llama, Mixtral, Grok, etc.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejemplo-practico-mistral-ai","title":"Ejemplo pr\u00e1ctico: Mistral AI","text":"<p>Pasos para utilizar la API de Mistral:</p> <ol> <li>Crear espacio en https://console.mistral.ai/</li> <li>Configurar plan (gratuito o de pago) </li> <li>Indica que quieres experimentar con un plan gratuito: </li> <li>Suscr\u00edbete y verifica tu n\u00famero de tel\u00e9fono: </li> <li>Crear una API Key </li> <li>Consultar documentaci\u00f3n en https://docs.mistral.ai/getting-started/quickstart/ </li> </ol>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#codigo-de-ejemplo","title":"C\u00f3digo de ejemplo:","text":"<ol> <li>Podemos crear una variable de entorno en nuestro sistema operativo que lea el valor de esa api_key o podemos poner directamente la clave en el valor de la api_key si tenemos un fichero \u201c.py\u201d con el c\u00f3digo en local. Si ponemos la clave en Google Colab para probar, acordaros despu\u00e9s de borrarla de Mistral por seguridad..</li> </ol> <pre><code>from mistralai import Mistral\n\napi_key = \"TU_API_KEY\"\nmodel = \"mistral-large-latest\"\n\nclient = Mistral(api_key=api_key)\n\nchat_response = client.chat.complete(\n    model=model,\n    messages=[{\"role\": \"user\", \"content\": \"What is the best French cheese?\"}]\n)\n\nprint(chat_response.choices[0].message.content)\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ejercicio-guiado-crear-una-webapp-con-flask","title":"Ejercicio guiado: Crear una webapp con Flask","text":""},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#objetivos","title":"Objetivos:","text":"<ul> <li>Crear entornos virtuales con conda.</li> <li>Desarrollar APIs (Backend) que accedan a la API de Mistral.</li> <li>Desarrollar FrontEnd en HTML con Flask.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#pasos","title":"Pasos:","text":""},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#1-crear-entorno-virtual-con-conda","title":"1. Crear entorno virtual con Conda","text":"<pre><code>conda create --name proyectoFlask python=3.11.2\nconda activate proyectoFlask\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#2-instalar-dependencias","title":"2. Instalar dependencias","text":"<pre><code>pip install flask mistralai python-dotenv markdown\n</code></pre> <p>Si quisieramos desactivar el entorno:</p> <pre><code>conda deactivate\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#3-estructura-del-proyecto","title":"3. Estructura del proyecto","text":"<p>Vamos a crear una carpeta \u2018chef_mistral_flask\u2019, dentro creamos un fichero \u201c.env\u201d con la clave de mistral :</p> <p><pre><code>echo \"MISTRAL_API_KEY=tu_clave_aki\"&gt;.env\n</code></pre> El fichero .env nos servir\u00e1 para leer la clave de mistral sin tener que ponerla directamente en el fichero de Python. Es una muy buena pr\u00e1ctica si despu\u00e9s queremos subir nuestra webapp a Github o similar, porque en ese caso subiremos todos los ficheros menos el fichero \u201c.env\u201d para evitar estar dando nuestro c\u00f3digo a cualquiera que pueda leer nuestros ficheros Python. Ya podemos abrir la carpeta \u2018chef_mistral_flask\u2019 desde VSCode.</p> <ul> <li><code>chef_mistral_flask/</code></li> <li><code>templates/</code> (contiene <code>home.html</code>)</li> <li><code>.env</code> (clave de Mistral)</li> <li><code>utilities_chef.py</code> (funciones de llamada a Mistral)</li> <li><code>app.py</code> (aplicaci\u00f3n Flask principal)</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#4-archivo-utilities_chefpy","title":"4. Archivo <code>utilities_chef.py</code>","text":"<p>Configurar mistral en la webapp: utilities_chef.py: Copiamos el fichero utilities_chef.py en la raiz del proyecto. De momento no reconoce la librer\u00eda mistralai, pero lo solucionamos enseguida:</p> <p></p> <pre><code>from mistralai import Mistral\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\napi_key = os.getenv(\"MISTRAL_API_KEY\")\nclient = Mistral(api_key=api_key)\n\ndef LLM_response(ingredientes):\n    prompt = f\"Genera una receta con estos ingredientes: {ingredientes}\"\n    response = client.chat.complete(\n        model=\"mistral-large-latest\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return response.choices[0].message.content\n</code></pre> <p>Pulsamos en la versi\u00f3n del interprete de Python (cuadro rojo inferior) y en el desplegable seleccionamos \u201cproyectoFlask\u201d (cuadro rojo superior) para que las librer\u00edas se importen:</p> <p></p> <p>Descomentamos la parte final del fichero para probar a llamar a Mistral y ya podemos ejecutar el fichero y comprobar si responde bien. Una vez probado volver a comentar.</p> <p></p> <p>Creamos la carpeta \u201ctemplates\u201d en nuestro proyecto y copiamos el fichero \u201chome.html\u201d de la carpeta de Recursos. Si lo abrimos podemos comprobar que al introducir los ingredientes llamar\u00e1 a \u201cgenerar_receta\u201d:</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#5-archivo-apppy","title":"5. Archivo <code>app.py</code>","text":"<p>Copiamos app.py, que ser\u00e1 quien atienda el servicio web utilizando Flask y mostrando la p\u00e1gina principal (home.html) a trav\u00e9s del decorador app.route cuando se acceda a la ra\u00edz de nuestra web:</p> <p></p> <pre><code>from utilities_chef import LLM_response\nfrom flask import Flask, render_template, request\nimport markdown\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('home.html', val='')\n\n@app.route('/generar_receta', methods=['POST'])\ndef generate_recipe():\n    if request.method == 'POST':\n        ingredients = request.form.get('INGREDIENTS', '').strip()\n        if not ingredients:\n            return render_template('home.html', val='Introduce ingredientes.')\n\n        try:\n            receta = LLM_response(ingredients)\n            receta_html = markdown.markdown(receta)\n            return render_template('home.html', ingredients_input=ingredients, val=receta_html)\n        except Exception as e:\n            return render_template('home.html', val=f'Error: {str(e)}')\n</code></pre> <p>Si solicitamos \u201cgenerar_receta\u201d en modo POST desde el formulario donde le indicamos los ingredientes invocaremos a Mistral utilizando el m\u00e9todo LLM_response que hemos creado en el fichero de utilidades:</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#6-ejecutar-la-aplicacion","title":"6. Ejecutar la aplicaci\u00f3n","text":"<p>Lancemos la aplicaci\u00f3n, comprobemos que esta corriendo y ya podemos probarla.</p> <p>Ten en cuenta que tarda en responder. La webapp es mejorable, pero como prueba de concepto es suficiente.</p> <pre><code>python app.py\n</code></pre> <p></p> <p>Acceder a <code>http://127.0.0.1:5000</code></p> <p> </p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#entrega-mini-webapp-con-flask-y-mistral","title":"Entrega: Mini-WebApp con Flask y Mistral","text":"<p>Crea un nuevo proyecto Flask que interact\u00fae con la API de Mistral para resolver un problema interesante.</p>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#ideas","title":"Ideas:","text":"<ul> <li>Generador de ideas para posts o tuits</li> <li>Asistente de programaci\u00f3n (explica c\u00f3digo)</li> <li>Ayudante de escritura (correcci\u00f3n gramatical, resumen)</li> <li>Traductor simple</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20Transformers%20y%20LLMs/#requisitos-de-entrega","title":"Requisitos de entrega:","text":"<ul> <li>Ficheros Python (<code>app.py</code>, <code>utilities.py</code>, etc.)</li> <li>Plantillas HTML</li> <li><code>requirements.txt</code></li> </ul>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/","title":"NLP: SpringAI","text":"<p>Ponente: Jose Ram\u00f3n Cebolla Cebolla Objetivos de la sesi\u00f3n:</p> <p>En esta sesi\u00f3n aprenderemos a: </p> <ul> <li>Utilizar otro lenguaje de programaci\u00f3n diferente a Python para IA.</li> <li>Comprender como funciona el ecosistema de LLMs que proporciona Groq.</li> <li>Crear un chatbot con Spring AI.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#ia-java-vs-python","title":"IA: Java vs. Python:","text":"<p>En esta pr\u00e1ctica vamos a utilizar Java para realizar un chatbot cuentachistes.</p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#por-que-utilizaremos-java-y-no-python","title":"\u00bfPor qu\u00e9 utilizaremos Java y no Python?","text":"<ul> <li>Aunque actualmente el lenguaje dominante en IA es claramente Python, no solo se puede hacer IA con Python.</li> <li>Spring Boot est\u00e1 abriendo una puerta enorme a utilizar la IA en proyectos Java con sus dependencias de Maven relacionadas con la IA.</li> <li>The New Stack, una plataforma de medios tecnol\u00f3gicos enfocada en noticias, an\u00e1lisis y recursos sobre Desarrollo Software, Tecnolog\u00edas Cloud Nativas y herramientas Open Source ha publicado recientemente (7 de Febrero de 2025) un art\u00edculo sobre este tema y afirma que Java se est\u00e1 posicionando para superar a Python como lenguaje dominante en el desarrollo de inteligencia artificial en un m\u00e1ximo de 3 a\u00f1os, especialmente en entornos empresariales. Afirman que Python probablemente mantendr\u00e1 su posici\u00f3n en investigaci\u00f3n y prototipado r\u00e1pido, pero Java est\u00e1 ganando terreno en implementaciones empresariales de IA gracias a su rendimiento, escalabilidad y ecosistema maduro. La industria parece estar movi\u00e9ndose hacia un modelo donde Python se usa para experimentaci\u00f3n inicial y Java para implementaci\u00f3n a producci\u00f3n. Este cambio podr\u00eda redefinir el panorama de desarrollo de IA en los pr\u00f3ximos a\u00f1os, con Java recuperando terreno en un dominio donde Python ha reinado durante m\u00e1s de una d\u00e9cada.</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#spring-ai-dependencias-disponibles","title":"Spring AI \u2013 Dependencias disponibles","text":"<p>Como podemos ver, el framework de Java Spring Boot ya pone a nuestra disposici\u00f3n muchas dependencias relacionadas con IA:</p> <p></p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#spring-ai-documentacion-oficial","title":"Spring AI \u2013 Documentaci\u00f3n oficial","text":"<p>Spring Boot tambi\u00e9n nos proporciona con Spring AI una web centrada en Inteligencia Artificial desde https://docs.spring.io/spring-ai/reference/index.html:</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#ecosistema-groq","title":"Ecosistema Groq","text":"<p>Antes de crear nuestra aplicaci\u00f3n debemos tener claro qu\u00e9 LLM queremos utilizar para conseguir una API_KEY del LLM seleccionado.</p> <p>Con Spring Boot podemos seleccionar m\u00faltiples LLMs de manera nativa con las dependencias de Spring Boot: Mistral, OpenAI, Ollama, \u2026</p> <p>En la pr\u00e1ctica anterior utiliz\u00e1bamos Mistral, ahora podr\u00edamos seguir utiliz\u00e1ndola, pero cambiemos y pasemos a utilizar el ecosistema Groq, que pone a nuestra disposici\u00f3n un listado de modelos de manera totalmente gratuita y que podemos utilizar durante las pr\u00e1cticas y ejercicios de prueba.</p> <p>\u26a0\ufe0f Aviso: la informaci\u00f3n que le pasas en los prompts puede ser utilizada por la empresa y no debe ser confidencial.</p> <p>Para empezar a utilizar Groq debemos de crear la API_KEY que usaremos para acceder al modelo. Accede a https://console.groq.com/keys.</p> <p>Al pulsar en \u201cLogin\u201d nos podemos logear con nuestra cuenta de Gmail o cualquiera de los m\u00e9todos que nos propone de manera gratuita</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#creacion-de-api_key","title":"Creaci\u00f3n de API_KEY","text":"<p>Hemos escogido Groq por la variedad de modelos que nos permite utilizar de manera totalmente gratuita que nos permite programar sin tener GPU.</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#ecosistema-groq_1","title":"Ecosistema Groq:","text":"<p>Vemos que la oferta es muy grande si ejecutamos el curl que nos devuelve los modelos que Groq permite utilizar :</p> <pre><code>curl https://api.groq.com/openai/v1/models \\ -H \"Authorization: Bearer $GROQ_API_KEY\"\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#configuracion-de-variable-de-entorno","title":"Configuraci\u00f3n de variable de entorno","text":"<p>Podemos poner directamente la API_KEY donde hemos escrito $GROQ_API_KEY o configurar $GROQ_API_KEY en Ubuntu en el fichero \u201c.bashrc\u201d a\u00f1adiendo al final del fichero una linea con:</p> <p>En Ubuntu (en <code>.bashrc</code>):</p> <pre><code>export GROQ_API_KEY=\"aqu\u00ed_tu_clave\"\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#tabla-de-modelos-groq-octubre-2025","title":"Tabla de modelos Groq (Octubre 2025)","text":"Categor\u00eda Nombre del Modelo (ID) Propietario Ventana de Contexto L\u00edmite de Respuesta Uso Recomendado Text-to-Speech playai-tts PlayAI 8192 8192 S\u00edntesis de voz general Text-to-Speech playai-tts-arabic PlayAI 8192 8192 S\u00edntesis de voz en \u00e1rabe Text Generation groq/compound Groq 131072 8192 Generaci\u00f3n de texto general Text Generation meta-llama/llama-4-scout-17b-16e-instruct Meta 131072 8192 Instrucciones y conversaciones Text Generation alam-2-7b SDAIA 4096 4096 Generaci\u00f3n de texto b\u00e1sico Text Generation openalign-oss-20b OpenAI 131072 65536 Texto largo y complejo Text Generation querytower-3-32b Alibaba Cloud 131072 40500 Chat multiling\u00fce Text Generation llama-3.3-70b-versatile Meta 131072 32766 Tareas vers\u00e1tiles Text Generation moonshotalk/mini-k2-instruct Moonshot AI 131072 16384 Instrucciones y razonamiento Text Generation moonshotalk/mini-k2-instruct-0905 Moonshot AI 262144 16384 Contextos muy largos Text Generation groq/compound-mini Groq 131072 8192 Generaci\u00f3n eficiente Text Generation meta-llama/llama-4-maverick-17b-128e-instruct Meta 131072 8192 Instrucciones especializadas Text Generation openalign-oss-120b OpenAI 131072 65536 Tareas complejas Text Generation llama-3.1-8b-instant Meta 131072 131072 Respuestas instant\u00e1neas Speech-to-Text whisper-large-v3-turbo OpenAI 448 448 Transcripci\u00f3n r\u00e1pida Speech-to-Text whisper-large-v3 OpenAI 448 448 Transcripci\u00f3n de alta calidad Specialized (Moderation) meta-llama/llama-guard-4-12b Meta 131072 1024 Moderaci\u00f3n de contenido Specialized (Moderation) meta-llama/llama-prompt-guard-2-22m Meta 512 512 Moderaci\u00f3n b\u00e1sica de prompts Specialized (Moderation) meta-llama/llama-prompt-guard-2-96m Meta 512 512 Moderaci\u00f3n avanzada de prompts <p>Normalmente si superas la ventana de contexto (limite del texto de la pregunta) el modelo olvidar\u00e1 las primeras palabras. 1 token \u2248 0.75 palabras en ingl\u00e9s.</p> <p>\u26a0\ufe0f Nota: Groq actualiza la lista de modelos sin previo aviso.</p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#nuestro-primer-chatbot-de-ia-en-java","title":"Nuestro primer chatbot de IA en Java","text":""},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#1-crear-proyecto-spring-boot","title":"1. Crear proyecto Spring Boot","text":"<p>Accede a https://start.spring.io y configura:</p> <ul> <li>Project: Maven</li> <li>Spring Boot: 3.5.9 (o la m\u00e1s reciente estable) . En la fecha de generar esta documentaci\u00f3n la dependencia OpenAI no est\u00e1 todav\u00eda para Spring 4.</li> <li>Dependencies:</li> <li>Spring Web</li> <li>Thymeleaf</li> <li>OpenAI (Spring AI)</li> <li>Java: 17 o 21</li> </ul> <p></p> <p>Genera y descarga el proyecto, luego \u00e1brelo con IntelliJ.</p> <p>El pom.xml deber\u00e1 contener la siguiente informaci\u00f3n:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.5.9&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.cipfpcheste.dam2&lt;/groupId&gt;\n    &lt;artifactId&gt;chatbot&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;chatbot&lt;/name&gt;\n    &lt;description&gt;Ejemplo de chatbot con SpringIA&lt;/description&gt;\n    &lt;url/&gt;\n    &lt;licenses&gt;\n        &lt;license/&gt;\n    &lt;/licenses&gt;\n    &lt;developers&gt;\n        &lt;developer/&gt;\n    &lt;/developers&gt;\n    &lt;scm&gt;\n        &lt;connection/&gt;\n        &lt;developerConnection/&gt;\n        &lt;tag/&gt;\n        &lt;url/&gt;\n    &lt;/scm&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;21&lt;/java.version&gt;\n        &lt;spring-ai.version&gt;1.1.2&lt;/spring-ai.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-ai-starter-model-openai&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;\n                &lt;version&gt;${spring-ai.version}&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#2-configuracion-de-applicationproperties","title":"2. Configuraci\u00f3n de <code>application.properties</code>","text":"<pre><code>spring.application.name=chatbot\nserver.port=8090\n#Configuramos el encoding\nserver.servlet.encoding.charset=UTF-8\nserver.servlet.encoding.enabled=true\nserver.servlet.encoding.force=true\n\n# Para obtener API_KEY DE Groq: https://console.groq.com/keys\n# 2 OPCIONES para configurar la API_KEY en la webapp de Spring Boot:\n# 1\u00ba Poner la clave directamente:\n# spring.ai.openai.api-key=aqui tu clave\n# 2\u00ba Utilizar una variable del sistema operativo (GROQ_API_KEY) y leerla aqu\u00ed:\nspring.ai.openai.api-key=${GROQ_API_KEY} \n# si no te funciona, coloca esto:\n# spring.ai.openai.api-key=sk-aqui tu clave\n# Url de la API de GROQ:\nspring.ai.openai.base-url=https://api.groq.com/openai\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#3-estructura-del-proyecto","title":"3. Estructura del proyecto","text":"<pre><code>src/main/java/com/example/chatbot/\n\u251c\u2500\u2500 ChatbotApplication.java\n\u251c\u2500\u2500 controller/\n\u2502   \u251c\u2500\u2500 GroqAIController.java\n\u2502   \u2514\u2500\u2500 FrontendController.java\n\u2514\u2500\u2500 service/\n    \u251c\u2500\u2500 GroqAIService.java\n    \u2514\u2500\u2500 impl/\n        \u2514\u2500\u2500 GroqAIServiceImpl.java\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#4-interfaz-groqaiservice","title":"4. Interfaz: <code>GroqAIService</code>","text":"<p>Empezamos nuestra API Rest definiendo los 2 m\u00e9todo p\u00fablicos que queremos que tenga el servicio GroqAIService, la presentaci\u00f3n del humorista y el chiste. Para aquellos que no han trabajado nunca con SpringBoot, creamos el fichero GroqAIService.java en el mismo directorio que ChatbotApplication.java y al indicar el nombre del paquete nos situamos encima de la linea en rojo y seleccionamos Quick Fix y Move:</p> <pre><code>package com.cipfpcheste.dam2.chatbot.service;\n\npublic interface GroqAIService {    /**\n * Genera una respuesta de presentaci\u00f3n personalizada para el usuario.\n *\n * @param nombre El nombre del usuario que se incluir\u00e1 en la presentaci\u00f3n\n * @return Un String que contiene la respuesta de presentaci\u00f3n generada por la IA\n */\n\nString getPresentacionAlUsuario(String nombre);\n\n    /**\n     * Genera una respuesta con un chiste sobre la tem\u00e1tica especificada.\n     *\n     * @param tema La tem\u00e1tica sobre la cual se generar\u00e1 el chiste\n     * @return Un String que contiene el chiste generado por la IA\n     */\n    String getChisteTematico(String tema);\n\n}\n\n``\n![GroqAIService](./img/GroqAIService.png)\n\n\n### 5. Servicio: `GroqAIServiceImpl`\n\nUna vez declarada la interface GroqAIService ya podemos declarar en el subpaquete \u2018impl\u2019 la clase que implementar\u00e1 ese servicio en la pr\u00e1ctica: GroqAIServiceImpl.\nEn la implementaci\u00f3n nos apoyaremos en los m\u00e9todo privados: getOptions, generateResponse, getPromptPresentacionAlUsuario y getPromptChisteTematico:\n\n```java\npackage com.cipfpcheste.dam2.chatbot.service.impl;\n\n\nimport com.cipfpcheste.dam2.chatbot.service.GroqAIService;\nimport org.springframework.ai.chat.messages.Message;\nimport org.springframework.ai.chat.model.ChatModel;\nimport org.springframework.ai.chat.model.ChatResponse;\nimport org.springframework.ai.chat.prompt.Prompt;\nimport org.springframework.ai.chat.prompt.PromptTemplate;\nimport org.springframework.ai.openai.OpenAiChatOptions;\nimport org.springframework.stereotype.Service;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Clase de servicio para interactuar con un modelo de chat y generar respuestas basadas en prompts.\n * Este servicio est\u00e1 dise\u00f1ado para proporcionar una experiencia de chatbot con la capacidad de\n * presentarse y contar chistes tem\u00e1ticos de manera sensible y amigable para el usuario.\n */\n@Service\npublic class GroqAIServiceImpl implements GroqAIService {\n\n    private final ChatModel chatModel;\n\n    /**\n     * Construye una nueva instancia de GroqAIService con el modelo de chat especificado.\n     *\n     * @param chatModel el modelo de chat que se utilizar\u00e1 para generar respuestas\n     */\n    public GroqAIServiceImpl(ChatModel chatModel) {\n        this.chatModel = chatModel;\n    }\n    // Definir el nombre del modelo de Groq (LLM) que utilizaremos\n    private final String modelName = \"llama-3.3-70b-versatile\";\n    //Definir el limite de tokens de respuesta para el modelo llama-3.3-70b-versatile\n    private final String maxTokens = \"32768\";\n\n    /**\n     * Configura y devuelve las opciones para el modelo de chat Groq AI.\n     *\n     * Este m\u00e9todo crea un objeto OpenAiChatOptions con configuraciones predefinidas:\n     * - Utiliza el modelo especificado en modelName\n     * - Establece la temperatura en 0.4 para equilibrar creatividad/consistencia\n     * - Establece el m\u00e1ximo de tokens basado en la configuraci\u00f3n maxTokens\n     *\n     * @return OpenAiChatOptions objeto configurado con los par\u00e1metros especificados\n     */\n    private OpenAiChatOptions getOptions() {\n        OpenAiChatOptions options = OpenAiChatOptions.builder()\n                .model(modelName)\n                .temperature(0.4)\n                .maxTokens(Integer.parseInt(maxTokens))\n                .build();\n        return options;\n    }\n\n    /**\n     * Genera una respuesta utilizando el modelo de chat basado en el prompt proporcionado.\n     *\n     * @param prompt El objeto prompt que contiene el mensaje de entrada para generar una respuesta\n     * @return La respuesta generada como texto en formato String\n     * @throws RuntimeException si el modelo de chat falla al generar una respuesta\n     */\n\n    private String generateResponse(Prompt prompt) {\n        ChatResponse response = chatModel.call(prompt);\n        return response.getResult().getOutput().getText();\n    }\n\n    /**\n     * Genera una respuesta de presentaci\u00f3n personalizada para el usuario.\n     *\n     * @param nombre El nombre del usuario que se incluir\u00e1 en la presentaci\u00f3n\n     * @return Un String que contiene la respuesta de presentaci\u00f3n generada por la IA\n     */\n\n    @Override\n    public String getPresentacionAlUsuario(String nombre) {\n        return generateResponse(getPromptPresentacionAlUsuario(nombre));\n    }\n\n    /**\n     * Genera una respuesta con un chiste sobre la tem\u00e1tica especificada.\n     *\n     * @param tema La tem\u00e1tica sobre la cual se generar\u00e1 el chiste\n     * @return Un String que contiene el chiste generado por la IA\n     */\n    @Override\n    public String getChisteTematico(String tema) {\n        return generateResponse(getPromptChisteTematico(tema));\n    }\n\n    /**\n     * Crea un prompt para la interacci\u00f3n inicial con el usuario, configurando un chatbot de IA\n     * que se especializa en contar chistes.\n     *\n     * El m\u00e9todo configura una plantilla de prompt que presenta al chatbot con un nombre dado\n     * y lo prepara para contar chistes sobre cualquier tema solicitado por el usuario.\n     *\n     * @param nombre El nombre que se usar\u00e1 para el chatbot en la interacci\u00f3n\n     * @return Prompt Un objeto prompt configurado que contiene el mensaje y las opciones de chat OpenAI\n     */\n\n    private Prompt getPromptPresentacionAlUsuario(String nombre) {\n        // 1. Crear plantilla de prompt con variables\n        PromptTemplate promptTemplate = new PromptTemplate(\n                \"\"\"\n                    Por favor, act\u00faa como chatBot de inteligencia artificial llamado '{nombre}'\n                    que siempre tiene ingenio para contar chistes sobre cualquier tem\u00e1tica.\n                    No hace falta que hagas una introducci\u00f3n, simplemente pres\u00e9ntate y pregunta \n                    sobre qu\u00e9 tem\u00e1tica le gustar\u00eda al usuario que le contaras un chiste en una \n                    frase no demasiado larga.\n                    Por favor, ten cuidado y s\u00e9 sensible respecto al contenido.\n                \"\"\"\n        );\n        // 2. Reemplazar variables en el prompt\n        Message message = promptTemplate.createMessage(\n                Map.of(\"nombre\", nombre)\n        );\n        // 3. Leer las opciones del modelo\n        OpenAiChatOptions options = getOptions();\n        // 4. Crear Prompt combinando mensaje y opciones\n        return new Prompt(List.of(message), options);\n    }\n\n    /**\n     * Crea un prompt para generar un chiste sobre una tem\u00e1tica espec\u00edfica.\n     *\n     * El m\u00e9todo configura una plantilla de prompt que solicita al modelo\n     * generar un chiste apropiado sobre el tema proporcionado, asegurando\n     * que el contenido sea adecuado y sensible.\n     *\n     * @param tema La tem\u00e1tica sobre la cual se generar\u00e1 el chiste\n     * @return Prompt Un objeto prompt configurado con el mensaje y las opciones de chat\n     */\n    private Prompt getPromptChisteTematico(String tema) {\n        // 1. Crear plantilla de prompt con variables\n        PromptTemplate promptTemplate = new PromptTemplate(\n                \"\"\"\n                    Vas a actuar como una persona graciosa y contarme un chiste sobre la tem\u00e1tica \n                    '{tema}' teniendo en cuenta lo siguiente:\n                    \u00b7 Si crees que la tem\u00e1tica es sobre un tema controvertido que puede ofender a alguien,\n                    por favor, cambia la tem\u00e1tica a algo m\u00e1s seguro lo m\u00e1s parecido posible a la tem\u00e1tica original,\n                    pero no digas que has cambiado de tem\u00e1tica.\n                    \u00b7 No empieces diciendo la tem\u00e1tica del chiste ni cu\u00e1l es tu intenci\u00f3n al contarlo, simplemente \n                    cuenta el chiste de una manera graciosa y divertida sin ser demasiado escueto ni demasiado largo.\n                    \u00b7 El chiste debe ser adecuado para un p\u00fablico general pensando que lo est\u00e1 contando un \n                    profesor a sus alumnos. Por favor, ten cuidado y s\u00e9 sensible respecto al contenido.\n                    \u00b7 Por \u00faltimo, acaba preguntando al usuario de manera divertida y sobre todo escueta sobre qu\u00e9 \n                    otra tem\u00e1tica le gustar\u00eda que le contaras un chiste.\n                \"\"\"\n        );\n        // 2. Reemplazar variables en el prompt\n        Message message = promptTemplate.createMessage(\n                Map.of(\"tema\", tema)\n        );\n        // 3. Leer las opciones del modelo\n        OpenAiChatOptions options = getOptions();\n        // 4. Crear Prompt combinando mensaje y opciones\n        return new Prompt(List.of(message), options);\n    }\n}\n</code></pre> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#6-controlador-groqaicontroller","title":"6. Controlador: <code>GroqAIController</code>","text":"<p>El controlador de esta API Rest cuenta chistes es muy reducido porque utiliza el servicio para llamar a las funciones \u2018getPresentacionAlUsuario\u2019 para presentarse y \u2018getChisteTematico\u2019 para contar un chiste de un tema concreto:</p> <pre><code>package com.cipfpcheste.dam2.chatbot.service.controller;\n\nimport com.cipfpcheste.dam2.chatbot.service.GroqAIService;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"api/v1\")\npublic class GroqAIController {\n\n    private final GroqAIService groqService;\n\n    public GroqAIController(GroqAIService groqService) {\n        this.groqService = groqService;\n    }\n\n    @GetMapping(\"/getPresentacionAlUsuario\")\n    public String getPresentacionAlUsuario() {\n        return groqService.getPresentacionAlUsuario(\"Simarret\");\n    }\n\n    @GetMapping(\"/getChisteTematico\")\n    public String getChisteTematico(@RequestParam String tema) {\n        return groqService.getChisteTematico(tema);\n    }\n}\n</code></pre> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#61-depurando-y-probando","title":"6.1. Depurando y probando","text":"<p>Vamos al explorador del proyecto y entramos en el controlador. Pongamos un punto de interrupci\u00f3n en la linea 21 (donde el controller solicita al servicio de Groq que se presente). Para hacerlo pulsamos en la parte izquierda del n\u00famero de linea y aparecer\u00e1 un punto rojo. Si en el navegador entramos en la url veremos como se para en esa linea. Si queremos continuar le damos al play y nos mostrar\u00e1 la presentaci\u00f3n:</p> <p></p> <p>Accede desde el navegador a la url: http://localhost:8090/api/v1/getPresentacionAlUsuario</p> <p>Si vas dando un step by step ver\u00e1s que al final te devuelve lo siguiente:</p> <p></p> <p>Quita el break point y bamos ahora a probar el API.</p> <p>Prueba esta: http://localhost:8090/api/v1/getChisteTematico?tema=programadores</p> <p></p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#7-frontend-con-thymeleaf","title":"7. Frontend con Thymeleaf","text":""},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#71-frontendcontroller","title":"7.1. FrontendController","text":"<p>Ahora vamos a sacar provecho de la dependencia Thymeleaf para poder crear un chatbot con interface gr\u00e1fica. Empezamos creando el controlador que renderizar\u00e1 la p\u00e1gina principal del chatbot:</p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#frontendcontrollerjava","title":"<code>FrontendController.java</code>","text":"<p><pre><code>package com.cipfpcheste.dam2.chatbot.service.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class FrontendController {\n    // Este controlador maneja la ruta ra\u00edz y devuelve la vista index.html\n    @GetMapping(\"/\")\n    public String index(Model model) {\n        // Aqu\u00ed puedes agregar datos al modelo si fuera necesario\n        return \"index\"; // Renderiza index.html\n    }\n}\n</code></pre> </p>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#archivos-estaticos","title":"Archivos est\u00e1ticos","text":"<p>Coloca en <code>src/main/resources/</code>:</p> <ul> <li><code>static/css/styles.css</code> styles.css</li> <li><code>static/images/logo_simarro.jpg</code> logo_simarro.jpg</li> <li><code>static/images/simarret.jpg</code> simarret.jpg</li> <li><code>static/js/script.js</code> script.js</li> <li><code>templates/index.html</code> index.html</li> </ul>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#8-ejecucion-y-prueba","title":"8. Ejecuci\u00f3n y prueba","text":"<ol> <li>Ejecuta la aplicaci\u00f3n</li> <li>Accede a:</li> <li><code>http://localhost:8090/api/v1/getPresentacionAlUsuario</code></li> <li><code>http://localhost:8090/api/v1/getChisteTematico?tema=programadores</code></li> <li><code>http://localhost:8090/</code> (interfaz web)</li> </ol>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#_1","title":"NLP: SpringAI","text":""},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#creatividad-del-llm","title":"Creatividad del LLM","text":""},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#parametros-de-control","title":"Par\u00e1metros de control","text":""},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#temperatura-temperature","title":"Temperatura (<code>temperature</code>)","text":"<p>Controla el grado de aleatoriedad en las respuestas.</p> Valor Efecto Casos de Uso 0.0 Determinista, repetitivo Hechos cient\u00edficos, respuestas t\u00e9cnicas 0.1\u20130.4 Conservador, enfocado Asistentes profesionales, chatbots empresariales 0.5\u20130.7 Equilibrio creatividad/coherencia (recomendado) Redacci\u00f3n creativa, brainstorming 0.8\u20131.0+ Altamente creativo/impredecible Poes\u00eda, ideas disruptivas"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#top-p-nucleus-sampling","title":"Top-P (Nucleus Sampling)","text":"<p>Controla la diversidad restringiendo la selecci\u00f3n a un subconjunto de opciones probables.</p> Valor Comportamiento Uso 0.1 Muy conservador Traducciones t\u00e9cnicas 0.5 Equilibrio coherencia/variedad Respuestas creativas pero relevantes 0.9 Diverso y original Historias, di\u00e1logos 1.0 M\u00e1xima diversidad Experimentaci\u00f3n art\u00edstica"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#combinaciones-recomendadas","title":"Combinaciones recomendadas","text":"<pre><code>OpenAiChatOptions.builder()\n    .model(\"llama-3.3-70b-versatile\")\n    .temperature(0.7)    // Creatividad media\n    .topP(0.9)           // Diversidad controlada\n    .maxTokens(32768)\n    .build();\n</code></pre>"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#guia-rapida","title":"Gu\u00eda r\u00e1pida","text":"Objetivo Temperature Top-P Respuestas t\u00e9cnicas 0.1\u20130.3 0.1\u20130.3 Chat creativo 0.6\u20130.8 0.7\u20130.9 Generaci\u00f3n de ideas 0.9\u20131.2 0.9\u20131.0 Poes\u00eda/Arte 1.0\u20131.5 1.0"},{"location":"Unidad%207%20IA/NLP%20con%20Spring%20AI%20Desarrollo%20de%20Chatbots%20en%20Java/#entrega-chatbot","title":"Entrega: Chatbot","text":"<p>Crea un nuevo proyecto Spring Boot (o Flask en Python) que utilice los modelos de Groq.</p> <p>Se valorar\u00e1:</p> <ul> <li>Funcionalidad interesante (texto, audio, moderaci\u00f3n, etc.).</li> <li>Experimentaci\u00f3n con <code>temperature</code> y <code>top_p</code>.</li> <li>Informe con conclusiones sobre el comportamiento del modelo.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/","title":"ChefAI - Documentacion didactica","text":"<p>Explicaci\u00f3n del funcionamiento de la app, el flujo de datos y las partes principales.</p>"},{"location":"Unidad%207%20IA/ChefAI/#que-hace-el-proyecto","title":"Que hace el proyecto","text":"<p>ChefAI es una app web con Spring Boot y Thymeleaf que genera recetas saludables a partir de ingredientes. El usuario completa un formulario y la app consulta un modelo de IA (Groq) para devolver la receta.</p>"},{"location":"Unidad%207%20IA/ChefAI/#tecnologias-principales","title":"Tecnologias principales","text":"<ul> <li>Spring Boot (aplicacion y servidor web)</li> <li>Spring MVC (controladores y vistas)</li> <li>Thymeleaf (plantillas HTML)</li> <li>Spring AI + Groq (llamada al modelo)</li> <li>HTML + CSS + JavaScript (interfaz)</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/#estructura-general-del-proyecto","title":"Estructura general del proyecto","text":"<ul> <li><code>src/main/java</code> contiene el backend (controlador, servicio, modelos y main).</li> <li><code>src/main/resources/templates</code> contiene las vistas Thymeleaf.</li> <li><code>src/main/resources/static</code> contiene CSS y JavaScript.</li> <li><code>src/main/resources/application.properties</code> contiene la configuracion.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/#flujo-de-la-aplicacion","title":"Flujo de la aplicaci\u00f3n","text":"<ol> <li>El navegador abre <code>/</code> y el controlador devuelve la vista <code>index</code>.</li> <li>El usuario rellena el formulario y envia el POST <code>/receta</code>.</li> <li>El servicio valida la entrada y construye un prompt.</li> <li>Se llama al modelo de IA y se limpia la respuesta.</li> <li>Se devuelve la receta a la vista y se muestra en pantalla.</li> </ol> <p>El proyecto completo lo podemos encontrar aqu\u00ed</p>"},{"location":"Unidad%207%20IA/ChefAI/clases/","title":"Clases del backend","text":"<p>A continuacion se documentan todas las clases Java del proyecto. Se detalla su responsabilidad, elementos y relacion con otras clases.</p>"},{"location":"Unidad%207%20IA/ChefAI/clases/#1-chefaiapplication","title":"1) ChefAiApplication","text":"<p>Ruta: <code>src/main/java/org/cipfpcheste/dam2/chefai/ChefAiApplication.java</code></p> <p>Responsabilidad</p> <ul> <li>Punto de entrada de la aplicacion Spring Boot.</li> <li>Inicia el contexto de Spring y el servidor embebido.</li> </ul> <p>Elementos principales</p> <ul> <li> <p>Anotacion <code>@SpringBootApplication</code>:</p> </li> <li> <p>Activa el escaneo de componentes.</p> </li> <li>Habilita la autoconfiguracion.</li> <li> <p>Permite usar configuracion basada en clases.</p> </li> <li> <p>Metodo <code>main(String[] args)</code>:</p> </li> <li> <p>Es el metodo que arranca la aplicacion.</p> </li> <li>Llama a <code>SpringApplication.run(...)</code>.</li> </ul> <p>Interacciones</p> <ul> <li>No depende directamente de otras clases del proyecto.</li> <li>Permite que Spring detecte <code>@Controller</code> y <code>@Service</code>.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/clases/#2-recipecontroller","title":"2) RecipeController","text":"<p>Ruta: <code>src/main/java/org/cipfpcheste/dam2/chefai/controlador/RecipeController.java</code></p> <p>Responsabilidad</p> <ul> <li>Controlador web MVC.</li> <li>Recibe peticiones HTTP y devuelve la vista <code>index</code>.</li> </ul> <p>Anotaciones</p> <ul> <li><code>@Controller</code>: indica que esta clase gestiona peticiones web y devuelve vistas.</li> <li><code>@GetMapping(\"/\")</code>: mapea la ruta raiz para mostrar el formulario.</li> <li><code>@PostMapping(\"/receta\")</code>: mapea el envio del formulario.</li> </ul> <p>Atributos</p> <ul> <li><code>private final RecetaService recetaService</code>:</li> <li>Servicio que contiene la logica de negocio.</li> <li>Se inyecta por constructor (inyeccion de dependencias).</li> </ul> <p>Constructores</p> <ul> <li><code>RecipeController(RecetaService recetaService)</code>:</li> <li>Spring inyecta el servicio automaticamente.</li> </ul> <p>Metodos</p> <ul> <li><code>showHomePage(Model model)</code>:</li> <li>Entradas: <code>Model model</code>.</li> <li>Acciones:<ul> <li>Crea un <code>RecetaRequest</code> y un <code>RecetaResponse</code> vacios.</li> <li>Los coloca en el <code>model</code> para que la vista los use.</li> </ul> </li> <li> <p>Salida: devuelve la vista <code>index</code>.</p> </li> <li> <p><code>generateReceta(@ModelAttribute RecetaRequest request, Model model)</code>:</p> </li> <li> <p>Entradas:</p> <ul> <li><code>RecetaRequest request</code>: datos del formulario.</li> <li><code>Model model</code>: datos para la vista.</li> </ul> </li> <li>Acciones:<ul> <li>Llama a <code>recetaService.generateRecipe(...)</code>.</li> <li>Si todo va bien, a\u00f1ade <code>success</code> y la respuesta.</li> <li>Si hay error, a\u00f1ade <code>error</code> y una respuesta vacia.</li> </ul> </li> <li>Salida: devuelve la vista <code>index</code>.</li> </ul> <p>Notas didacticas</p> <ul> <li><code>@ModelAttribute</code> enlaza el formulario con el DTO de entrada.</li> <li>El controlador no implementa la logica del modelo; solo coordina.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/clases/#3-recetaservice","title":"3) RecetaService","text":"<p>Ruta: <code>src/main/java/org/cipfpcheste/dam2/chefai/service/RecetaService.java</code></p> <p>Responsabilidad</p> <ul> <li>Encapsula la logica de negocio para generar recetas.</li> <li>Se encarga de validar, crear el prompt y llamar a la IA.</li> </ul> <p>Anotaciones</p> <ul> <li><code>@Service</code>: indica que es un servicio de Spring.</li> </ul> <p>Atributos</p> <ul> <li><code>private final ChatClient chatClient</code>:</li> <li>Cliente para llamar al modelo via Spring AI.</li> <li>Se crea usando un <code>ChatClient.Builder</code>.</li> </ul> <p>Constructor</p> <ul> <li><code>RecetaService(ChatClient.Builder chatClientBuilder)</code>:</li> <li>Construye el cliente con <code>chatClientBuilder.build()</code>.</li> </ul> <p>Metodos</p> <ul> <li><code>generateRecipe(RecetaRequest request)</code>:</li> <li>Entradas: <code>RecetaRequest</code> con ingredientes, tipo y objetivo.</li> <li> <p>Pasos:</p> <ol> <li><code>validateRequest(request)</code> valida la entrada.</li> <li><code>createRecipePrompt(request)</code> crea el texto para la IA.</li> <li>Configura <code>OpenAiChatOptions</code> (modelo, temperatura, tokens).</li> <li>Llama al modelo con <code>chatClient.prompt().user(...).call()</code>.</li> <li>Limpia la salida con <code>cleanRecipeText(...)</code>.</li> <li>Devuelve un <code>RecetaResponse</code> con los datos finales.</li> </ol> </li> <li> <p>Salida: <code>RecetaResponse</code>.</p> </li> <li> <p>Errores: lanza <code>RuntimeException</code> si falla la llamada.</p> </li> <li> <p><code>createRecipePrompt(RecetaRequest request)</code>:</p> </li> <li>Objetivo: construir el prompt con formato.</li> <li> <p>Salida: <code>String</code> listo para enviar a la IA.</p> </li> <li> <p><code>cleanRecipeText(String text)</code>:</p> </li> <li>Objetivo: eliminar comillas y espacios sobrantes.</li> <li> <p>Salida: <code>String</code> limpio.</p> </li> <li> <p><code>validateRequest(RecetaRequest request)</code>:</p> </li> <li>Objetivo: validar campos vacios y longitud maxima.</li> <li>Errores: <code>IllegalArgumentException</code> si hay errores.</li> </ul> <p>Notas didacticas</p> <ul> <li>Se separa la logica del controlador (principio SRP).</li> <li>Los metodos privados ayudan a mantener el codigo ordenado.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/clases/#4-recetarequest","title":"4) RecetaRequest","text":"<p>Ruta: <code>src/main/java/org/cipfpcheste/dam2/chefai/modelo/RecetaRequest.java</code></p> <p>Responsabilidad</p> <ul> <li>DTO de entrada con los datos del formulario.</li> </ul> <p>Anotaciones (Lombok)</p> <ul> <li><code>@Data</code>:</li> <li>Genera getters, setters, <code>toString</code>, <code>equals</code>, <code>hashCode</code>.</li> <li><code>@AllArgsConstructor</code>:</li> <li>Crea constructor con todos los campos.</li> <li><code>@NoArgsConstructor</code>:</li> <li>Crea constructor vacio.</li> </ul> <p>Campos</p> <ul> <li><code>private String ingredientes</code>:</li> <li>Texto con ingredientes disponibles.</li> <li><code>private String tipoComida</code>:</li> <li>Tipo de comida (desayuno, almuerzo, etc.).</li> <li><code>private String objetivoDieta</code>:</li> <li>Objetivo saludable (alto en proteina, bajo en carbohidratos, etc.).</li> </ul> <p>Uso</p> <ul> <li>Se rellena automaticamente desde el formulario web.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/clases/#5-recetaresponse","title":"5) RecetaResponse","text":"<p>Ruta: <code>src/main/java/org/cipfpcheste/dam2/chefai/modelo/RecetaResponse.java</code></p> <p>Responsabilidad</p> <ul> <li>DTO de salida con la receta generada y los datos asociados.</li> </ul> <p>Anotaciones (Lombok)</p> <ul> <li><code>@Data</code>, <code>@AllArgsConstructor</code>, <code>@NoArgsConstructor</code>.</li> </ul> <p>Campos</p> <ul> <li><code>private String ingredientes</code>:</li> <li>Ingredientes recibidos (se muestran en pantalla).</li> <li><code>private String receta</code>:</li> <li>Texto de la receta generado por la IA.</li> <li><code>private String tipoComida</code>:</li> <li>Tipo de comida solicitado.</li> <li><code>private String objetivoDieta</code>:</li> <li>Objetivo saludable solicitado.</li> </ul> <p>Uso</p> <ul> <li>Se crea en <code>RecetaService</code> y se envia al controlador.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/configuracion/","title":"Configuracion (application.properties)","text":"<p>Archivo: <code>src/main/resources/application.properties</code></p> <p>Este archivo define propiedades de Spring Boot, el servidor y la integracion con la API.</p>"},{"location":"Unidad%207%20IA/ChefAI/configuracion/#propiedades-y-significado","title":"Propiedades y significado","text":"<ul> <li> <p>Nombre logico de la aplicacion.</p> </li> <li> <p><code>spring.application.name=ChefAI</code></p> </li> <li> <p>Puerto HTTP en el que se levanta la app.</p> </li> <li> <p><code>server.port=8080</code></p> </li> <li> <p>Contexto base. Con <code>/</code> la app queda en la raiz del servidor.</p> </li> <li> <p><code>server.servlet.context-path=/</code></p> </li> <li> <p>URL base para las llamadas a la API compatible con OpenAI (Groq).</p> </li> <li> <p><code>spring.ai.openai.base-url=https://api.groq.com/openai</code></p> </li> <li> <p>Clave de API para autenticar las llamadas.</p> </li> <li>Recomendacion didactica: en produccion se debe usar una variable de entorno y no dejar la clave en el repositorio.</li> <li> <p><code>spring.ai.openai.api-key=...</code></p> </li> <li> <p>Carpeta de plantillas Thymeleaf.</p> </li> <li> <p><code>spring.thymeleaf.prefix=classpath:/templates/</code></p> </li> <li> <p>Extension de las vistas.</p> </li> <li> <p><code>spring.thymeleaf.suffix=.html</code></p> </li> <li> <p>Modo de procesado de Thymeleaf.</p> </li> <li> <p><code>spring.thymeleaf.mode=HTML</code></p> </li> <li> <p>Codificacion de caracteres para las vistas.</p> </li> <li> <p><code>spring.thymeleaf.encoding=UTF-8</code></p> </li> <li> <p>Tipo de contenido devuelto por el motor de vistas.</p> </li> <li> <p><code>spring.thymeleaf.servlet.content-type=text/html</code></p> </li> <li> <p>Carpeta para recursos estaticos (CSS, JS, imagenes).</p> </li> <li> <p><code>spring.web.resources.static-locations=classpath:/static/</code></p> </li> <li> <p>Nivel de log para un paquete concreto.</p> </li> <li><code>llogging.level.org.cipfpcheste.dam2.chefai=debug</code></li> </ul> <p>Info</p> <ul> <li>Mover la API key a variables de entorno.</li> <li>Mantener propiedades sensibles fuera del repositorio.</li> <li>Ajustar niveles de log segun entorno (DEV vs PROD).</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/frontend/","title":"Frontend (HTML, CSS y JavaScript)","text":"<p>El frontend se compone de una vista Thymeleaf y recursos estaticos.</p>"},{"location":"Unidad%207%20IA/ChefAI/frontend/#vista-principal-thymeleaf","title":"Vista principal (Thymeleaf)","text":"<p>Archivo: <code>src/main/resources/templates/index.html</code></p> <p>Estructura general</p> <ul> <li><code>&lt;!DOCTYPE html&gt;</code> y <code>&lt;html lang=\"es\"&gt;</code> definen el idioma y el documento.</li> <li><code>&lt;head&gt;</code> carga el CSS <code>href=\"/style.css\"</code>.</li> <li><code>&lt;body&gt;</code> contiene la app dentro de <code>.container</code>.</li> </ul> <p>Cabecera</p> <ul> <li><code>.header</code> muestra el titulo, un subtitulo y una etiqueta de tecnologia.</li> </ul> <p>Mensajes de estado</p> <ul> <li>Bloques con <code>th:if</code> para mostrar mensajes de exito o error:</li> <li><code>th:if=\"${success}\"</code> y <code>th:text=\"${success}\"</code>.</li> <li><code>th:if=\"${error}\"</code> y <code>th:text=\"${error}\"</code>.</li> </ul> <p>Formulario</p> <ul> <li>Se envia a <code>POST /receta</code> con <code>th:action</code>.</li> <li><code>textarea#ingredientes</code>:</li> <li><code>name=\"ingredientes\"</code> enlaza con <code>RecetaRequest.ingredientes</code>.</li> <li><code>th:text</code> rellena el texto en caso de recarga.</li> <li><code>select#tipoComida</code>:</li> <li><code>name=\"tipoComida\"</code>.</li> <li><code>select#objetivoDieta</code>:</li> <li><code>name=\"objetivoDieta\"</code>.</li> </ul> <p>Nota didactica importante</p> <ul> <li>En Spring MVC, el <code>name</code> del formulario debe coincidir con el nombre del atributo del DTO.</li> <li>En este proyecto, los <code>name</code> del HTML coinciden con <code>tipoComida</code> y <code>objetivoDieta</code> del DTO, por lo que el binding es directo.</li> </ul> <p>Resultado</p> <ul> <li>Se muestra solo si hay receta:</li> <li><code>th:if=\"${recetaResponse != null and recetaResponse.receta != null and recetaResponse.receta != ''}\"</code></li> <li>Presenta ingredientes y receta generada en columnas.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/frontend/#estilos-css","title":"Estilos CSS","text":"<p>Archivo: <code>src/main/resources/static/style.css</code></p> <p>Variables CSS (<code>:root</code>)</p> <ul> <li>Define la paleta de colores (<code>--cream</code>, <code>--sage</code>, <code>--copper</code>, etc.).</li> <li>Facilita cambios globales en la interfaz.</li> </ul> <p>Tipografia y fondo</p> <ul> <li>Usa fuentes de Google Fonts.</li> <li>Fondo con gradientes y circulos decorativos.</li> </ul> <p>Layout principal</p> <ul> <li><code>.container</code> centra y limita el ancho.</li> <li><code>.header</code> usa un gradiente para la cabecera.</li> <li><code>.content</code> controla padding y espaciado.</li> </ul> <p>Componentes de formulario</p> <ul> <li><code>textarea</code> y <code>select</code> con borde suave y foco con sombra.</li> <li><code>.controls</code> usa grid para dos columnas.</li> <li><code>.translate-btn</code> define el boton principal con hover.</li> </ul> <p>Resultado</p> <ul> <li><code>.translation-result</code> crea un panel destacado.</li> <li><code>.result-container</code> usa dos columnas para ingredientes y receta.</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/frontend/#javascript","title":"JavaScript","text":"<p>Archivo: <code>src/main/resources/static/js/app.js</code></p> <p>Clase <code>RecipeApp</code></p> <ul> <li>Encapsula la logica del contador de caracteres.</li> </ul> <p>Metodos</p> <ul> <li><code>initializeElements()</code>:</li> <li>Obtiene <code>textarea#ingredientes</code> y <code>div#charCount</code>.</li> <li><code>attachEventListeners()</code>:</li> <li>Escucha el evento <code>input</code> del textarea.</li> <li>Llama a <code>updateCharCount()</code> al cargar.</li> <li><code>updateCharCount()</code>:</li> <li>Actualiza el texto <code>X/2000 caracteres</code>.</li> <li>Si supera 2000, aplica la clase <code>warning</code>.</li> </ul> <p>Inicializacion</p> <ul> <li>Se instancia cuando el DOM esta listo (<code>DOMContentLoaded</code>).</li> </ul>"},{"location":"Unidad%207%20IA/ChefAI/frontend/#rutas-estaticas","title":"Rutas estaticas","text":"<ul> <li>CSS se sirve desde <code>/style.css</code>.</li> <li>JS se sirve desde <code>/js/app.js</code>.</li> <li>Esto funciona porque <code>spring.web.resources.static-locations</code> apunta a <code>classpath:/static/</code>.</li> </ul>"}]}